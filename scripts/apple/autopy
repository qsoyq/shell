#! /usr/bin/env python3
# isort autopy && ruff check autopy --fix && ruff format autopy

# pip install xmltodict httpx pydantic python-dateutil

import html
import logging
import os
import re
import subprocess
import sys
import threading
import time
from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum
from functools import wraps
from itertools import chain
from pathlib import Path

import httpx
import xmltodict
from dateutil import parser
from pydantic import BaseModel, Field


def remove_html_tags(text: str):
    # 定义一个正则表达式，用于匹配HTML标签
    html_tags_re = re.compile(r"<[^>]+>")
    # 使用sub方法替换掉所有HTML标签为空字符串
    return html_tags_re.sub("", text)


class BarkPushLevel(str, Enum):
    active = "active"
    timeSensitive = "timeSensitive"
    passive = "passive"


class BarkPushScheme(BaseModel):
    title: str
    body: str
    category: str | None = Field(None, help="Reserved field, no use yet")
    device_key: str | None = Field(None, help="bark token, The key for each device")
    level: BarkPushLevel | None = Field(
        None, help="'active', 'timeSensitive', or 'passive'"
    )
    badge: int | None = Field(
        None,
        help="The number displayed next to App icon ([Apple Developer](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649864-badge))",
    )
    automaticallyCopy: str | None = Field(None, help="Must be 1")
    _copy: str | None = Field(None, help="The value to be copied", alias="copy")
    sound: str | None = Field(
        None, help="Value from [here](https://github.com/Finb/Bark/tree/master/Sounds)"
    )
    icon: str | None = Field(
        None, help="An url to the icon, available only on iOS 15 or later"
    )
    group: str | None = Field(None, help="The group of the notification")
    isArchive: str | None = Field(
        None, help="Value must be 1. Whether or not should be archived by the app"
    )
    url: str | None = Field(None, help="Url that will jump when click notification")


logger = logging.getLogger(__file__)


class BarkAPI:
    def __init__(self, token: str) -> None:
        self.token = token

    def push(self, body: BarkPushScheme) -> httpx.Response:
        """https://github.com/Finb/bark-server/blob/master/docs/API_V2.md#push"""
        url = "https://api.day.app/push"
        if not body.device_key:
            body.device_key = self.token

        # {"code":500,"message":"interface conversion: interface {} is nil, not string","timestamp":1706443398}%
        # 兼容对参数位null的处理
        paylaod = {k: v for k, v in body.dict().items() if v is not None}

        res = httpx.post(url, json=paylaod)
        logger.debug(f"bark push body: {body.dict()}")
        res.raise_for_status()
        return res


def get_bark_token():
    return os.getenv("BARK_TOKEN")


def get_mikanani_rss_url():
    return os.getenv("mikanani_rss_url")


def init():
    assert get_bark_token()
    assert get_mikanani_rss_url()


def thread_error_handler(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            token = get_bark_token()
            if token is not None:
                cb = noexception(BarkAPI(token).push)
                cb(BarkPushScheme(title="thread_error_handler", body=f"{e}"))  # type: ignore
            raise e

    return wrapper


def noexception(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            logger.warning(f"noexception: {e}", exc_info=True)
            pass

    return wrapper


class LogWriter(threading.Thread):
    def __init__(self, interval=60):
        super().__init__()
        self.interval = interval
        homedir = os.getenv("HOME", "./")
        self.log_path = p = Path(f"{homedir}/Desktop/log.txt")
        if not p.exists():
            p.touch()

    @thread_error_handler
    def run(self):
        while True:
            self.write_log()
            time.sleep(self.interval)

    def write_log(self):
        self.log_path.write_text(f"\n{datetime.now()}")


class BatteryPowerNotifier(threading.Thread):
    def __init__(
        self, bark_token: str, interval: int = 60, min_power: int = 20, **kwargs
    ):
        kwargs.setdefault("name", "BatteryPowerNotifier")
        super().__init__(**kwargs)
        self.interval = interval
        self.min_power = min_power
        self.bark_token = bark_token

    def _bark_notification(self, percent: int):
        BarkAPI(self.bark_token).push(
            BarkPushScheme(
                title="macbookpro 电量不足",
                body=f"当前电量: {percent}%",
                group="macbookpro",
            )  # type: ignore
        )

    @thread_error_handler
    def run(self) -> None:
        while True:
            percent = self.get_battery_power_percent()
            if percent is not None:
                if percent <= self.min_power:
                    self._bark_notification(percent)
                    return
            time.sleep(self.interval)

    def get_battery_power_percent(self) -> int | None:
        if sys.platform == "darwin":
            return self.get_battery_power_percent_macos()

        return None

    def get_battery_power_percent_macos(self) -> int:
        cmd = "pmset -g batt | grep -o '[0-9]*%' | tr -d '%'"
        power = subprocess.check_output(cmd, shell=True)
        return int(power)


class RSSHubWatcher(ABC, threading.Thread):
    """https://docs.rsshub.app/zh/"""

    def __init__(self, bark_token: str, urls: list[str], interval: int = 60, **kwargs):
        super().__init__(**kwargs)
        self.interval = interval
        self.urls = urls
        self.ts = int(time.time())
        self.bark_token = bark_token
        self.failed_messages = []

    def clean_text(self, text: str) -> str:
        return remove_html_tags(html.unescape(text.replace("<br>", "\n")))

    @thread_error_handler
    def run(self) -> None:
        while True:
            self.parse_rss()
            time.sleep(self.interval)

    @noexception
    def parse_rss(self):
        for url in self.urls:
            res = httpx.get(url)
            res.raise_for_status()
            messages = self.xml_handler(xmltodict.parse(res.text))
            self._bark_notification(messages)
        self.ts = int(time.time())

    def _bark_notification(self, messages: list[str | BarkPushScheme]):
        failed_messages = self.failed_messages.copy()
        for message in chain(failed_messages, messages):
            try:
                if isinstance(message, str):
                    body = BarkPushScheme(title="", body=message)  # type: ignore
                elif isinstance(message, BarkPushScheme):
                    body = message
                else:
                    raise ValueError(f"message type error: {type(message)}")
                BarkAPI(self.bark_token).push(body)
            except Exception as e:
                logger.warning(f"MikananiRssWatcher bark notification failed: {e}")
                self.failed_messages.append(message)

    @abstractmethod
    def xml_handler(self, data: dict) -> list[str | BarkPushScheme]:
        return []


class RSSHubBilibiliLiveRoomWatcher(RSSHubWatcher):
    """https://docs.rsshub.app/zh/routes/live#bi-li-bi-li-zhi-bo-zhi-bo-kai-bo"""

    def xml_handler(self, data: dict) -> list[str | BarkPushScheme]:
        messages = []
        if "item" in data["rss"]["channel"]:
            pubDate = data["rss"]["channel"]["item"]["pubDate"]
            link = data["rss"]["channel"]["link"]
            title = data["rss"]["channel"]["item"]["title"]
            content = data["rss"]["channel"]["item"]["description"]
        else:
            pubDate = data["rss"]["channel"]["lastBuildDate"]
            link = data["rss"]["channel"]["link"]
            title = data["rss"]["channel"]["title"]
            content = "已开播"
        title = self.clean_text(title)
        content = self.clean_text(content)
        logger.debug(
            f"RSSHubBilibiliLiveRoomWatcher pubDate: {pubDate}, link: {link}, title: {title}, content: {content}"
        )
        if int(parser.parse(pubDate).timestamp()) > self.ts:
            message = BarkPushScheme(title=title, body=content, url=link)  # type: ignore
            messages.append(message)
        return messages


class MikananiRssWatcher(threading.Thread):
    def __init__(self, bark_token: str, rss_url: str, interval: int = 300, **kwargs):
        kwargs.setdefault("name", "MikananiRssWatcher")
        super().__init__(**kwargs)
        self.interval = interval
        self.rss_url = rss_url
        self.ts = int(time.time())
        self.bark_token = bark_token
        self.failed_messages = []

    @thread_error_handler
    def run(self) -> None:
        while True:
            self.parse_rss()
            time.sleep(self.interval)

    def _bark_notification(self, messages: list[str]):
        failed_messages = self.failed_messages.copy()
        for message in chain(failed_messages, messages):
            try:
                BarkAPI(self.bark_token).push(
                    BarkPushScheme(
                        title="蜜柑计划订阅更新",
                        body=message,
                        group="mikanani",
                    )  # type: ignore
                )
            except Exception as e:
                logger.warning(f"MikananiRssWatcher bark notification failed: {e}")
                self.failed_messages.append(message)

    def parse_rss_date(self, pubDate: str) -> int:
        return int(parser.parse(pubDate).timestamp())

    @noexception
    def parse_rss(self):
        messages = []
        res = httpx.get(self.rss_url)
        res.raise_for_status()
        data = xmltodict.parse(res.text)
        for item in data["rss"]["channel"]["item"]:
            torrent = item["torrent"]
            pubDate = self.parse_rss_date(torrent["pubDate"])
            if pubDate >= self.ts:
                messages.append(item["title"])
        self.ts = int(time.time())
        self._bark_notification(messages)
