#! /usr/bin/env python3
# isort autopy && ruff check autopy --fix && ruff format autopy

# pip install xmltodict httpx pydantic python-dateutil

import html
import logging
import os
import re
import subprocess
import sys
import threading
import time
from abc import ABC, abstractmethod
from datetime import datetime
from enum import Enum
from functools import wraps
from itertools import chain
from pathlib import Path

import httpx
import xmltodict
from dateutil import parser
from pydantic import BaseModel, Field


def remove_html_tags(text: str):
    # 定义一个正则表达式，用于匹配HTML标签
    html_tags_re = re.compile(r"<[^>]+>")
    # 使用sub方法替换掉所有HTML标签为空字符串
    return html_tags_re.sub("", text)


class BarkPushLevel(str, Enum):
    active = "active"
    timeSensitive = "timeSensitive"
    passive = "passive"


class BarkPushScheme(BaseModel):
    title: str
    body: str
    category: str | None = Field(None, help="Reserved field, no use yet")
    device_key: str | None = Field(None, help="bark token, The key for each device")
    level: BarkPushLevel | None = Field(
        None, help="'active', 'timeSensitive', or 'passive'"
    )
    badge: int | None = Field(
        None,
        help="The number displayed next to App icon ([Apple Developer](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/1649864-badge))",
    )
    automaticallyCopy: str | None = Field(None, help="Must be 1")
    _copy: str | None = Field(None, help="The value to be copied", alias="copy")
    sound: str | None = Field(
        None, help="Value from [here](https://github.com/Finb/Bark/tree/master/Sounds)"
    )
    icon: str | None = Field(
        None, help="An url to the icon, available only on iOS 15 or later"
    )
    group: str | None = Field(None, help="The group of the notification")
    isArchive: str | None = Field(
        None, help="Value must be 1. Whether or not should be archived by the app"
    )
    url: str | None = Field(None, help="Url that will jump when click notification")


logger = logging.getLogger(__file__)


class BarkAPI:
    def __init__(self, token: str) -> None:
        self.token = token

    def push(self, body: BarkPushScheme) -> httpx.Response:
        """https://github.com/Finb/bark-server/blob/master/docs/API_V2.md#push"""
        url = "https://api.day.app/push"
        if not body.device_key:
            body.device_key = self.token

        # {"code":500,"message":"interface conversion: interface {} is nil, not string","timestamp":1706443398}%
        # 兼容对参数位null的处理
        paylaod = {k: v for k, v in body.dict().items() if v is not None}

        res = httpx.post(url, json=paylaod)
        logger.debug(f"bark push body: {body.dict()}")
        res.raise_for_status()
        return res


def get_bark_token(key: str = "BARK_TOKEN"):
    return os.getenv(key)


def get_mikanani_rss_url():
    return os.getenv("mikanani_rss_url")


def init():
    assert get_bark_token()
    assert get_mikanani_rss_url()


def thread_error_handler(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            token = get_bark_token()
            if token is not None:
                cb = noexception(BarkAPI(token).push)
                cb(BarkPushScheme(title="thread_error_handler", body=f"{e}"))  # type: ignore
            raise e

    return wrapper


def noexception(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            logger.warning(f"noexception: {e}", exc_info=True)
            pass

    return wrapper


class LogWriter(threading.Thread):
    def __init__(self, interval=60):
        super().__init__()
        self.interval = interval
        homedir = os.getenv("HOME", "./")
        self.log_path = p = Path(f"{homedir}/Desktop/log.txt")
        if not p.exists():
            p.touch()

    @thread_error_handler
    def run(self):
        while True:
            self.write_log()
            time.sleep(self.interval)

    def write_log(self):
        self.log_path.write_text(f"\n{datetime.now()}")


class BatteryPowerNotifier(threading.Thread):
    """When the laptop battery is less than a specified value, send a notification (exit thread after successful sending).
    >>> bark_token = ""
    >>> min_power = 20
    >>> BatteryPowerNotifier(bark_token, min_power=min_power, name="BatteryPowerNotifier20").start().join()
    """

    def __init__(
        self, bark_token: str, interval: int = 60, min_power: int = 20, **kwargs
    ):
        kwargs.setdefault("name", "BatteryPowerNotifier")
        super().__init__(**kwargs)
        self.interval = interval
        self.min_power = min_power
        self.bark_token = bark_token

    def _bark_notification(self, percent: int):
        BarkAPI(self.bark_token).push(
            BarkPushScheme(
                title="macbookpro 电量不足",
                body=f"当前电量: {percent}%",
                group="macbookpro",
            )  # type: ignore
        )

    @thread_error_handler
    def run(self) -> None:
        while True:
            logger.info(
                f"{self.__class__.__name__} date {datetime.fromtimestamp(int(time.time()))}"
            )
            percent = self.get_battery_power_percent()
            if percent is not None:
                if percent <= self.min_power:
                    self._bark_notification(percent)
                    return
            time.sleep(self.interval)

    def get_battery_power_percent(self) -> int | None:
        if sys.platform == "darwin":
            return self.get_battery_power_percent_macos()

        return None

    def get_battery_power_percent_macos(self) -> int:
        cmd = "pmset -g batt | grep -o '[0-9]*%' | tr -d '%'"
        power = subprocess.check_output(cmd, shell=True)
        return int(power)


class BilibiliRoomInfoScheme(BaseModel):
    uid: int
    room_id: int
    title: str | None
    description: str | None
    live_status: int | None
    live_time: str | None
    user_cover: str | None
    keyframe: str | None
    live_time: str | None

    def get_room_link(self):
        return f"https://live.bilibili.com/{self.room_id}"

    @property
    def pub_date(self) -> datetime:
        assert self.live_time
        return parser.parse(self.live_time)

    def is_alive(self):
        return self.live_status == 1

    def if_push(self, last_pub_date: datetime | int | None) -> bool:
        if last_pub_date is None:
            return True

        if isinstance(last_pub_date, datetime):
            return int(self.pub_date.timestamp()) > int(last_pub_date.timestamp())

        if isinstance(last_pub_date, int):
            return int(self.pub_date.timestamp()) > last_pub_date

        return False

    def get_bark_push_message(self) -> BarkPushScheme:
        link = self.get_room_link()
        return BarkPushScheme(
            title=RSSHubWatcher.clean_text(self.title or ""),
            body=RSSHubWatcher.clean_text(self.description or ""),
            url=link,
            icon=self.keyframe,
            group="bilibili",
            isArchive="1",
            _copy=link,  # type: ignore
        )  # type: ignore


class RSSHubWatcher(ABC, threading.Thread):
    """https://docs.rsshub.app/zh/"""

    def __init__(self, bark_token: str, urls: list[str], interval: int = 60, **kwargs):
        super().__init__(**kwargs)
        self.interval = interval
        self.urls = urls
        self.bark_token = bark_token
        self.failed_messages: list[str | BarkPushScheme] = []

    @staticmethod
    def clean_text(text: str) -> str:
        return remove_html_tags(html.unescape(text.replace("<br>", "\n")))

    @thread_error_handler
    def run(self) -> None:
        while True:
            logger.info(
                f"RSSHubWatcher {self.__class__.__name__} date {datetime.now()}"
            )
            self.parse_rss()
            time.sleep(self.interval)

    @noexception
    def parse_rss(self):
        for url in self.urls:
            res = httpx.get(url)
            res.raise_for_status()
            messages = self.handler(url, xmltodict.parse(res.text))
            self._bark_notification(messages)
        self.ts = int(time.time())

    def _bark_notification(self, messages: list[str | BarkPushScheme]):
        failed_messages = self.failed_messages.copy()
        self.failed_messages.clear()
        for message in chain(failed_messages, messages):
            if isinstance(message, str):
                body = BarkPushScheme(title="", body=message)  # type: ignore
            elif isinstance(message, BarkPushScheme):
                body = message
            else:
                raise ValueError(f"message type error: {type(message)}")
            try:
                res = BarkAPI(self.bark_token).push(body)
                res.raise_for_status()
            except Exception as e:
                logger.warning(
                    f"{self.__class__.__name__} bark notification failed: {e}"
                )
                self.failed_messages.append(message)

    @abstractmethod
    def handler(self, url: str, data: dict) -> list[str | BarkPushScheme]:
        raise NotImplementedError


class RSSHubBilibiliLiveRoomWatcher(RSSHubWatcher):
    """Subscribe to the Bilibili live room broadcast status, and send out a notification when it starts broadcasting.
    https://docs.rsshub.app/zh/routes/live#bi-li-bi-li-zhi-bo-zhi-bo-kai-bo
    >>> bark_token = ""
    >>> bilibili_live_room_rss_url = ["https://rsshub.app/bilibili/live/room/732"]
    >>> RSSHubBilibiliLiveRoomWatcher(bark_token, bilibili_live_room_rss_url, name="RSSHubBilibiliLiveRoomWatcher").start().join()
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # self.start_pub_date = parser.parse("2024/01/30 18:00")
        self.start_pub_date = datetime.now()
        self.records: dict[str, datetime] = {}

    def get_room_info(self, room_id: str | int) -> BilibiliRoomInfoScheme:
        url = "https://api.live.bilibili.com/room/v1/Room/get_info"
        headers = {
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
        }
        params = {"room_id": room_id, "from": "from"}
        resp = httpx.get(url, params=params, headers=headers)
        resp.raise_for_status()
        return BilibiliRoomInfoScheme(**resp.json().get("data", {}))

    def handler(self, url: str, data: dict) -> list[str | BarkPushScheme]:
        room_id = url.split("/")[-1]
        info = self.get_room_info(room_id)
        last_pub_date = self.records.get(room_id, self.start_pub_date)
        logger.debug(f"RSSHubBilibiliLiveRoomWatcher room info: {info}")
        if info.is_alive() and info.if_push(last_pub_date):
            message = info.get_bark_push_message()
            self.records[room_id] = info.pub_date
            return [message]

        return []


class MikananiRssWatcher(threading.Thread):
    """Send a notification when the anime subscribed to by Mikanani Project is updated.
    https://mikanani.me/
    >>> bark_token = ""
    >>> rss_url = "https://mikanani.me/RSS/MyBangumi?token={token}"
    >>> MikananiRssWatcher(bark_token, rss_url, name="MikananiRssWatcher").start().join()
    """

    def __init__(self, bark_token: str, rss_url: str, interval: int = 300, **kwargs):
        super().__init__(**kwargs)
        self.interval = interval
        self.rss_url = rss_url
        self.ts = datetime.now()
        self.bark_token = bark_token
        self.failed_messages = []

    @thread_error_handler
    def run(self) -> None:
        while True:
            logger.info(f"{self.__class__.__name__} date {self.ts}")
            messages = self.parse_rss()
            self._bark_notification(messages)
            time.sleep(self.interval)

    @noexception
    def _bark_notification(self, messages: list[str | BarkPushScheme]):
        failed_messages = self.failed_messages.copy()
        self.failed_messages.clear()
        for message in chain(failed_messages, messages):
            try:
                if isinstance(message, str):
                    payload = BarkPushScheme(
                        title="蜜柑计划订阅更新",
                        body=message,
                        group="mikanani",
                    )  # type: ignore
                elif isinstance(message, BarkPushScheme):
                    payload = message
                else:
                    raise ValueError(f"message type error: {type(message)}")
                BarkAPI(self.bark_token).push(payload)
            except Exception as e:
                logger.warning(f"MikananiRssWatcher bark notification failed: {e}")
                self.failed_messages.append(message)

    @noexception
    def parse_rss_date(self, pubDate: str) -> int:
        return int(parser.parse(pubDate).timestamp())

    @noexception
    def parse_rss(self) -> list[str | BarkPushScheme]:
        messages = []
        res = httpx.get(self.rss_url)
        res.raise_for_status()
        data = xmltodict.parse(res.text)
        for item in data["rss"]["channel"]["item"]:
            torrent = item["torrent"]
            title = item["title"]
            content = item["title"]
            pubDate = parser.parse(torrent["pubDate"])
            link = torrent["link"]
            torrent_download_url = item["enclosure"]["@url"]
            if int(pubDate.timestamp()) >= int(self.ts.timestamp()):
                message = BarkPushScheme(
                    title=title, body=content, url=link, copy=torrent_download_url
                )  # type: ignore
                messages.append(message)

        if messages:
            self.ts = datetime.now()
        return messages
