// 2024-11-29 03:24:41
var cC = Object.defineProperty;
var fC = (Ve, Ue, et) => Ue in Ve ? cC(Ve, Ue, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: et
}) : Ve[Ue] = et;
var Yr = (Ve, Ue, et) => (fC(Ve, typeof Ue != "symbol" ? Ue + "" : Ue, et),
    et)
    , fc = (Ve, Ue, et) => {
        if (!Ue.has(Ve))
            throw TypeError("Cannot " + et)
    }
    ;
var h = (Ve, Ue, et) => (fc(Ve, Ue, "read from private field"),
    et ? et.call(Ve) : Ue.get(Ve))
    , j = (Ve, Ue, et) => {
        if (Ue.has(Ve))
            throw TypeError("Cannot add the same private member more than once");
        Ue instanceof WeakSet ? Ue.add(Ve) : Ue.set(Ve, et)
    }
    , V = (Ve, Ue, et, mr) => (fc(Ve, Ue, "write to private field"),
        mr ? mr.call(Ve, et) : Ue.set(Ve, et),
        et);
var fa = (Ve, Ue, et, mr) => ({
    set _(ah) {
        V(Ve, Ue, ah, et)
    },
    get _() {
        return h(Ve, Ue, mr)
    }
})
    , te = (Ve, Ue, et) => (fc(Ve, Ue, "access private method"),
        et);
(() => {
    var bt, st, mg, Fl, kv, Ul, xv, gg, Ss, vg, Pn, ih, jl, Iv, yg, Kd, Xd, Ln, Cs, dt, _g, _e, Et, As, Xs, Hl, Pv, ql, Lv, $l, Ov, Va, mc, Vl, Mv, Tg, as, Ni, Ar, za, bg, ut, it, ws, Bi, On, Mn, Qe, Ga, zl, Rv, Gl, Nv, Eg, Fi, wr, Ys, Qs, fi, pi, mi, Wa, zt, Ka, Xa, Gt, Ya, Wl, Bv, Sg, Rn, Js, Cg, We, It, os, ls, us, Nn, Pt, Qa, Bn, Lt, Ja, Fn, Zs, Ag, Di, er, Dr, Ds, Un, Za, gc, wg, eo, jn, Kl, Fv, Dg, St, to, io, so, Xl, Uv, kg, Hn, tr, ir, ro, vc, xg, kr, Ig, Yd, Wt, no, Te, sr, xr, Ir, ks, Yl, jv, Ql, Hv, Jl, qv, ao, yc, Zl, $v, eu, Vv, tu, zv, iu, Gv, su, Wv, ru, Kv, hs, pr, qn, sh, oo, _c, nu, Xv, Pg, lo, Lg, $n, xs, gi, Pr, Vn, rr, Ui, au, Yv, Og, Ot, nr, ds, Lr, zn, cs, Or, ct, ou, Qv, lu, Jv, Is, Qr, Mg, ar, ki, ri, Ct, Mr, Rr, Nr, Br, ji, Gn, fs, uo, ho, uu, Zv, hu, ey, du, ty, Rg, Kt, Hi, or, cu, iy, Ng, Wn, Fr, Mt, Ps, Ls, Os, Ms, Kn, lr, ps, co, Tc, Xn, rh, fo, bc, po, Ec, fu, sy, pu, ry, mu, ny, Ur, Fo, gu, ay, vu, oy, mo, Sc, Yn, nh, go, Cc, Bg, qi, jr, Qn, Rt, Rs, ms, Xt, ur, vi, hr, yu, ly, _u, uy, Tu, hy, bu, dy, Eu, cy, Su, fy, Cu, py, Au, my, Ns, Jr, wu, gy, Fg, Bs, rt, gt, Jn, Du, vy, ku, yy, Ug, Zn, ea, nt, xu, _y, jg;
    var Ve = Object.create
        , Ue = Object.defineProperty
        , et = Object.getOwnPropertyDescriptor
        , mr = Object.getOwnPropertyNames
        , ah = Object.getPrototypeOf
        , Ty = Object.prototype.hasOwnProperty
        , Ke = (t, e) => function () {
            return e || (0,
                t[mr(t)[0]])((e = {
                    exports: {}
                }).exports, e),
                e.exports
        }
        , by = (t, e, s, r) => {
            if (e && typeof e == "object" || typeof e == "function")
                for (let n of mr(e))
                    !Ty.call(t, n) && n !== s && Ue(t, n, {
                        get: () => e[n],
                        enumerable: !(r = et(e, n)) || r.enumerable
                    });
            return t
        }
        , _t = (t, e, s) => (s = t != null ? Ve(ah(t)) : {},
            by(e || !t || !t.__esModule ? Ue(s, "default", {
                value: t,
                enumerable: !0
            }) : s, t))
        , Ki = Ke({
            "node_modules/global/window.js"(t, e) {
                var s;
                typeof window < "u" ? s = window : typeof global < "u" ? s = global : typeof self < "u" ? s = self : s = {},
                    e.exports = s
            }
        })
        , Ey = Ke({
            "(disabled):node_modules/min-document/index.js"() { }
        })
        , Ac = Ke({
            "node_modules/global/document.js"(t, e) {
                var s = typeof global < "u" ? global : typeof window < "u" ? window : {}, r = Ey(), n;
                typeof document < "u" ? n = document : (n = s["__GLOBAL_DOCUMENT_CACHE@4"],
                    n || (n = s["__GLOBAL_DOCUMENT_CACHE@4"] = r)),
                    e.exports = n
            }
        })
        , Sy = Ke({
            "node_modules/keycode/index.js"(t, e) {
                function s(c) {
                    if (c && typeof c == "object") {
                        var f = c.which || c.keyCode || c.charCode;
                        f && (c = f)
                    }
                    if (typeof c == "number")
                        return o[c];
                    var v = String(c)
                        , T = r[v.toLowerCase()];
                    if (T)
                        return T;
                    var T = n[v.toLowerCase()];
                    if (T)
                        return T;
                    if (v.length === 1)
                        return v.charCodeAt(0)
                }
                s.isEventKey = function (f, v) {
                    if (f && typeof f == "object") {
                        var T = f.which || f.keyCode || f.charCode;
                        if (T == null)
                            return !1;
                        if (typeof v == "string") {
                            var D = r[v.toLowerCase()];
                            if (D)
                                return D === T;
                            var D = n[v.toLowerCase()];
                            if (D)
                                return D === T
                        } else if (typeof v == "number")
                            return v === T;
                        return !1
                    }
                }
                    ,
                    t = e.exports = s;
                var r = t.code = t.codes = {
                    backspace: 8,
                    tab: 9,
                    enter: 13,
                    shift: 16,
                    ctrl: 17,
                    alt: 18,
                    "pause/break": 19,
                    "caps lock": 20,
                    esc: 27,
                    space: 32,
                    "page up": 33,
                    "page down": 34,
                    end: 35,
                    home: 36,
                    left: 37,
                    up: 38,
                    right: 39,
                    down: 40,
                    insert: 45,
                    delete: 46,
                    command: 91,
                    "left command": 91,
                    "right command": 93,
                    "numpad *": 106,
                    "numpad +": 107,
                    "numpad -": 109,
                    "numpad .": 110,
                    "numpad /": 111,
                    "num lock": 144,
                    "scroll lock": 145,
                    "my computer": 182,
                    "my calculator": 183,
                    ";": 186,
                    "=": 187,
                    ",": 188,
                    "-": 189,
                    ".": 190,
                    "/": 191,
                    "`": 192,
                    "[": 219,
                    "\\": 220,
                    "]": 221,
                    "'": 222
                }
                    , n = t.aliases = {
                        windows: 91,
                        "\u21E7": 16,
                        "\u2325": 18,
                        "\u2303": 17,
                        "\u2318": 91,
                        ctl: 17,
                        control: 17,
                        option: 18,
                        pause: 19,
                        break: 19,
                        caps: 20,
                        return: 13,
                        escape: 27,
                        spc: 32,
                        spacebar: 32,
                        pgup: 33,
                        pgdn: 34,
                        ins: 45,
                        del: 46,
                        cmd: 91
                    };
                for (a = 97; a < 123; a++)
                    r[String.fromCharCode(a)] = a - 32;
                for (a = 48; a < 58; a++)
                    r[a - 48] = a;
                var a;
                for (a = 1; a < 13; a++)
                    r["f" + a] = a + 111;
                for (a = 0; a < 10; a++)
                    r["numpad " + a] = a + 96;
                var o = t.names = t.title = {};
                for (a in r)
                    o[r[a]] = a;
                for (u in n)
                    r[u] = n[u];
                var u
            }
        })
        , Cy = Ke({
            "node_modules/safe-json-parse/tuple.js"(t, e) {
                e.exports = s;
                function s(r, n) {
                    var a, o = null;
                    try {
                        a = JSON.parse(r, n)
                    } catch (u) {
                        o = u
                    }
                    return [o, a]
                }
            }
        })
        , Ay = Ke({
            "node_modules/@babel/runtime/helpers/extends.js"(t, e) {
                function s() {
                    return e.exports = s = Object.assign ? Object.assign.bind() : function (r) {
                        for (var n = 1; n < arguments.length; n++) {
                            var a = arguments[n];
                            for (var o in a)
                                Object.prototype.hasOwnProperty.call(a, o) && (r[o] = a[o])
                        }
                        return r
                    }
                        ,
                        e.exports.__esModule = !0,
                        e.exports.default = e.exports,
                        s.apply(this, arguments)
                }
                e.exports = s,
                    e.exports.__esModule = !0,
                    e.exports.default = e.exports
            }
        })
        , wy = Ke({
            "node_modules/is-function/index.js"(t, e) {
                e.exports = r;
                var s = Object.prototype.toString;
                function r(n) {
                    if (!n)
                        return !1;
                    var a = s.call(n);
                    return a === "[object Function]" || typeof n == "function" && a !== "[object RegExp]" || typeof window < "u" && (n === window.setTimeout || n === window.alert || n === window.confirm || n === window.prompt)
                }
            }
        })
        , Dy = Ke({
            "node_modules/@videojs/xhr/lib/http-handler.js"(t, e) {
                "use strict";
                var s = Ki()
                    , r = function (o, u) {
                        return u === void 0 && (u = !1),
                            function (c, f, v) {
                                if (c) {
                                    o(c);
                                    return
                                }
                                if (f.statusCode >= 400 && f.statusCode <= 599) {
                                    var T = v;
                                    if (u)
                                        if (s.TextDecoder) {
                                            var D = n(f.headers && f.headers["content-type"]);
                                            try {
                                                T = new TextDecoder(D).decode(v)
                                            } catch (_) { }
                                        } else
                                            T = String.fromCharCode.apply(null, new Uint8Array(v));
                                    o({
                                        cause: T
                                    });
                                    return
                                }
                                o(null, v)
                            }
                    };
                function n(a) {
                    return a === void 0 && (a = ""),
                        a.toLowerCase().split(";").reduce(function (o, u) {
                            var c = u.split("=")
                                , f = c[0]
                                , v = c[1];
                            return f.trim() === "charset" ? v.trim() : o
                        }, "utf-8")
                }
                e.exports = r
            }
        })
        , ky = Ke({
            "node_modules/@videojs/xhr/lib/index.js"(t, e) {
                "use strict";
                var s = Ki()
                    , r = Ay()
                    , n = wy();
                f.httpHandler = Dy();
                var a = function (L) {
                    var M = {};
                    return L && L.trim().split(`
`).forEach(function (N) {
                        var x = N.indexOf(":")
                            , B = N.slice(0, x).trim().toLowerCase()
                            , z = N.slice(x + 1).trim();
                        typeof M[B] > "u" ? M[B] = z : Array.isArray(M[B]) ? M[B].push(z) : M[B] = [M[B], z]
                    }),
                        M
                };
                e.exports = f,
                    e.exports.default = f,
                    f.XMLHttpRequest = s.XMLHttpRequest || D,
                    f.XDomainRequest = "withCredentials" in new f.XMLHttpRequest ? f.XMLHttpRequest : s.XDomainRequest,
                    o(["get", "put", "post", "patch", "head", "delete"], function (_) {
                        f[_ === "delete" ? "del" : _] = function (L, M, N) {
                            return M = c(L, M, N),
                                M.method = _.toUpperCase(),
                                v(M)
                        }
                    });
                function o(_, L) {
                    for (var M = 0; M < _.length; M++)
                        L(_[M])
                }
                function u(_) {
                    for (var L in _)
                        if (_.hasOwnProperty(L))
                            return !1;
                    return !0
                }
                function c(_, L, M) {
                    var N = _;
                    return n(L) ? (M = L,
                        typeof _ == "string" && (N = {
                            uri: _
                        })) : N = r({}, L, {
                            uri: _
                        }),
                        N.callback = M,
                        N
                }
                function f(_, L, M) {
                    return L = c(_, L, M),
                        v(L)
                }
                function v(_) {
                    if (typeof _.callback > "u")
                        throw new Error("callback argument missing");
                    var L = !1
                        , M = function (re, he, oe) {
                            L || (L = !0,
                                _.callback(re, he, oe))
                        };
                    function N() {
                        R.readyState === 4 && setTimeout(z, 0)
                    }
                    function x() {
                        var Z = void 0;
                        if (R.response ? Z = R.response : Z = R.responseText || T(R),
                            w)
                            try {
                                Z = JSON.parse(Z)
                            } catch (re) { }
                        return Z
                    }
                    function B(Z) {
                        return clearTimeout(H),
                            Z instanceof Error || (Z = new Error("" + (Z || "Unknown XMLHttpRequest Error"))),
                            Z.statusCode = 0,
                            M(Z, X)
                    }
                    function z() {
                        if (!Y) {
                            var Z;
                            clearTimeout(H),
                                _.useXDR && R.status === void 0 ? Z = 200 : Z = R.status === 1223 ? 204 : R.status;
                            var re = X
                                , he = null;
                            return Z !== 0 ? (re = {
                                body: x(),
                                statusCode: Z,
                                method: de,
                                headers: {},
                                url: ue,
                                rawRequest: R
                            },
                                R.getAllResponseHeaders && (re.headers = a(R.getAllResponseHeaders()))) : he = new Error("Internal XMLHttpRequest Error"),
                                M(he, re, re.body)
                        }
                    }
                    var R = _.xhr || null;
                    R || (_.cors || _.useXDR ? R = new f.XDomainRequest : R = new f.XMLHttpRequest);
                    var F, Y, ue = R.url = _.uri || _.url, de = R.method = _.method || "GET", ee = _.body || _.data, G = R.headers = _.headers || {}, A = !!_.sync, w = !1, H, X = {
                        body: void 0,
                        headers: {},
                        statusCode: 0,
                        method: de,
                        url: ue,
                        rawRequest: R
                    };
                    if ("json" in _ && _.json !== !1 && (w = !0,
                        G.accept || G.Accept || (G.Accept = "application/json"),
                        de !== "GET" && de !== "HEAD" && (G["content-type"] || G["Content-Type"] || (G["Content-Type"] = "application/json"),
                            ee = JSON.stringify(_.json === !0 ? ee : _.json))),
                        R.onreadystatechange = N,
                        R.onload = z,
                        R.onerror = B,
                        R.onprogress = function () { }
                        ,
                        R.onabort = function () {
                            Y = !0
                        }
                        ,
                        R.ontimeout = B,
                        R.open(de, ue, !A, _.username, _.password),
                        A || (R.withCredentials = !!_.withCredentials),
                        !A && _.timeout > 0 && (H = setTimeout(function () {
                            if (!Y) {
                                Y = !0,
                                    R.abort("timeout");
                                var Z = new Error("XMLHttpRequest timeout");
                                Z.code = "ETIMEDOUT",
                                    B(Z)
                            }
                        }, _.timeout)),
                        R.setRequestHeader)
                        for (F in G)
                            G.hasOwnProperty(F) && R.setRequestHeader(F, G[F]);
                    else if (_.headers && !u(_.headers))
                        throw new Error("Headers cannot be set on an XDomainRequest object");
                    return "responseType" in _ && (R.responseType = _.responseType),
                        "beforeSend" in _ && typeof _.beforeSend == "function" && _.beforeSend(R),
                        R.send(ee || null),
                        R
                }
                function T(_) {
                    try {
                        if (_.responseType === "document")
                            return _.responseXML;
                        var L = _.responseXML && _.responseXML.documentElement.nodeName === "parsererror";
                        if (_.responseType === "" && !L)
                            return _.responseXML
                    } catch (M) { }
                    return null
                }
                function D() { }
            }
        })
        , xy = Ke({
            "node_modules/videojs-vtt.js/lib/vtt.js"(t, e) {
                var s = Ac()
                    , r = Object.create || function () {
                        function A() { }
                        return function (w) {
                            if (arguments.length !== 1)
                                throw new Error("Object.create shim only accepts one parameter.");
                            return A.prototype = w,
                                new A
                        }
                    }();
                function n(A, w) {
                    this.name = "ParsingError",
                        this.code = A.code,
                        this.message = w || A.message
                }
                n.prototype = r(Error.prototype),
                    n.prototype.constructor = n,
                    n.Errors = {
                        BadSignature: {
                            code: 0,
                            message: "Malformed WebVTT signature."
                        },
                        BadTimeStamp: {
                            code: 1,
                            message: "Malformed time stamp."
                        }
                    };
                function a(A) {
                    function w(X, Z, re, he) {
                        return (X | 0) * 3600 + (Z | 0) * 60 + (re | 0) + (he | 0) / 1e3
                    }
                    var H = A.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
                    return H ? H[3] ? w(H[1], H[2], H[3].replace(":", ""), H[4]) : H[1] > 59 ? w(H[1], H[2], 0, H[4]) : w(0, H[1], H[2], H[4]) : null
                }
                function o() {
                    this.values = r(null)
                }
                o.prototype = {
                    set: function (A, w) {
                        !this.get(A) && w !== "" && (this.values[A] = w)
                    },
                    get: function (A, w, H) {
                        return H ? this.has(A) ? this.values[A] : w[H] : this.has(A) ? this.values[A] : w
                    },
                    has: function (A) {
                        return A in this.values
                    },
                    alt: function (A, w, H) {
                        for (var X = 0; X < H.length; ++X)
                            if (w === H[X]) {
                                this.set(A, w);
                                break
                            }
                    },
                    integer: function (A, w) {
                        /^-?\d+$/.test(w) && this.set(A, parseInt(w, 10))
                    },
                    percent: function (A, w) {
                        var H;
                        return (H = w.match(/^([\d]{1,3})(\.[\d]*)?%$/)) && (w = parseFloat(w),
                            w >= 0 && w <= 100) ? (this.set(A, w),
                                !0) : !1
                    }
                };
                function u(A, w, H, X) {
                    var Z = X ? A.split(X) : [A];
                    for (var re in Z)
                        if (typeof Z[re] == "string") {
                            var he = Z[re].split(H);
                            if (he.length === 2) {
                                var oe = he[0].trim()
                                    , ie = he[1].trim();
                                w(oe, ie)
                            }
                        }
                }
                function c(A, w, H) {
                    var X = A;
                    function Z() {
                        var oe = a(A);
                        if (oe === null)
                            throw new n(n.Errors.BadTimeStamp, "Malformed timestamp: " + X);
                        return A = A.replace(/^[^\sa-zA-Z-]+/, ""),
                            oe
                    }
                    function re(oe, ie) {
                        var ae = new o;
                        u(oe, function (ce, se) {
                            switch (ce) {
                                case "region":
                                    for (var ve = H.length - 1; ve >= 0; ve--)
                                        if (H[ve].id === se) {
                                            ae.set(ce, H[ve].region);
                                            break
                                        }
                                    break;
                                case "vertical":
                                    ae.alt(ce, se, ["rl", "lr"]);
                                    break;
                                case "line":
                                    var Me = se.split(",")
                                        , ge = Me[0];
                                    ae.integer(ce, ge),
                                        ae.percent(ce, ge) && ae.set("snapToLines", !1),
                                        ae.alt(ce, ge, ["auto"]),
                                        Me.length === 2 && ae.alt("lineAlign", Me[1], ["start", "center", "end"]);
                                    break;
                                case "position":
                                    Me = se.split(","),
                                        ae.percent(ce, Me[0]),
                                        Me.length === 2 && ae.alt("positionAlign", Me[1], ["start", "center", "end"]);
                                    break;
                                case "size":
                                    ae.percent(ce, se);
                                    break;
                                case "align":
                                    ae.alt(ce, se, ["start", "center", "end", "left", "right"]);
                                    break
                            }
                        }, /:/, /\s/),
                            ie.region = ae.get("region", null),
                            ie.vertical = ae.get("vertical", "");
                        try {
                            ie.line = ae.get("line", "auto")
                        } catch (ce) { }
                        ie.lineAlign = ae.get("lineAlign", "start"),
                            ie.snapToLines = ae.get("snapToLines", !0),
                            ie.size = ae.get("size", 100);
                        try {
                            ie.align = ae.get("align", "center")
                        } catch (ce) {
                            ie.align = ae.get("align", "middle")
                        }
                        try {
                            ie.position = ae.get("position", "auto")
                        } catch (ce) {
                            ie.position = ae.get("position", {
                                start: 0,
                                left: 0,
                                center: 50,
                                middle: 50,
                                end: 100,
                                right: 100
                            }, ie.align)
                        }
                        ie.positionAlign = ae.get("positionAlign", {
                            start: "start",
                            left: "start",
                            center: "center",
                            middle: "center",
                            end: "end",
                            right: "end"
                        }, ie.align)
                    }
                    function he() {
                        A = A.replace(/^\s+/, "")
                    }
                    if (he(),
                        w.startTime = Z(),
                        he(),
                        A.substr(0, 3) !== "-->")
                        throw new n(n.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '-->'): " + X);
                    A = A.substr(3),
                        he(),
                        w.endTime = Z(),
                        he(),
                        re(A, w)
                }
                var f = s.createElement && s.createElement("textarea")
                    , v = {
                        c: "span",
                        i: "i",
                        b: "b",
                        u: "u",
                        ruby: "ruby",
                        rt: "rt",
                        v: "span",
                        lang: "span"
                    }
                    , T = {
                        white: "rgba(255,255,255,1)",
                        lime: "rgba(0,255,0,1)",
                        cyan: "rgba(0,255,255,1)",
                        red: "rgba(255,0,0,1)",
                        yellow: "rgba(255,255,0,1)",
                        magenta: "rgba(255,0,255,1)",
                        blue: "rgba(0,0,255,1)",
                        black: "rgba(0,0,0,1)"
                    }
                    , D = {
                        v: "title",
                        lang: "lang"
                    }
                    , _ = {
                        rt: "ruby"
                    };
                function L(A, w) {
                    function H() {
                        if (!w)
                            return null;
                        function ge(ke) {
                            return w = w.substr(ke.length),
                                ke
                        }
                        var Ce = w.match(/^([^<]*)(<[^>]*>?)?/);
                        return ge(Ce[1] ? Ce[1] : Ce[2])
                    }
                    function X(ge) {
                        return f.innerHTML = ge,
                            ge = f.textContent,
                            f.textContent = "",
                            ge
                    }
                    function Z(ge, Ce) {
                        return !_[Ce.localName] || _[Ce.localName] === ge.localName
                    }
                    function re(ge, Ce) {
                        var ke = v[ge];
                        if (!ke)
                            return null;
                        var At = A.document.createElement(ke)
                            , qe = D[ge];
                        return qe && Ce && (At[qe] = Ce.trim()),
                            At
                    }
                    for (var he = A.document.createElement("div"), oe = he, ie, ae = []; (ie = H()) !== null;) {
                        if (ie[0] === "<") {
                            if (ie[1] === "/") {
                                ae.length && ae[ae.length - 1] === ie.substr(2).replace(">", "") && (ae.pop(),
                                    oe = oe.parentNode);
                                continue
                            }
                            var ce = a(ie.substr(1, ie.length - 2)), se;
                            if (ce) {
                                se = A.document.createProcessingInstruction("timestamp", ce),
                                    oe.appendChild(se);
                                continue
                            }
                            var ve = ie.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
                            if (!ve || (se = re(ve[1], ve[3]),
                                !se) || !Z(oe, se))
                                continue;
                            if (ve[2]) {
                                var Me = ve[2].split(".");
                                Me.forEach(function (ge) {
                                    var Ce = /^bg_/.test(ge)
                                        , ke = Ce ? ge.slice(3) : ge;
                                    if (T.hasOwnProperty(ke)) {
                                        var At = Ce ? "background-color" : "color"
                                            , qe = T[ke];
                                        se.style[At] = qe
                                    }
                                }),
                                    se.className = Me.join(" ")
                            }
                            ae.push(ve[1]),
                                oe.appendChild(se),
                                oe = se;
                            continue
                        }
                        oe.appendChild(A.document.createTextNode(X(ie)))
                    }
                    return he
                }
                var M = [[1470, 1470], [1472, 1472], [1475, 1475], [1478, 1478], [1488, 1514], [1520, 1524], [1544, 1544], [1547, 1547], [1549, 1549], [1563, 1563], [1566, 1610], [1645, 1647], [1649, 1749], [1765, 1766], [1774, 1775], [1786, 1805], [1807, 1808], [1810, 1839], [1869, 1957], [1969, 1969], [1984, 2026], [2036, 2037], [2042, 2042], [2048, 2069], [2074, 2074], [2084, 2084], [2088, 2088], [2096, 2110], [2112, 2136], [2142, 2142], [2208, 2208], [2210, 2220], [8207, 8207], [64285, 64285], [64287, 64296], [64298, 64310], [64312, 64316], [64318, 64318], [64320, 64321], [64323, 64324], [64326, 64449], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65020], [65136, 65140], [65142, 65276], [67584, 67589], [67592, 67592], [67594, 67637], [67639, 67640], [67644, 67644], [67647, 67669], [67671, 67679], [67840, 67867], [67872, 67897], [67903, 67903], [67968, 68023], [68030, 68031], [68096, 68096], [68112, 68115], [68117, 68119], [68121, 68147], [68160, 68167], [68176, 68184], [68192, 68223], [68352, 68405], [68416, 68437], [68440, 68466], [68472, 68479], [68608, 68680], [126464, 126467], [126469, 126495], [126497, 126498], [126500, 126500], [126503, 126503], [126505, 126514], [126516, 126519], [126521, 126521], [126523, 126523], [126530, 126530], [126535, 126535], [126537, 126537], [126539, 126539], [126541, 126543], [126545, 126546], [126548, 126548], [126551, 126551], [126553, 126553], [126555, 126555], [126557, 126557], [126559, 126559], [126561, 126562], [126564, 126564], [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], [126590, 126590], [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [1114109, 1114109]];
                function N(A) {
                    for (var w = 0; w < M.length; w++) {
                        var H = M[w];
                        if (A >= H[0] && A <= H[1])
                            return !0
                    }
                    return !1
                }
                function x(A) {
                    var w = [], H = "", X;
                    if (!A || !A.childNodes)
                        return "ltr";
                    function Z(oe, ie) {
                        for (var ae = ie.childNodes.length - 1; ae >= 0; ae--)
                            oe.push(ie.childNodes[ae])
                    }
                    function re(oe) {
                        if (!oe || !oe.length)
                            return null;
                        var ie = oe.pop()
                            , ae = ie.textContent || ie.innerText;
                        if (ae) {
                            var ce = ae.match(/^.*(\n|\r)/);
                            return ce ? (oe.length = 0,
                                ce[0]) : ae
                        }
                        if (ie.tagName === "ruby")
                            return re(oe);
                        if (ie.childNodes)
                            return Z(oe, ie),
                                re(oe)
                    }
                    for (Z(w, A); H = re(w);)
                        for (var he = 0; he < H.length; he++)
                            if (X = H.charCodeAt(he),
                                N(X))
                                return "rtl";
                    return "ltr"
                }
                function B(A) {
                    if (typeof A.line == "number" && (A.snapToLines || A.line >= 0 && A.line <= 100))
                        return A.line;
                    if (!A.track || !A.track.textTrackList || !A.track.textTrackList.mediaElement)
                        return -1;
                    for (var w = A.track, H = w.textTrackList, X = 0, Z = 0; Z < H.length && H[Z] !== w; Z++)
                        H[Z].mode === "showing" && X++;
                    return ++X * -1
                }
                function z() { }
                z.prototype.applyStyles = function (A, w) {
                    w = w || this.div;
                    for (var H in A)
                        A.hasOwnProperty(H) && (w.style[H] = A[H])
                }
                    ,
                    z.prototype.formatStyle = function (A, w) {
                        return A === 0 ? 0 : A + w
                    }
                    ;
                function R(A, w, H) {
                    z.call(this),
                        this.cue = w,
                        this.cueDiv = L(A, w.text);
                    var X = {
                        color: "rgba(255, 255, 255, 1)",
                        backgroundColor: "rgba(0, 0, 0, 0.8)",
                        position: "relative",
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0,
                        display: "inline",
                        writingMode: w.vertical === "" ? "horizontal-tb" : w.vertical === "lr" ? "vertical-lr" : "vertical-rl",
                        unicodeBidi: "plaintext"
                    };
                    this.applyStyles(X, this.cueDiv),
                        this.div = A.document.createElement("div"),
                        X = {
                            direction: x(this.cueDiv),
                            writingMode: w.vertical === "" ? "horizontal-tb" : w.vertical === "lr" ? "vertical-lr" : "vertical-rl",
                            unicodeBidi: "plaintext",
                            textAlign: w.align === "middle" ? "center" : w.align,
                            font: H.font,
                            whiteSpace: "pre-line",
                            position: "absolute"
                        },
                        this.applyStyles(X),
                        this.div.appendChild(this.cueDiv);
                    var Z = 0;
                    switch (w.positionAlign) {
                        case "start":
                        case "line-left":
                            Z = w.position;
                            break;
                        case "center":
                            Z = w.position - w.size / 2;
                            break;
                        case "end":
                        case "line-right":
                            Z = w.position - w.size;
                            break
                    }
                    w.vertical === "" ? this.applyStyles({
                        left: this.formatStyle(Z, "%"),
                        width: this.formatStyle(w.size, "%")
                    }) : this.applyStyles({
                        top: this.formatStyle(Z, "%"),
                        height: this.formatStyle(w.size, "%")
                    }),
                        this.move = function (re) {
                            this.applyStyles({
                                top: this.formatStyle(re.top, "px"),
                                bottom: this.formatStyle(re.bottom, "px"),
                                left: this.formatStyle(re.left, "px"),
                                right: this.formatStyle(re.right, "px"),
                                height: this.formatStyle(re.height, "px"),
                                width: this.formatStyle(re.width, "px")
                            })
                        }
                }
                R.prototype = r(z.prototype),
                    R.prototype.constructor = R;
                function F(A) {
                    var w, H, X, Z;
                    if (A.div) {
                        H = A.div.offsetHeight,
                            X = A.div.offsetWidth,
                            Z = A.div.offsetTop;
                        var re = (re = A.div.childNodes) && (re = re[0]) && re.getClientRects && re.getClientRects();
                        A = A.div.getBoundingClientRect(),
                            w = re ? Math.max(re[0] && re[0].height || 0, A.height / re.length) : 0
                    }
                    this.left = A.left,
                        this.right = A.right,
                        this.top = A.top || Z,
                        this.height = A.height || H,
                        this.bottom = A.bottom || Z + (A.height || H),
                        this.width = A.width || X,
                        this.lineHeight = w !== void 0 ? w : A.lineHeight
                }
                F.prototype.move = function (A, w) {
                    switch (w = w !== void 0 ? w : this.lineHeight,
                    A) {
                        case "+x":
                            this.left += w,
                                this.right += w;
                            break;
                        case "-x":
                            this.left -= w,
                                this.right -= w;
                            break;
                        case "+y":
                            this.top += w,
                                this.bottom += w;
                            break;
                        case "-y":
                            this.top -= w,
                                this.bottom -= w;
                            break
                    }
                }
                    ,
                    F.prototype.overlaps = function (A) {
                        return this.left < A.right && this.right > A.left && this.top < A.bottom && this.bottom > A.top
                    }
                    ,
                    F.prototype.overlapsAny = function (A) {
                        for (var w = 0; w < A.length; w++)
                            if (this.overlaps(A[w]))
                                return !0;
                        return !1
                    }
                    ,
                    F.prototype.within = function (A) {
                        return this.top >= A.top && this.bottom <= A.bottom && this.left >= A.left && this.right <= A.right
                    }
                    ,
                    F.prototype.overlapsOppositeAxis = function (A, w) {
                        switch (w) {
                            case "+x":
                                return this.left < A.left;
                            case "-x":
                                return this.right > A.right;
                            case "+y":
                                return this.top < A.top;
                            case "-y":
                                return this.bottom > A.bottom
                        }
                    }
                    ,
                    F.prototype.intersectPercentage = function (A) {
                        var w = Math.max(0, Math.min(this.right, A.right) - Math.max(this.left, A.left))
                            , H = Math.max(0, Math.min(this.bottom, A.bottom) - Math.max(this.top, A.top))
                            , X = w * H;
                        return X / (this.height * this.width)
                    }
                    ,
                    F.prototype.toCSSCompatValues = function (A) {
                        return {
                            top: this.top - A.top,
                            bottom: A.bottom - this.bottom,
                            left: this.left - A.left,
                            right: A.right - this.right,
                            height: this.height,
                            width: this.width
                        }
                    }
                    ,
                    F.getSimpleBoxPosition = function (A) {
                        var w = A.div ? A.div.offsetHeight : A.tagName ? A.offsetHeight : 0
                            , H = A.div ? A.div.offsetWidth : A.tagName ? A.offsetWidth : 0
                            , X = A.div ? A.div.offsetTop : A.tagName ? A.offsetTop : 0;
                        A = A.div ? A.div.getBoundingClientRect() : A.tagName ? A.getBoundingClientRect() : A;
                        var Z = {
                            left: A.left,
                            right: A.right,
                            top: A.top || X,
                            height: A.height || w,
                            bottom: A.bottom || X + (A.height || w),
                            width: A.width || H
                        };
                        return Z
                    }
                    ;
                function Y(A, w, H, X) {
                    function Z(ke, At) {
                        for (var qe, wt = new F(ke), $i = 1, yi = 0; yi < At.length; yi++) {
                            for (; ke.overlapsOppositeAxis(H, At[yi]) || ke.within(H) && ke.overlapsAny(X);)
                                ke.move(At[yi]);
                            if (ke.within(H))
                                return ke;
                            var Fs = ke.intersectPercentage(H);
                            $i > Fs && (qe = new F(ke),
                                $i = Fs),
                                ke = new F(wt)
                        }
                        return qe || wt
                    }
                    var re = new F(w)
                        , he = w.cue
                        , oe = B(he)
                        , ie = [];
                    if (he.snapToLines) {
                        var ae;
                        switch (he.vertical) {
                            case "":
                                ie = ["+y", "-y"],
                                    ae = "height";
                                break;
                            case "rl":
                                ie = ["+x", "-x"],
                                    ae = "width";
                                break;
                            case "lr":
                                ie = ["-x", "+x"],
                                    ae = "width";
                                break
                        }
                        var ce = re.lineHeight
                            , se = ce * Math.round(oe)
                            , ve = H[ae] + ce
                            , Me = ie[0];
                        Math.abs(se) > ve && (se = se < 0 ? -1 : 1,
                            se *= Math.ceil(ve / ce) * ce),
                            oe < 0 && (se += he.vertical === "" ? H.height : H.width,
                                ie = ie.reverse()),
                            re.move(Me, se)
                    } else {
                        var ge = re.lineHeight / H.height * 100;
                        switch (he.lineAlign) {
                            case "center":
                                oe -= ge / 2;
                                break;
                            case "end":
                                oe -= ge;
                                break
                        }
                        switch (he.vertical) {
                            case "":
                                w.applyStyles({
                                    top: w.formatStyle(oe, "%")
                                });
                                break;
                            case "rl":
                                w.applyStyles({
                                    left: w.formatStyle(oe, "%")
                                });
                                break;
                            case "lr":
                                w.applyStyles({
                                    right: w.formatStyle(oe, "%")
                                });
                                break
                        }
                        ie = ["+y", "-x", "+x", "-y"],
                            re = new F(w)
                    }
                    var Ce = Z(re, ie);
                    w.move(Ce.toCSSCompatValues(H))
                }
                function ue() { }
                ue.StringDecoder = function () {
                    return {
                        decode: function (A) {
                            if (!A)
                                return "";
                            if (typeof A != "string")
                                throw new Error("Error - expected string data.");
                            return decodeURIComponent(encodeURIComponent(A))
                        }
                    }
                }
                    ,
                    ue.convertCueToDOMTree = function (A, w) {
                        return !A || !w ? null : L(A, w)
                    }
                    ;
                var de = .05
                    , ee = "sans-serif"
                    , G = "1.5%";
                ue.processCues = function (A, w, H) {
                    if (!A || !w || !H)
                        return null;
                    for (; H.firstChild;)
                        H.removeChild(H.firstChild);
                    var X = A.document.createElement("div");
                    X.style.position = "absolute",
                        X.style.left = "0",
                        X.style.right = "0",
                        X.style.top = "0",
                        X.style.bottom = "0",
                        X.style.margin = G,
                        H.appendChild(X);
                    function Z(ce) {
                        for (var se = 0; se < ce.length; se++)
                            if (ce[se].hasBeenReset || !ce[se].displayState)
                                return !0;
                        return !1
                    }
                    if (!Z(w)) {
                        for (var re = 0; re < w.length; re++)
                            X.appendChild(w[re].displayState);
                        return
                    }
                    var he = []
                        , oe = F.getSimpleBoxPosition(X)
                        , ie = Math.round(oe.height * de * 100) / 100
                        , ae = {
                            font: ie + "px " + ee
                        };
                    (function () {
                        for (var ce, se, ve = 0; ve < w.length; ve++)
                            se = w[ve],
                                ce = new R(A, se, ae),
                                X.appendChild(ce.div),
                                Y(A, ce, oe, he),
                                se.displayState = ce.div,
                                he.push(F.getSimpleBoxPosition(ce))
                    }
                    )()
                }
                    ,
                    ue.Parser = function (A, w, H) {
                        H || (H = w,
                            w = {}),
                            w || (w = {}),
                            this.window = A,
                            this.vttjs = w,
                            this.state = "INITIAL",
                            this.buffer = "",
                            this.decoder = H || new TextDecoder("utf8"),
                            this.regionList = []
                    }
                    ,
                    ue.Parser.prototype = {
                        reportOrThrowError: function (A) {
                            if (A instanceof n)
                                this.onparsingerror && this.onparsingerror(A);
                            else
                                throw A
                        },
                        parse: function (A) {
                            var w = this;
                            A && (w.buffer += w.decoder.decode(A, {
                                stream: !0
                            }));
                            function H() {
                                for (var ce = w.buffer, se = 0; se < ce.length && ce[se] !== "\r" && ce[se] !== `
`;)
                                    ++se;
                                var ve = ce.substr(0, se);
                                return ce[se] === "\r" && ++se,
                                    ce[se] === `
` && ++se,
                                    w.buffer = ce.substr(se),
                                    ve
                            }
                            function X(ce) {
                                var se = new o;
                                if (u(ce, function (Me, ge) {
                                    switch (Me) {
                                        case "id":
                                            se.set(Me, ge);
                                            break;
                                        case "width":
                                            se.percent(Me, ge);
                                            break;
                                        case "lines":
                                            se.integer(Me, ge);
                                            break;
                                        case "regionanchor":
                                        case "viewportanchor":
                                            var Ce = ge.split(",");
                                            if (Ce.length !== 2)
                                                break;
                                            var ke = new o;
                                            if (ke.percent("x", Ce[0]),
                                                ke.percent("y", Ce[1]),
                                                !ke.has("x") || !ke.has("y"))
                                                break;
                                            se.set(Me + "X", ke.get("x")),
                                                se.set(Me + "Y", ke.get("y"));
                                            break;
                                        case "scroll":
                                            se.alt(Me, ge, ["up"]);
                                            break
                                    }
                                }, /=/, /\s/),
                                    se.has("id")) {
                                    var ve = new (w.vttjs.VTTRegion || w.window.VTTRegion);
                                    ve.width = se.get("width", 100),
                                        ve.lines = se.get("lines", 3),
                                        ve.regionAnchorX = se.get("regionanchorX", 0),
                                        ve.regionAnchorY = se.get("regionanchorY", 100),
                                        ve.viewportAnchorX = se.get("viewportanchorX", 0),
                                        ve.viewportAnchorY = se.get("viewportanchorY", 100),
                                        ve.scroll = se.get("scroll", ""),
                                        w.onregion && w.onregion(ve),
                                        w.regionList.push({
                                            id: se.get("id"),
                                            region: ve
                                        })
                                }
                            }
                            function Z(ce) {
                                var se = new o;
                                u(ce, function (ve, Me) {
                                    switch (ve) {
                                        case "MPEGT":
                                            se.integer(ve + "S", Me);
                                            break;
                                        case "LOCA":
                                            se.set(ve + "L", a(Me));
                                            break
                                    }
                                }, /[^\d]:/, /,/),
                                    w.ontimestampmap && w.ontimestampmap({
                                        MPEGTS: se.get("MPEGTS"),
                                        LOCAL: se.get("LOCAL")
                                    })
                            }
                            function re(ce) {
                                ce.match(/X-TIMESTAMP-MAP/) ? u(ce, function (se, ve) {
                                    switch (se) {
                                        case "X-TIMESTAMP-MAP":
                                            Z(ve);
                                            break
                                    }
                                }, /=/) : u(ce, function (se, ve) {
                                    switch (se) {
                                        case "Region":
                                            X(ve);
                                            break
                                    }
                                }, /:/)
                            }
                            try {
                                var he;
                                if (w.state === "INITIAL") {
                                    if (!/\r\n|\n/.test(w.buffer))
                                        return this;
                                    he = H();
                                    var oe = he.match(/^WEBVTT([ \t].*)?$/);
                                    if (!oe || !oe[0])
                                        throw new n(n.Errors.BadSignature);
                                    w.state = "HEADER"
                                }
                                for (var ie = !1; w.buffer;) {
                                    if (!/\r\n|\n/.test(w.buffer))
                                        return this;
                                    switch (ie ? ie = !1 : he = H(),
                                    w.state) {
                                        case "HEADER":
                                            /:/.test(he) ? re(he) : he || (w.state = "ID");
                                            continue;
                                        case "NOTE":
                                            he || (w.state = "ID");
                                            continue;
                                        case "ID":
                                            if (/^NOTE($|[ \t])/.test(he)) {
                                                w.state = "NOTE";
                                                break
                                            }
                                            if (!he)
                                                continue;
                                            w.cue = new (w.vttjs.VTTCue || w.window.VTTCue)(0, 0, "");
                                            try {
                                                w.cue.align = "center"
                                            } catch (ce) {
                                                w.cue.align = "middle"
                                            }
                                            if (w.state = "CUE",
                                                he.indexOf("-->") === -1) {
                                                w.cue.id = he;
                                                continue
                                            }
                                        case "CUE":
                                            try {
                                                c(he, w.cue, w.regionList)
                                            } catch (ce) {
                                                w.reportOrThrowError(ce),
                                                    w.cue = null,
                                                    w.state = "BADCUE";
                                                continue
                                            }
                                            w.state = "CUETEXT";
                                            continue;
                                        case "CUETEXT":
                                            var ae = he.indexOf("-->") !== -1;
                                            if (!he || ae && (ie = !0)) {
                                                w.oncue && w.oncue(w.cue),
                                                    w.cue = null,
                                                    w.state = "ID";
                                                continue
                                            }
                                            w.cue.text && (w.cue.text += `
`),
                                                w.cue.text += he.replace(/\u2028/g, `
`).replace(/u2029/g, `
`);
                                            continue;
                                        case "BADCUE":
                                            he || (w.state = "ID");
                                            continue
                                    }
                                }
                            } catch (ce) {
                                w.reportOrThrowError(ce),
                                    w.state === "CUETEXT" && w.cue && w.oncue && w.oncue(w.cue),
                                    w.cue = null,
                                    w.state = w.state === "INITIAL" ? "BADWEBVTT" : "BADCUE"
                            }
                            return this
                        },
                        flush: function () {
                            var A = this;
                            try {
                                if (A.buffer += A.decoder.decode(),
                                    (A.cue || A.state === "HEADER") && (A.buffer += `

`,
                                        A.parse()),
                                    A.state === "INITIAL")
                                    throw new n(n.Errors.BadSignature)
                            } catch (w) {
                                A.reportOrThrowError(w)
                            }
                            return A.onflush && A.onflush(),
                                this
                        }
                    },
                    e.exports = ue
            }
        })
        , Iy = Ke({
            "node_modules/videojs-vtt.js/lib/vttcue.js"(t, e) {
                var s = "auto"
                    , r = {
                        "": 1,
                        lr: 1,
                        rl: 1
                    }
                    , n = {
                        start: 1,
                        center: 1,
                        end: 1,
                        left: 1,
                        right: 1,
                        auto: 1,
                        "line-left": 1,
                        "line-right": 1
                    };
                function a(c) {
                    if (typeof c != "string")
                        return !1;
                    var f = r[c.toLowerCase()];
                    return f ? c.toLowerCase() : !1
                }
                function o(c) {
                    if (typeof c != "string")
                        return !1;
                    var f = n[c.toLowerCase()];
                    return f ? c.toLowerCase() : !1
                }
                function u(c, f, v) {
                    this.hasBeenReset = !1;
                    var T = ""
                        , D = !1
                        , _ = c
                        , L = f
                        , M = v
                        , N = null
                        , x = ""
                        , B = !0
                        , z = "auto"
                        , R = "start"
                        , F = "auto"
                        , Y = "auto"
                        , ue = 100
                        , de = "center";
                    Object.defineProperties(this, {
                        id: {
                            enumerable: !0,
                            get: function () {
                                return T
                            },
                            set: function (ee) {
                                T = "" + ee
                            }
                        },
                        pauseOnExit: {
                            enumerable: !0,
                            get: function () {
                                return D
                            },
                            set: function (ee) {
                                D = !!ee
                            }
                        },
                        startTime: {
                            enumerable: !0,
                            get: function () {
                                return _
                            },
                            set: function (ee) {
                                if (typeof ee != "number")
                                    throw new TypeError("Start time must be set to a number.");
                                _ = ee,
                                    this.hasBeenReset = !0
                            }
                        },
                        endTime: {
                            enumerable: !0,
                            get: function () {
                                return L
                            },
                            set: function (ee) {
                                if (typeof ee != "number")
                                    throw new TypeError("End time must be set to a number.");
                                L = ee,
                                    this.hasBeenReset = !0
                            }
                        },
                        text: {
                            enumerable: !0,
                            get: function () {
                                return M
                            },
                            set: function (ee) {
                                M = "" + ee,
                                    this.hasBeenReset = !0
                            }
                        },
                        region: {
                            enumerable: !0,
                            get: function () {
                                return N
                            },
                            set: function (ee) {
                                N = ee,
                                    this.hasBeenReset = !0
                            }
                        },
                        vertical: {
                            enumerable: !0,
                            get: function () {
                                return x
                            },
                            set: function (ee) {
                                var G = a(ee);
                                if (G === !1)
                                    throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
                                x = G,
                                    this.hasBeenReset = !0
                            }
                        },
                        snapToLines: {
                            enumerable: !0,
                            get: function () {
                                return B
                            },
                            set: function (ee) {
                                B = !!ee,
                                    this.hasBeenReset = !0
                            }
                        },
                        line: {
                            enumerable: !0,
                            get: function () {
                                return z
                            },
                            set: function (ee) {
                                if (typeof ee != "number" && ee !== s)
                                    throw new SyntaxError("Line: an invalid number or illegal string was specified.");
                                z = ee,
                                    this.hasBeenReset = !0
                            }
                        },
                        lineAlign: {
                            enumerable: !0,
                            get: function () {
                                return R
                            },
                            set: function (ee) {
                                var G = o(ee);
                                G ? (R = G,
                                    this.hasBeenReset = !0) : console.warn("lineAlign: an invalid or illegal string was specified.")
                            }
                        },
                        position: {
                            enumerable: !0,
                            get: function () {
                                return F
                            },
                            set: function (ee) {
                                if (ee < 0 || ee > 100)
                                    throw new Error("Position must be between 0 and 100.");
                                F = ee,
                                    this.hasBeenReset = !0
                            }
                        },
                        positionAlign: {
                            enumerable: !0,
                            get: function () {
                                return Y
                            },
                            set: function (ee) {
                                var G = o(ee);
                                G ? (Y = G,
                                    this.hasBeenReset = !0) : console.warn("positionAlign: an invalid or illegal string was specified.")
                            }
                        },
                        size: {
                            enumerable: !0,
                            get: function () {
                                return ue
                            },
                            set: function (ee) {
                                if (ee < 0 || ee > 100)
                                    throw new Error("Size must be between 0 and 100.");
                                ue = ee,
                                    this.hasBeenReset = !0
                            }
                        },
                        align: {
                            enumerable: !0,
                            get: function () {
                                return de
                            },
                            set: function (ee) {
                                var G = o(ee);
                                if (!G)
                                    throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
                                de = G,
                                    this.hasBeenReset = !0
                            }
                        }
                    }),
                        this.displayState = void 0
                }
                u.prototype.getCueAsHTML = function () {
                    return WebVTT.convertCueToDOMTree(window, this.text)
                }
                    ,
                    e.exports = u
            }
        })
        , Py = Ke({
            "node_modules/videojs-vtt.js/lib/vttregion.js"(t, e) {
                var s = {
                    "": !0,
                    up: !0
                };
                function r(o) {
                    if (typeof o != "string")
                        return !1;
                    var u = s[o.toLowerCase()];
                    return u ? o.toLowerCase() : !1
                }
                function n(o) {
                    return typeof o == "number" && o >= 0 && o <= 100
                }
                function a() {
                    var o = 100
                        , u = 3
                        , c = 0
                        , f = 100
                        , v = 0
                        , T = 100
                        , D = "";
                    Object.defineProperties(this, {
                        width: {
                            enumerable: !0,
                            get: function () {
                                return o
                            },
                            set: function (_) {
                                if (!n(_))
                                    throw new Error("Width must be between 0 and 100.");
                                o = _
                            }
                        },
                        lines: {
                            enumerable: !0,
                            get: function () {
                                return u
                            },
                            set: function (_) {
                                if (typeof _ != "number")
                                    throw new TypeError("Lines must be set to a number.");
                                u = _
                            }
                        },
                        regionAnchorY: {
                            enumerable: !0,
                            get: function () {
                                return f
                            },
                            set: function (_) {
                                if (!n(_))
                                    throw new Error("RegionAnchorX must be between 0 and 100.");
                                f = _
                            }
                        },
                        regionAnchorX: {
                            enumerable: !0,
                            get: function () {
                                return c
                            },
                            set: function (_) {
                                if (!n(_))
                                    throw new Error("RegionAnchorY must be between 0 and 100.");
                                c = _
                            }
                        },
                        viewportAnchorY: {
                            enumerable: !0,
                            get: function () {
                                return T
                            },
                            set: function (_) {
                                if (!n(_))
                                    throw new Error("ViewportAnchorY must be between 0 and 100.");
                                T = _
                            }
                        },
                        viewportAnchorX: {
                            enumerable: !0,
                            get: function () {
                                return v
                            },
                            set: function (_) {
                                if (!n(_))
                                    throw new Error("ViewportAnchorX must be between 0 and 100.");
                                v = _
                            }
                        },
                        scroll: {
                            enumerable: !0,
                            get: function () {
                                return D
                            },
                            set: function (_) {
                                var L = r(_);
                                L === !1 ? console.warn("Scroll: an invalid or illegal string was specified.") : D = L
                            }
                        }
                    })
                }
                e.exports = a
            }
        })
        , Ly = Ke({
            "node_modules/videojs-vtt.js/lib/browser-index.js"(t, e) {
                var s = Ki()
                    , r = e.exports = {
                        WebVTT: xy(),
                        VTTCue: Iy(),
                        VTTRegion: Py()
                    };
                s.vttjs = r,
                    s.WebVTT = r.WebVTT;
                var n = r.VTTCue
                    , a = r.VTTRegion
                    , o = s.VTTCue
                    , u = s.VTTRegion;
                r.shim = function () {
                    s.VTTCue = n,
                        s.VTTRegion = a
                }
                    ,
                    r.restore = function () {
                        s.VTTCue = o,
                            s.VTTRegion = u
                    }
                    ,
                    s.VTTCue || r.shim()
            }
        })
        , Oy = Ke({
            "node_modules/url-toolkit/src/url-toolkit.js"(t, e) {
                (function (s) {
                    var r = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/
                        , n = /^(?=([^\/?#]*))\1([^]*)$/
                        , a = /(?:\/|^)\.(?=\/)/g
                        , o = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g
                        , u = {
                            buildAbsoluteURL: function (c, f, v) {
                                if (v = v || {},
                                    c = c.trim(),
                                    f = f.trim(),
                                    !f) {
                                    if (!v.alwaysNormalize)
                                        return c;
                                    var T = u.parseURL(c);
                                    if (!T)
                                        throw new Error("Error trying to parse base URL.");
                                    return T.path = u.normalizePath(T.path),
                                        u.buildURLFromParts(T)
                                }
                                var D = u.parseURL(f);
                                if (!D)
                                    throw new Error("Error trying to parse relative URL.");
                                if (D.scheme)
                                    return v.alwaysNormalize ? (D.path = u.normalizePath(D.path),
                                        u.buildURLFromParts(D)) : f;
                                var _ = u.parseURL(c);
                                if (!_)
                                    throw new Error("Error trying to parse base URL.");
                                if (!_.netLoc && _.path && _.path[0] !== "/") {
                                    var L = n.exec(_.path);
                                    _.netLoc = L[1],
                                        _.path = L[2]
                                }
                                _.netLoc && !_.path && (_.path = "/");
                                var M = {
                                    scheme: _.scheme,
                                    netLoc: D.netLoc,
                                    path: null,
                                    params: D.params,
                                    query: D.query,
                                    fragment: D.fragment
                                };
                                if (!D.netLoc && (M.netLoc = _.netLoc,
                                    D.path[0] !== "/"))
                                    if (!D.path)
                                        M.path = _.path,
                                            D.params || (M.params = _.params,
                                                D.query || (M.query = _.query));
                                    else {
                                        var N = _.path
                                            , x = N.substring(0, N.lastIndexOf("/") + 1) + D.path;
                                        M.path = u.normalizePath(x)
                                    }
                                return M.path === null && (M.path = v.alwaysNormalize ? u.normalizePath(D.path) : D.path),
                                    u.buildURLFromParts(M)
                            },
                            parseURL: function (c) {
                                var f = r.exec(c);
                                return f ? {
                                    scheme: f[1] || "",
                                    netLoc: f[2] || "",
                                    path: f[3] || "",
                                    params: f[4] || "",
                                    query: f[5] || "",
                                    fragment: f[6] || ""
                                } : null
                            },
                            normalizePath: function (c) {
                                for (c = c.split("").reverse().join("").replace(a, ""); c.length !== (c = c.replace(o, "")).length;)
                                    ;
                                return c.split("").reverse().join("")
                            },
                            buildURLFromParts: function (c) {
                                return c.scheme + c.netLoc + c.path + c.params + c.query + c.fragment
                            }
                        };
                    typeof t == "object" && typeof e == "object" ? e.exports = u : typeof define == "function" && define.amd ? define([], function () {
                        return u
                    }) : typeof t == "object" ? t.URLToolkit = u : s.URLToolkit = u
                }
                )(t)
            }
        })
        , Uo = Ke({
            "node_modules/@xmldom/xmldom/lib/conventions.js"(t) {
                "use strict";
                function e(o, u, c) {
                    if (c === void 0 && (c = Array.prototype),
                        o && typeof c.find == "function")
                        return c.find.call(o, u);
                    for (var f = 0; f < o.length; f++)
                        if (Object.prototype.hasOwnProperty.call(o, f)) {
                            var v = o[f];
                            if (u.call(void 0, v, f, o))
                                return v
                        }
                }
                function s(o, u) {
                    return u === void 0 && (u = Object),
                        u && typeof u.freeze == "function" ? u.freeze(o) : o
                }
                function r(o, u) {
                    if (o === null || typeof o != "object")
                        throw new TypeError("target is not an object");
                    for (var c in u)
                        Object.prototype.hasOwnProperty.call(u, c) && (o[c] = u[c]);
                    return o
                }
                var n = s({
                    HTML: "text/html",
                    isHTML: function (o) {
                        return o === n.HTML
                    },
                    XML_APPLICATION: "application/xml",
                    XML_TEXT: "text/xml",
                    XML_XHTML_APPLICATION: "application/xhtml+xml",
                    XML_SVG_IMAGE: "image/svg+xml"
                })
                    , a = s({
                        HTML: "http://www.w3.org/1999/xhtml",
                        isHTML: function (o) {
                            return o === a.HTML
                        },
                        SVG: "http://www.w3.org/2000/svg",
                        XML: "http://www.w3.org/XML/1998/namespace",
                        XMLNS: "http://www.w3.org/2000/xmlns/"
                    });
                t.assign = r,
                    t.find = e,
                    t.freeze = s,
                    t.MIME_TYPE = n,
                    t.NAMESPACE = a
            }
        })
        , wc = Ke({
            "node_modules/@xmldom/xmldom/lib/dom.js"(t) {
                var e = Uo()
                    , s = e.find
                    , r = e.NAMESPACE;
                function n(b) {
                    return b !== ""
                }
                function a(b) {
                    return b ? b.split(/[\t\n\f\r ]+/).filter(n) : []
                }
                function o(b, E) {
                    return b.hasOwnProperty(E) || (b[E] = !0),
                        b
                }
                function u(b) {
                    if (!b)
                        return [];
                    var E = a(b);
                    return Object.keys(E.reduce(o, {}))
                }
                function c(b) {
                    return function (E) {
                        return b && b.indexOf(E) !== -1
                    }
                }
                function f(b, E) {
                    for (var P in b)
                        Object.prototype.hasOwnProperty.call(b, P) && (E[P] = b[P])
                }
                function v(b, E) {
                    var P = b.prototype;
                    if (!(P instanceof E)) {
                        let ne = function () { };
                        var W = ne;
                        ne.prototype = E.prototype,
                            ne = new ne,
                            f(P, ne),
                            b.prototype = P = ne
                    }
                    P.constructor != b && (typeof b != "function" && console.error("unknown Class:" + b),
                        P.constructor = b)
                }
                var T = {}
                    , D = T.ELEMENT_NODE = 1
                    , _ = T.ATTRIBUTE_NODE = 2
                    , L = T.TEXT_NODE = 3
                    , M = T.CDATA_SECTION_NODE = 4
                    , N = T.ENTITY_REFERENCE_NODE = 5
                    , x = T.ENTITY_NODE = 6
                    , B = T.PROCESSING_INSTRUCTION_NODE = 7
                    , z = T.COMMENT_NODE = 8
                    , R = T.DOCUMENT_NODE = 9
                    , F = T.DOCUMENT_TYPE_NODE = 10
                    , Y = T.DOCUMENT_FRAGMENT_NODE = 11
                    , ue = T.NOTATION_NODE = 12
                    , de = {}
                    , ee = {}
                    , G = de.INDEX_SIZE_ERR = (ee[1] = "Index size error",
                        1)
                    , A = de.DOMSTRING_SIZE_ERR = (ee[2] = "DOMString size error",
                        2)
                    , w = de.HIERARCHY_REQUEST_ERR = (ee[3] = "Hierarchy request error",
                        3)
                    , H = de.WRONG_DOCUMENT_ERR = (ee[4] = "Wrong document",
                        4)
                    , X = de.INVALID_CHARACTER_ERR = (ee[5] = "Invalid character",
                        5)
                    , Z = de.NO_DATA_ALLOWED_ERR = (ee[6] = "No data allowed",
                        6)
                    , re = de.NO_MODIFICATION_ALLOWED_ERR = (ee[7] = "No modification allowed",
                        7)
                    , he = de.NOT_FOUND_ERR = (ee[8] = "Not found",
                        8)
                    , oe = de.NOT_SUPPORTED_ERR = (ee[9] = "Not supported",
                        9)
                    , ie = de.INUSE_ATTRIBUTE_ERR = (ee[10] = "Attribute in use",
                        10)
                    , ae = de.INVALID_STATE_ERR = (ee[11] = "Invalid state",
                        11)
                    , ce = de.SYNTAX_ERR = (ee[12] = "Syntax error",
                        12)
                    , se = de.INVALID_MODIFICATION_ERR = (ee[13] = "Invalid modification",
                        13)
                    , ve = de.NAMESPACE_ERR = (ee[14] = "Invalid namespace",
                        14)
                    , Me = de.INVALID_ACCESS_ERR = (ee[15] = "Invalid access",
                        15);
                function ge(b, E) {
                    if (E instanceof Error)
                        var P = E;
                    else
                        P = this,
                            Error.call(this, ee[b]),
                            this.message = ee[b],
                            Error.captureStackTrace && Error.captureStackTrace(this, ge);
                    return P.code = b,
                        E && (this.message = this.message + ": " + E),
                        P
                }
                ge.prototype = Error.prototype,
                    f(de, ge);
                function Ce() { }
                Ce.prototype = {
                    length: 0,
                    item: function (b) {
                        return b >= 0 && b < this.length ? this[b] : null
                    },
                    toString: function (b, E) {
                        for (var P = [], W = 0; W < this.length; W++)
                            cr(this[W], P, b, E);
                        return P.join("")
                    },
                    filter: function (b) {
                        return Array.prototype.filter.call(this, b)
                    },
                    indexOf: function (b) {
                        return Array.prototype.indexOf.call(this, b)
                    }
                };
                function ke(b, E) {
                    this._node = b,
                        this._refresh = E,
                        At(this)
                }
                function At(b) {
                    var E = b._node._inc || b._node.ownerDocument._inc;
                    if (b._inc !== E) {
                        var P = b._refresh(b._node);
                        if (aa(b, "length", P.length),
                            !b.$$length || P.length < b.$$length)
                            for (var W = P.length; W in b; W++)
                                Object.prototype.hasOwnProperty.call(b, W) && delete b[W];
                        f(P, b),
                            b._inc = E
                    }
                }
                ke.prototype.item = function (b) {
                    return At(this),
                        this[b] || null
                }
                    ,
                    v(ke, Ce);
                function qe() { }
                function wt(b, E) {
                    for (var P = b.length; P--;)
                        if (b[P] === E)
                            return P
                }
                function $i(b, E, P, W) {
                    if (W ? E[wt(E, W)] = P : E[E.length++] = P,
                        b) {
                        P.ownerElement = b;
                        var ne = b.ownerDocument;
                        ne && (W && dr(ne, b, W),
                            _i(ne, b, P))
                    }
                }
                function yi(b, E, P) {
                    var W = wt(E, P);
                    if (W >= 0) {
                        for (var ne = E.length - 1; W < ne;)
                            E[W] = E[++W];
                        if (E.length = ne,
                            b) {
                            var Se = b.ownerDocument;
                            Se && (dr(Se, b, P),
                                P.ownerElement = null)
                        }
                    } else
                        throw new ge(he, new Error(b.tagName + "@" + P))
                }
                qe.prototype = {
                    length: 0,
                    item: Ce.prototype.item,
                    getNamedItem: function (b) {
                        for (var E = this.length; E--;) {
                            var P = this[E];
                            if (P.nodeName == b)
                                return P
                        }
                    },
                    setNamedItem: function (b) {
                        var E = b.ownerElement;
                        if (E && E != this._ownerElement)
                            throw new ge(ie);
                        var P = this.getNamedItem(b.nodeName);
                        return $i(this._ownerElement, this, b, P),
                            P
                    },
                    setNamedItemNS: function (b) {
                        var E = b.ownerElement, P;
                        if (E && E != this._ownerElement)
                            throw new ge(ie);
                        return P = this.getNamedItemNS(b.namespaceURI, b.localName),
                            $i(this._ownerElement, this, b, P),
                            P
                    },
                    removeNamedItem: function (b) {
                        var E = this.getNamedItem(b);
                        return yi(this._ownerElement, this, E),
                            E
                    },
                    removeNamedItemNS: function (b, E) {
                        var P = this.getNamedItemNS(b, E);
                        return yi(this._ownerElement, this, P),
                            P
                    },
                    getNamedItemNS: function (b, E) {
                        for (var P = this.length; P--;) {
                            var W = this[P];
                            if (W.localName == E && W.namespaceURI == b)
                                return W
                        }
                        return null
                    }
                };
                function Fs() { }
                Fs.prototype = {
                    hasFeature: function (b, E) {
                        return !0
                    },
                    createDocument: function (b, E, P) {
                        var W = new Ze;
                        if (W.implementation = this,
                            W.childNodes = new Ce,
                            W.doctype = P || null,
                            P && W.appendChild(P),
                            E) {
                            var ne = W.createElementNS(b, E);
                            W.appendChild(ne)
                        }
                        return W
                    },
                    createDocumentType: function (b, E, P) {
                        var W = new sa;
                        return W.name = b,
                            W.nodeName = b,
                            W.publicId = E || "",
                            W.systemId = P || "",
                            W
                    }
                };
                function Pe() { }
                Pe.prototype = {
                    firstChild: null,
                    lastChild: null,
                    previousSibling: null,
                    nextSibling: null,
                    attributes: null,
                    parentNode: null,
                    childNodes: null,
                    ownerDocument: null,
                    nodeValue: null,
                    namespaceURI: null,
                    prefix: null,
                    localName: null,
                    insertBefore: function (b, E) {
                        return Ne(this, b, E)
                    },
                    replaceChild: function (b, E) {
                        Ne(this, b, E, vo),
                            E && this.removeChild(E)
                    },
                    removeChild: function (b) {
                        return Hr(this, b)
                    },
                    appendChild: function (b) {
                        return this.insertBefore(b, null)
                    },
                    hasChildNodes: function () {
                        return this.firstChild != null
                    },
                    cloneNode: function (b) {
                        return na(this.ownerDocument || this, this, b)
                    },
                    normalize: function () {
                        for (var b = this.firstChild; b;) {
                            var E = b.nextSibling;
                            E && E.nodeType == L && b.nodeType == L ? (this.removeChild(E),
                                b.appendData(E.data)) : (b.normalize(),
                                    b = E)
                        }
                    },
                    isSupported: function (b, E) {
                        return this.ownerDocument.implementation.hasFeature(b, E)
                    },
                    hasAttributes: function () {
                        return this.attributes.length > 0
                    },
                    lookupPrefix: function (b) {
                        for (var E = this; E;) {
                            var P = E._nsMap;
                            if (P) {
                                for (var W in P)
                                    if (Object.prototype.hasOwnProperty.call(P, W) && P[W] === b)
                                        return W
                            }
                            E = E.nodeType == _ ? E.ownerDocument : E.parentNode
                        }
                        return null
                    },
                    lookupNamespaceURI: function (b) {
                        for (var E = this; E;) {
                            var P = E._nsMap;
                            if (P && Object.prototype.hasOwnProperty.call(P, b))
                                return P[b];
                            E = E.nodeType == _ ? E.ownerDocument : E.parentNode
                        }
                        return null
                    },
                    isDefaultNamespace: function (b) {
                        var E = this.lookupPrefix(b);
                        return E == null
                    }
                };
                function vt(b) {
                    return b == "<" && "&lt;" || b == ">" && "&gt;" || b == "&" && "&amp;" || b == '"' && "&quot;" || "&#" + b.charCodeAt() + ";"
                }
                f(T, Pe),
                    f(T, Pe.prototype);
                function Vi(b, E) {
                    if (E(b))
                        return !0;
                    if (b = b.firstChild)
                        do
                            if (Vi(b, E))
                                return !0;
                        while (b = b.nextSibling)
                }
                function Ze() {
                    this.ownerDocument = this
                }
                function _i(b, E, P) {
                    b && b._inc++;
                    var W = P.namespaceURI;
                    W === r.XMLNS && (E._nsMap[P.prefix ? P.localName : ""] = P.value)
                }
                function dr(b, E, P, W) {
                    b && b._inc++;
                    var ne = P.namespaceURI;
                    ne === r.XMLNS && delete E._nsMap[P.prefix ? P.localName : ""]
                }
                function xe(b, E, P) {
                    if (b && b._inc) {
                        b._inc++;
                        var W = E.childNodes;
                        if (P)
                            W[W.length++] = P;
                        else {
                            for (var ne = E.firstChild, Se = 0; ne;)
                                W[Se++] = ne,
                                    ne = ne.nextSibling;
                            W.length = Se,
                                delete W[W.length]
                        }
                    }
                }
                function Hr(b, E) {
                    var P = E.previousSibling
                        , W = E.nextSibling;
                    return P ? P.nextSibling = W : b.firstChild = W,
                        W ? W.previousSibling = P : b.lastChild = P,
                        E.parentNode = null,
                        E.previousSibling = null,
                        E.nextSibling = null,
                        xe(b.ownerDocument, b),
                        E
                }
                function $e(b) {
                    return b && (b.nodeType === Pe.DOCUMENT_NODE || b.nodeType === Pe.DOCUMENT_FRAGMENT_NODE || b.nodeType === Pe.ELEMENT_NODE)
                }
                function Nt(b) {
                    return b && (ni(b) || qr(b) || Yt(b) || b.nodeType === Pe.DOCUMENT_FRAGMENT_NODE || b.nodeType === Pe.COMMENT_NODE || b.nodeType === Pe.PROCESSING_INSTRUCTION_NODE)
                }
                function Yt(b) {
                    return b && b.nodeType === Pe.DOCUMENT_TYPE_NODE
                }
                function ni(b) {
                    return b && b.nodeType === Pe.ELEMENT_NODE
                }
                function qr(b) {
                    return b && b.nodeType === Pe.TEXT_NODE
                }
                function $r(b, E) {
                    var P = b.childNodes || [];
                    if (s(P, ni) || Yt(E))
                        return !1;
                    var W = s(P, Yt);
                    return !(E && W && P.indexOf(W) > P.indexOf(E))
                }
                function ta(b, E) {
                    var P = b.childNodes || [];
                    function W(Se) {
                        return ni(Se) && Se !== E
                    }
                    if (s(P, W))
                        return !1;
                    var ne = s(P, Yt);
                    return !(E && ne && P.indexOf(ne) > P.indexOf(E))
                }
                function Iu(b, E, P) {
                    if (!$e(b))
                        throw new ge(w, "Unexpected parent node type " + b.nodeType);
                    if (P && P.parentNode !== b)
                        throw new ge(he, "child not in parent");
                    if (!Nt(E) || Yt(E) && b.nodeType !== Pe.DOCUMENT_NODE)
                        throw new ge(w, "Unexpected node type " + E.nodeType + " for parent node type " + b.nodeType)
                }
                function Pu(b, E, P) {
                    var W = b.childNodes || []
                        , ne = E.childNodes || [];
                    if (E.nodeType === Pe.DOCUMENT_FRAGMENT_NODE) {
                        var Se = ne.filter(ni);
                        if (Se.length > 1 || s(ne, qr))
                            throw new ge(w, "More than one element or text in fragment");
                        if (Se.length === 1 && !$r(b, P))
                            throw new ge(w, "Element in fragment can not be inserted before doctype")
                    }
                    if (ni(E) && !$r(b, P))
                        throw new ge(w, "Only one element can be added and only after doctype");
                    if (Yt(E)) {
                        if (s(W, Yt))
                            throw new ge(w, "Only one doctype is allowed");
                        var be = s(W, ni);
                        if (P && W.indexOf(be) < W.indexOf(P))
                            throw new ge(w, "Doctype can only be inserted before an element");
                        if (!P && be)
                            throw new ge(w, "Doctype can not be appended since element is present")
                    }
                }
                function vo(b, E, P) {
                    var W = b.childNodes || []
                        , ne = E.childNodes || [];
                    if (E.nodeType === Pe.DOCUMENT_FRAGMENT_NODE) {
                        var Se = ne.filter(ni);
                        if (Se.length > 1 || s(ne, qr))
                            throw new ge(w, "More than one element or text in fragment");
                        if (Se.length === 1 && !ta(b, P))
                            throw new ge(w, "Element in fragment can not be inserted before doctype")
                    }
                    if (ni(E) && !ta(b, P))
                        throw new ge(w, "Only one element can be added and only after doctype");
                    if (Yt(E)) {
                        let ai = function (Bt) {
                            return Yt(Bt) && Bt !== P
                        };
                        var be = ai;
                        if (s(W, ai))
                            throw new ge(w, "Only one doctype is allowed");
                        var Dt = s(W, ni);
                        if (P && W.indexOf(Dt) < W.indexOf(P))
                            throw new ge(w, "Doctype can only be inserted before an element")
                    }
                }
                function Ne(b, E, P, W) {
                    Iu(b, E, P),
                        b.nodeType === Pe.DOCUMENT_NODE && (W || Pu)(b, E, P);
                    var ne = E.parentNode;
                    if (ne && ne.removeChild(E),
                        E.nodeType === Y) {
                        var Se = E.firstChild;
                        if (Se == null)
                            return E;
                        var be = E.lastChild
                    } else
                        Se = be = E;
                    var Dt = P ? P.previousSibling : b.lastChild;
                    Se.previousSibling = Dt,
                        be.nextSibling = P,
                        Dt ? Dt.nextSibling = Se : b.firstChild = Se,
                        P == null ? b.lastChild = be : P.previousSibling = be;
                    do
                        Se.parentNode = b;
                    while (Se !== be && (Se = Se.nextSibling));
                    return xe(b.ownerDocument || b, b),
                        E.nodeType == Y && (E.firstChild = E.lastChild = null),
                        E
                }
                function Qd(b, E) {
                    return E.parentNode && E.parentNode.removeChild(E),
                        E.parentNode = b,
                        E.previousSibling = b.lastChild,
                        E.nextSibling = null,
                        E.previousSibling ? E.previousSibling.nextSibling = E : b.firstChild = E,
                        b.lastChild = E,
                        xe(b.ownerDocument, b, E),
                        E
                }
                Ze.prototype = {
                    nodeName: "#document",
                    nodeType: R,
                    doctype: null,
                    documentElement: null,
                    _inc: 1,
                    insertBefore: function (b, E) {
                        if (b.nodeType == Y) {
                            for (var P = b.firstChild; P;) {
                                var W = P.nextSibling;
                                this.insertBefore(P, E),
                                    P = W
                            }
                            return b
                        }
                        return Ne(this, b, E),
                            b.ownerDocument = this,
                            this.documentElement === null && b.nodeType === D && (this.documentElement = b),
                            b
                    },
                    removeChild: function (b) {
                        return this.documentElement == b && (this.documentElement = null),
                            Hr(this, b)
                    },
                    replaceChild: function (b, E) {
                        Ne(this, b, E, vo),
                            b.ownerDocument = this,
                            E && this.removeChild(E),
                            ni(b) && (this.documentElement = b)
                    },
                    importNode: function (b, E) {
                        return Nu(this, b, E)
                    },
                    getElementById: function (b) {
                        var E = null;
                        return Vi(this.documentElement, function (P) {
                            if (P.nodeType == D && P.getAttribute("id") == b)
                                return E = P,
                                    !0
                        }),
                            E
                    },
                    getElementsByClassName: function (b) {
                        var E = u(b);
                        return new ke(this, function (P) {
                            var W = [];
                            return E.length > 0 && Vi(P.documentElement, function (ne) {
                                if (ne !== P && ne.nodeType === D) {
                                    var Se = ne.getAttribute("class");
                                    if (Se) {
                                        var be = b === Se;
                                        if (!be) {
                                            var Dt = u(Se);
                                            be = E.every(c(Dt))
                                        }
                                        be && W.push(ne)
                                    }
                                }
                            }),
                                W
                        }
                        )
                    },
                    createElement: function (b) {
                        var E = new xi;
                        E.ownerDocument = this,
                            E.nodeName = b,
                            E.tagName = b,
                            E.localName = b,
                            E.childNodes = new Ce;
                        var P = E.attributes = new qe;
                        return P._ownerElement = E,
                            E
                    },
                    createDocumentFragment: function () {
                        var b = new ra;
                        return b.ownerDocument = this,
                            b.childNodes = new Ce,
                            b
                    },
                    createTextNode: function (b) {
                        var E = new yo;
                        return E.ownerDocument = this,
                            E.appendData(b),
                            E
                    },
                    createComment: function (b) {
                        var E = new _o;
                        return E.ownerDocument = this,
                            E.appendData(b),
                            E
                    },
                    createCDATASection: function (b) {
                        var E = new To;
                        return E.ownerDocument = this,
                            E.appendData(b),
                            E
                    },
                    createProcessingInstruction: function (b, E) {
                        var P = new Eo;
                        return P.ownerDocument = this,
                            P.tagName = P.nodeName = P.target = b,
                            P.nodeValue = P.data = E,
                            P
                    },
                    createAttribute: function (b) {
                        var E = new ia;
                        return E.ownerDocument = this,
                            E.name = b,
                            E.nodeName = b,
                            E.localName = b,
                            E.specified = !0,
                            E
                    },
                    createEntityReference: function (b) {
                        var E = new bo;
                        return E.ownerDocument = this,
                            E.nodeName = b,
                            E
                    },
                    createElementNS: function (b, E) {
                        var P = new xi
                            , W = E.split(":")
                            , ne = P.attributes = new qe;
                        return P.childNodes = new Ce,
                            P.ownerDocument = this,
                            P.nodeName = E,
                            P.tagName = E,
                            P.namespaceURI = b,
                            W.length == 2 ? (P.prefix = W[0],
                                P.localName = W[1]) : P.localName = E,
                            ne._ownerElement = P,
                            P
                    },
                    createAttributeNS: function (b, E) {
                        var P = new ia
                            , W = E.split(":");
                        return P.ownerDocument = this,
                            P.nodeName = E,
                            P.name = E,
                            P.namespaceURI = b,
                            P.specified = !0,
                            W.length == 2 ? (P.prefix = W[0],
                                P.localName = W[1]) : P.localName = E,
                            P
                    }
                },
                    v(Ze, Pe);
                function xi() {
                    this._nsMap = {}
                }
                xi.prototype = {
                    nodeType: D,
                    hasAttribute: function (b) {
                        return this.getAttributeNode(b) != null
                    },
                    getAttribute: function (b) {
                        var E = this.getAttributeNode(b);
                        return E && E.value || ""
                    },
                    getAttributeNode: function (b) {
                        return this.attributes.getNamedItem(b)
                    },
                    setAttribute: function (b, E) {
                        var P = this.ownerDocument.createAttribute(b);
                        P.value = P.nodeValue = "" + E,
                            this.setAttributeNode(P)
                    },
                    removeAttribute: function (b) {
                        var E = this.getAttributeNode(b);
                        E && this.removeAttributeNode(E)
                    },
                    appendChild: function (b) {
                        return b.nodeType === Y ? this.insertBefore(b, null) : Qd(this, b)
                    },
                    setAttributeNode: function (b) {
                        return this.attributes.setNamedItem(b)
                    },
                    setAttributeNodeNS: function (b) {
                        return this.attributes.setNamedItemNS(b)
                    },
                    removeAttributeNode: function (b) {
                        return this.attributes.removeNamedItem(b.nodeName)
                    },
                    removeAttributeNS: function (b, E) {
                        var P = this.getAttributeNodeNS(b, E);
                        P && this.removeAttributeNode(P)
                    },
                    hasAttributeNS: function (b, E) {
                        return this.getAttributeNodeNS(b, E) != null
                    },
                    getAttributeNS: function (b, E) {
                        var P = this.getAttributeNodeNS(b, E);
                        return P && P.value || ""
                    },
                    setAttributeNS: function (b, E, P) {
                        var W = this.ownerDocument.createAttributeNS(b, E);
                        W.value = W.nodeValue = "" + P,
                            this.setAttributeNode(W)
                    },
                    getAttributeNodeNS: function (b, E) {
                        return this.attributes.getNamedItemNS(b, E)
                    },
                    getElementsByTagName: function (b) {
                        return new ke(this, function (E) {
                            var P = [];
                            return Vi(E, function (W) {
                                W !== E && W.nodeType == D && (b === "*" || W.tagName == b) && P.push(W)
                            }),
                                P
                        }
                        )
                    },
                    getElementsByTagNameNS: function (b, E) {
                        return new ke(this, function (P) {
                            var W = [];
                            return Vi(P, function (ne) {
                                ne !== P && ne.nodeType === D && (b === "*" || ne.namespaceURI === b) && (E === "*" || ne.localName == E) && W.push(ne)
                            }),
                                W
                        }
                        )
                    }
                },
                    Ze.prototype.getElementsByTagName = xi.prototype.getElementsByTagName,
                    Ze.prototype.getElementsByTagNameNS = xi.prototype.getElementsByTagNameNS,
                    v(xi, Pe);
                function ia() { }
                ia.prototype.nodeType = _,
                    v(ia, Pe);
                function Vr() { }
                Vr.prototype = {
                    data: "",
                    substringData: function (b, E) {
                        return this.data.substring(b, b + E)
                    },
                    appendData: function (b) {
                        b = this.data + b,
                            this.nodeValue = this.data = b,
                            this.length = b.length
                    },
                    insertData: function (b, E) {
                        this.replaceData(b, 0, E)
                    },
                    appendChild: function (b) {
                        throw new Error(ee[w])
                    },
                    deleteData: function (b, E) {
                        this.replaceData(b, E, "")
                    },
                    replaceData: function (b, E, P) {
                        var W = this.data.substring(0, b)
                            , ne = this.data.substring(b + E);
                        P = W + P + ne,
                            this.nodeValue = this.data = P,
                            this.length = P.length
                    }
                },
                    v(Vr, Pe);
                function yo() { }
                yo.prototype = {
                    nodeName: "#text",
                    nodeType: L,
                    splitText: function (b) {
                        var E = this.data
                            , P = E.substring(b);
                        E = E.substring(0, b),
                            this.data = this.nodeValue = E,
                            this.length = E.length;
                        var W = this.ownerDocument.createTextNode(P);
                        return this.parentNode && this.parentNode.insertBefore(W, this.nextSibling),
                            W
                    }
                },
                    v(yo, Vr);
                function _o() { }
                _o.prototype = {
                    nodeName: "#comment",
                    nodeType: z
                },
                    v(_o, Vr);
                function To() { }
                To.prototype = {
                    nodeName: "#cdata-section",
                    nodeType: M
                },
                    v(To, Vr);
                function sa() { }
                sa.prototype.nodeType = F,
                    v(sa, Pe);
                function Lu() { }
                Lu.prototype.nodeType = ue,
                    v(Lu, Pe);
                function Ou() { }
                Ou.prototype.nodeType = x,
                    v(Ou, Pe);
                function bo() { }
                bo.prototype.nodeType = N,
                    v(bo, Pe);
                function ra() { }
                ra.prototype.nodeName = "#document-fragment",
                    ra.prototype.nodeType = Y,
                    v(ra, Pe);
                function Eo() { }
                Eo.prototype.nodeType = B,
                    v(Eo, Pe);
                function So() { }
                So.prototype.serializeToString = function (b, E, P) {
                    return Mu.call(b, E, P)
                }
                    ,
                    Pe.prototype.toString = Mu;
                function Mu(b, E) {
                    var P = []
                        , W = this.nodeType == 9 && this.documentElement || this
                        , ne = W.prefix
                        , Se = W.namespaceURI;
                    if (Se && ne == null) {
                        var ne = W.lookupPrefix(Se);
                        if (ne == null)
                            var be = [{
                                namespace: Se,
                                prefix: null
                            }]
                    }
                    return cr(this, P, b, E, be),
                        P.join("")
                }
                function Ru(b, E, P) {
                    var W = b.prefix || ""
                        , ne = b.namespaceURI;
                    if (!ne || W === "xml" && ne === r.XML || ne === r.XMLNS)
                        return !1;
                    for (var Se = P.length; Se--;) {
                        var be = P[Se];
                        if (be.prefix === W)
                            return be.namespace !== ne
                    }
                    return !0
                }
                function Co(b, E, P) {
                    b.push(" ", E, '="', P.replace(/[<>&"\t\n\r]/g, vt), '"')
                }
                function cr(b, E, P, W, ne) {
                    if (ne || (ne = []),
                        W)
                        if (b = W(b),
                            b) {
                            if (typeof b == "string") {
                                E.push(b);
                                return
                            }
                        } else
                            return;
                    switch (b.nodeType) {
                        case D:
                            var Se = b.attributes
                                , be = Se.length
                                , yt = b.firstChild
                                , Dt = b.tagName;
                            P = r.isHTML(b.namespaceURI) || P;
                            var ai = Dt;
                            if (!P && !b.prefix && b.namespaceURI) {
                                for (var Bt, zi = 0; zi < Se.length; zi++)
                                    if (Se.item(zi).name === "xmlns") {
                                        Bt = Se.item(zi).value;
                                        break
                                    }
                                if (!Bt)
                                    for (var Qt = ne.length - 1; Qt >= 0; Qt--) {
                                        var Oe = ne[Qt];
                                        if (Oe.prefix === "" && Oe.namespace === b.namespaceURI) {
                                            Bt = Oe.namespace;
                                            break
                                        }
                                    }
                                if (Bt !== b.namespaceURI)
                                    for (var Qt = ne.length - 1; Qt >= 0; Qt--) {
                                        var Oe = ne[Qt];
                                        if (Oe.namespace === b.namespaceURI) {
                                            Oe.prefix && (ai = Oe.prefix + ":" + Dt);
                                            break
                                        }
                                    }
                            }
                            E.push("<", ai);
                            for (var gs = 0; gs < be; gs++) {
                                var Jt = Se.item(gs);
                                Jt.prefix == "xmlns" ? ne.push({
                                    prefix: Jt.localName,
                                    namespace: Jt.value
                                }) : Jt.nodeName == "xmlns" && ne.push({
                                    prefix: "",
                                    namespace: Jt.value
                                })
                            }
                            for (var gs = 0; gs < be; gs++) {
                                var Jt = Se.item(gs);
                                if (Ru(Jt, P, ne)) {
                                    var Us = Jt.prefix || ""
                                        , zr = Jt.namespaceURI;
                                    Co(E, Us ? "xmlns:" + Us : "xmlns", zr),
                                        ne.push({
                                            prefix: Us,
                                            namespace: zr
                                        })
                                }
                                cr(Jt, E, P, W, ne)
                            }
                            if (Dt === ai && Ru(b, P, ne)) {
                                var Us = b.prefix || ""
                                    , zr = b.namespaceURI;
                                Co(E, Us ? "xmlns:" + Us : "xmlns", zr),
                                    ne.push({
                                        prefix: Us,
                                        namespace: zr
                                    })
                            }
                            if (yt || P && !/^(?:meta|link|img|br|hr|input)$/i.test(Dt)) {
                                if (E.push(">"),
                                    P && /^script$/i.test(Dt))
                                    for (; yt;)
                                        yt.data ? E.push(yt.data) : cr(yt, E, P, W, ne.slice()),
                                            yt = yt.nextSibling;
                                else
                                    for (; yt;)
                                        cr(yt, E, P, W, ne.slice()),
                                            yt = yt.nextSibling;
                                E.push("</", ai, ">")
                            } else
                                E.push("/>");
                            return;
                        case R:
                        case Y:
                            for (var yt = b.firstChild; yt;)
                                cr(yt, E, P, W, ne.slice()),
                                    yt = yt.nextSibling;
                            return;
                        case _:
                            return Co(E, b.name, b.value);
                        case L:
                            return E.push(b.data.replace(/[<&>]/g, vt));
                        case M:
                            return E.push("<![CDATA[", b.data, "]]>");
                        case z:
                            return E.push("<!--", b.data, "-->");
                        case F:
                            var Ao = b.publicId
                                , vs = b.systemId;
                            if (E.push("<!DOCTYPE ", b.name),
                                Ao)
                                E.push(" PUBLIC ", Ao),
                                    vs && vs != "." && E.push(" ", vs),
                                    E.push(">");
                            else if (vs && vs != ".")
                                E.push(" SYSTEM ", vs, ">");
                            else {
                                var la = b.internalSubset;
                                la && E.push(" [", la, "]"),
                                    E.push(">")
                            }
                            return;
                        case B:
                            return E.push("<?", b.target, " ", b.data, "?>");
                        case N:
                            return E.push("&", b.nodeName, ";");
                        default:
                            E.push("??", b.nodeName)
                    }
                }
                function Nu(b, E, P) {
                    var W;
                    switch (E.nodeType) {
                        case D:
                            W = E.cloneNode(!1),
                                W.ownerDocument = b;
                        case Y:
                            break;
                        case _:
                            P = !0;
                            break
                    }
                    if (W || (W = E.cloneNode(!1)),
                        W.ownerDocument = b,
                        W.parentNode = null,
                        P)
                        for (var ne = E.firstChild; ne;)
                            W.appendChild(Nu(b, ne, P)),
                                ne = ne.nextSibling;
                    return W
                }
                function na(b, E, P) {
                    var W = new E.constructor;
                    for (var ne in E)
                        if (Object.prototype.hasOwnProperty.call(E, ne)) {
                            var Se = E[ne];
                            typeof Se != "object" && Se != W[ne] && (W[ne] = Se)
                        }
                    switch (E.childNodes && (W.childNodes = new Ce),
                    W.ownerDocument = b,
                    W.nodeType) {
                        case D:
                            var be = E.attributes
                                , Dt = W.attributes = new qe
                                , ai = be.length;
                            Dt._ownerElement = W;
                            for (var Bt = 0; Bt < ai; Bt++)
                                W.setAttributeNode(na(b, be.item(Bt), !0));
                            break;
                        case _:
                            P = !0
                    }
                    if (P)
                        for (var zi = E.firstChild; zi;)
                            W.appendChild(na(b, zi, P)),
                                zi = zi.nextSibling;
                    return W
                }
                function aa(b, E, P) {
                    b[E] = P
                }
                try {
                    if (Object.defineProperty) {
                        let b = function (E) {
                            switch (E.nodeType) {
                                case D:
                                case Y:
                                    var P = [];
                                    for (E = E.firstChild; E;)
                                        E.nodeType !== 7 && E.nodeType !== 8 && P.push(b(E)),
                                            E = E.nextSibling;
                                    return P.join("");
                                default:
                                    return E.nodeValue
                            }
                        };
                        oa = b,
                            Object.defineProperty(ke.prototype, "length", {
                                get: function () {
                                    return At(this),
                                        this.$$length
                                }
                            }),
                            Object.defineProperty(Pe.prototype, "textContent", {
                                get: function () {
                                    return b(this)
                                },
                                set: function (E) {
                                    switch (this.nodeType) {
                                        case D:
                                        case Y:
                                            for (; this.firstChild;)
                                                this.removeChild(this.firstChild);
                                            (E || String(E)) && this.appendChild(this.ownerDocument.createTextNode(E));
                                            break;
                                        default:
                                            this.data = E,
                                                this.value = E,
                                                this.nodeValue = E
                                    }
                                }
                            }),
                            aa = function (E, P, W) {
                                E["$$" + P] = W
                            }
                    }
                } catch (b) { }
                var oa;
                t.DocumentType = sa,
                    t.DOMException = ge,
                    t.DOMImplementation = Fs,
                    t.Element = xi,
                    t.Node = Pe,
                    t.NodeList = Ce,
                    t.XMLSerializer = So
            }
        })
        , My = Ke({
            "node_modules/@xmldom/xmldom/lib/entities.js"(t) {
                "use strict";
                var e = Uo().freeze;
                t.XML_ENTITIES = e({
                    amp: "&",
                    apos: "'",
                    gt: ">",
                    lt: "<",
                    quot: '"'
                }),
                    t.HTML_ENTITIES = e({
                        Aacute: "\xC1",
                        aacute: "\xE1",
                        Abreve: "\u0102",
                        abreve: "\u0103",
                        ac: "\u223E",
                        acd: "\u223F",
                        acE: "\u223E\u0333",
                        Acirc: "\xC2",
                        acirc: "\xE2",
                        acute: "\xB4",
                        Acy: "\u0410",
                        acy: "\u0430",
                        AElig: "\xC6",
                        aelig: "\xE6",
                        af: "\u2061",
                        Afr: "\u{1D504}",
                        afr: "\u{1D51E}",
                        Agrave: "\xC0",
                        agrave: "\xE0",
                        alefsym: "\u2135",
                        aleph: "\u2135",
                        Alpha: "\u0391",
                        alpha: "\u03B1",
                        Amacr: "\u0100",
                        amacr: "\u0101",
                        amalg: "\u2A3F",
                        AMP: "&",
                        amp: "&",
                        And: "\u2A53",
                        and: "\u2227",
                        andand: "\u2A55",
                        andd: "\u2A5C",
                        andslope: "\u2A58",
                        andv: "\u2A5A",
                        ang: "\u2220",
                        ange: "\u29A4",
                        angle: "\u2220",
                        angmsd: "\u2221",
                        angmsdaa: "\u29A8",
                        angmsdab: "\u29A9",
                        angmsdac: "\u29AA",
                        angmsdad: "\u29AB",
                        angmsdae: "\u29AC",
                        angmsdaf: "\u29AD",
                        angmsdag: "\u29AE",
                        angmsdah: "\u29AF",
                        angrt: "\u221F",
                        angrtvb: "\u22BE",
                        angrtvbd: "\u299D",
                        angsph: "\u2222",
                        angst: "\xC5",
                        angzarr: "\u237C",
                        Aogon: "\u0104",
                        aogon: "\u0105",
                        Aopf: "\u{1D538}",
                        aopf: "\u{1D552}",
                        ap: "\u2248",
                        apacir: "\u2A6F",
                        apE: "\u2A70",
                        ape: "\u224A",
                        apid: "\u224B",
                        apos: "'",
                        ApplyFunction: "\u2061",
                        approx: "\u2248",
                        approxeq: "\u224A",
                        Aring: "\xC5",
                        aring: "\xE5",
                        Ascr: "\u{1D49C}",
                        ascr: "\u{1D4B6}",
                        Assign: "\u2254",
                        ast: "*",
                        asymp: "\u2248",
                        asympeq: "\u224D",
                        Atilde: "\xC3",
                        atilde: "\xE3",
                        Auml: "\xC4",
                        auml: "\xE4",
                        awconint: "\u2233",
                        awint: "\u2A11",
                        backcong: "\u224C",
                        backepsilon: "\u03F6",
                        backprime: "\u2035",
                        backsim: "\u223D",
                        backsimeq: "\u22CD",
                        Backslash: "\u2216",
                        Barv: "\u2AE7",
                        barvee: "\u22BD",
                        Barwed: "\u2306",
                        barwed: "\u2305",
                        barwedge: "\u2305",
                        bbrk: "\u23B5",
                        bbrktbrk: "\u23B6",
                        bcong: "\u224C",
                        Bcy: "\u0411",
                        bcy: "\u0431",
                        bdquo: "\u201E",
                        becaus: "\u2235",
                        Because: "\u2235",
                        because: "\u2235",
                        bemptyv: "\u29B0",
                        bepsi: "\u03F6",
                        bernou: "\u212C",
                        Bernoullis: "\u212C",
                        Beta: "\u0392",
                        beta: "\u03B2",
                        beth: "\u2136",
                        between: "\u226C",
                        Bfr: "\u{1D505}",
                        bfr: "\u{1D51F}",
                        bigcap: "\u22C2",
                        bigcirc: "\u25EF",
                        bigcup: "\u22C3",
                        bigodot: "\u2A00",
                        bigoplus: "\u2A01",
                        bigotimes: "\u2A02",
                        bigsqcup: "\u2A06",
                        bigstar: "\u2605",
                        bigtriangledown: "\u25BD",
                        bigtriangleup: "\u25B3",
                        biguplus: "\u2A04",
                        bigvee: "\u22C1",
                        bigwedge: "\u22C0",
                        bkarow: "\u290D",
                        blacklozenge: "\u29EB",
                        blacksquare: "\u25AA",
                        blacktriangle: "\u25B4",
                        blacktriangledown: "\u25BE",
                        blacktriangleleft: "\u25C2",
                        blacktriangleright: "\u25B8",
                        blank: "\u2423",
                        blk12: "\u2592",
                        blk14: "\u2591",
                        blk34: "\u2593",
                        block: "\u2588",
                        bne: "=\u20E5",
                        bnequiv: "\u2261\u20E5",
                        bNot: "\u2AED",
                        bnot: "\u2310",
                        Bopf: "\u{1D539}",
                        bopf: "\u{1D553}",
                        bot: "\u22A5",
                        bottom: "\u22A5",
                        bowtie: "\u22C8",
                        boxbox: "\u29C9",
                        boxDL: "\u2557",
                        boxDl: "\u2556",
                        boxdL: "\u2555",
                        boxdl: "\u2510",
                        boxDR: "\u2554",
                        boxDr: "\u2553",
                        boxdR: "\u2552",
                        boxdr: "\u250C",
                        boxH: "\u2550",
                        boxh: "\u2500",
                        boxHD: "\u2566",
                        boxHd: "\u2564",
                        boxhD: "\u2565",
                        boxhd: "\u252C",
                        boxHU: "\u2569",
                        boxHu: "\u2567",
                        boxhU: "\u2568",
                        boxhu: "\u2534",
                        boxminus: "\u229F",
                        boxplus: "\u229E",
                        boxtimes: "\u22A0",
                        boxUL: "\u255D",
                        boxUl: "\u255C",
                        boxuL: "\u255B",
                        boxul: "\u2518",
                        boxUR: "\u255A",
                        boxUr: "\u2559",
                        boxuR: "\u2558",
                        boxur: "\u2514",
                        boxV: "\u2551",
                        boxv: "\u2502",
                        boxVH: "\u256C",
                        boxVh: "\u256B",
                        boxvH: "\u256A",
                        boxvh: "\u253C",
                        boxVL: "\u2563",
                        boxVl: "\u2562",
                        boxvL: "\u2561",
                        boxvl: "\u2524",
                        boxVR: "\u2560",
                        boxVr: "\u255F",
                        boxvR: "\u255E",
                        boxvr: "\u251C",
                        bprime: "\u2035",
                        Breve: "\u02D8",
                        breve: "\u02D8",
                        brvbar: "\xA6",
                        Bscr: "\u212C",
                        bscr: "\u{1D4B7}",
                        bsemi: "\u204F",
                        bsim: "\u223D",
                        bsime: "\u22CD",
                        bsol: "\\",
                        bsolb: "\u29C5",
                        bsolhsub: "\u27C8",
                        bull: "\u2022",
                        bullet: "\u2022",
                        bump: "\u224E",
                        bumpE: "\u2AAE",
                        bumpe: "\u224F",
                        Bumpeq: "\u224E",
                        bumpeq: "\u224F",
                        Cacute: "\u0106",
                        cacute: "\u0107",
                        Cap: "\u22D2",
                        cap: "\u2229",
                        capand: "\u2A44",
                        capbrcup: "\u2A49",
                        capcap: "\u2A4B",
                        capcup: "\u2A47",
                        capdot: "\u2A40",
                        CapitalDifferentialD: "\u2145",
                        caps: "\u2229\uFE00",
                        caret: "\u2041",
                        caron: "\u02C7",
                        Cayleys: "\u212D",
                        ccaps: "\u2A4D",
                        Ccaron: "\u010C",
                        ccaron: "\u010D",
                        Ccedil: "\xC7",
                        ccedil: "\xE7",
                        Ccirc: "\u0108",
                        ccirc: "\u0109",
                        Cconint: "\u2230",
                        ccups: "\u2A4C",
                        ccupssm: "\u2A50",
                        Cdot: "\u010A",
                        cdot: "\u010B",
                        cedil: "\xB8",
                        Cedilla: "\xB8",
                        cemptyv: "\u29B2",
                        cent: "\xA2",
                        CenterDot: "\xB7",
                        centerdot: "\xB7",
                        Cfr: "\u212D",
                        cfr: "\u{1D520}",
                        CHcy: "\u0427",
                        chcy: "\u0447",
                        check: "\u2713",
                        checkmark: "\u2713",
                        Chi: "\u03A7",
                        chi: "\u03C7",
                        cir: "\u25CB",
                        circ: "\u02C6",
                        circeq: "\u2257",
                        circlearrowleft: "\u21BA",
                        circlearrowright: "\u21BB",
                        circledast: "\u229B",
                        circledcirc: "\u229A",
                        circleddash: "\u229D",
                        CircleDot: "\u2299",
                        circledR: "\xAE",
                        circledS: "\u24C8",
                        CircleMinus: "\u2296",
                        CirclePlus: "\u2295",
                        CircleTimes: "\u2297",
                        cirE: "\u29C3",
                        cire: "\u2257",
                        cirfnint: "\u2A10",
                        cirmid: "\u2AEF",
                        cirscir: "\u29C2",
                        ClockwiseContourIntegral: "\u2232",
                        CloseCurlyDoubleQuote: "\u201D",
                        CloseCurlyQuote: "\u2019",
                        clubs: "\u2663",
                        clubsuit: "\u2663",
                        Colon: "\u2237",
                        colon: ":",
                        Colone: "\u2A74",
                        colone: "\u2254",
                        coloneq: "\u2254",
                        comma: ",",
                        commat: "@",
                        comp: "\u2201",
                        compfn: "\u2218",
                        complement: "\u2201",
                        complexes: "\u2102",
                        cong: "\u2245",
                        congdot: "\u2A6D",
                        Congruent: "\u2261",
                        Conint: "\u222F",
                        conint: "\u222E",
                        ContourIntegral: "\u222E",
                        Copf: "\u2102",
                        copf: "\u{1D554}",
                        coprod: "\u2210",
                        Coproduct: "\u2210",
                        COPY: "\xA9",
                        copy: "\xA9",
                        copysr: "\u2117",
                        CounterClockwiseContourIntegral: "\u2233",
                        crarr: "\u21B5",
                        Cross: "\u2A2F",
                        cross: "\u2717",
                        Cscr: "\u{1D49E}",
                        cscr: "\u{1D4B8}",
                        csub: "\u2ACF",
                        csube: "\u2AD1",
                        csup: "\u2AD0",
                        csupe: "\u2AD2",
                        ctdot: "\u22EF",
                        cudarrl: "\u2938",
                        cudarrr: "\u2935",
                        cuepr: "\u22DE",
                        cuesc: "\u22DF",
                        cularr: "\u21B6",
                        cularrp: "\u293D",
                        Cup: "\u22D3",
                        cup: "\u222A",
                        cupbrcap: "\u2A48",
                        CupCap: "\u224D",
                        cupcap: "\u2A46",
                        cupcup: "\u2A4A",
                        cupdot: "\u228D",
                        cupor: "\u2A45",
                        cups: "\u222A\uFE00",
                        curarr: "\u21B7",
                        curarrm: "\u293C",
                        curlyeqprec: "\u22DE",
                        curlyeqsucc: "\u22DF",
                        curlyvee: "\u22CE",
                        curlywedge: "\u22CF",
                        curren: "\xA4",
                        curvearrowleft: "\u21B6",
                        curvearrowright: "\u21B7",
                        cuvee: "\u22CE",
                        cuwed: "\u22CF",
                        cwconint: "\u2232",
                        cwint: "\u2231",
                        cylcty: "\u232D",
                        Dagger: "\u2021",
                        dagger: "\u2020",
                        daleth: "\u2138",
                        Darr: "\u21A1",
                        dArr: "\u21D3",
                        darr: "\u2193",
                        dash: "\u2010",
                        Dashv: "\u2AE4",
                        dashv: "\u22A3",
                        dbkarow: "\u290F",
                        dblac: "\u02DD",
                        Dcaron: "\u010E",
                        dcaron: "\u010F",
                        Dcy: "\u0414",
                        dcy: "\u0434",
                        DD: "\u2145",
                        dd: "\u2146",
                        ddagger: "\u2021",
                        ddarr: "\u21CA",
                        DDotrahd: "\u2911",
                        ddotseq: "\u2A77",
                        deg: "\xB0",
                        Del: "\u2207",
                        Delta: "\u0394",
                        delta: "\u03B4",
                        demptyv: "\u29B1",
                        dfisht: "\u297F",
                        Dfr: "\u{1D507}",
                        dfr: "\u{1D521}",
                        dHar: "\u2965",
                        dharl: "\u21C3",
                        dharr: "\u21C2",
                        DiacriticalAcute: "\xB4",
                        DiacriticalDot: "\u02D9",
                        DiacriticalDoubleAcute: "\u02DD",
                        DiacriticalGrave: "`",
                        DiacriticalTilde: "\u02DC",
                        diam: "\u22C4",
                        Diamond: "\u22C4",
                        diamond: "\u22C4",
                        diamondsuit: "\u2666",
                        diams: "\u2666",
                        die: "\xA8",
                        DifferentialD: "\u2146",
                        digamma: "\u03DD",
                        disin: "\u22F2",
                        div: "\xF7",
                        divide: "\xF7",
                        divideontimes: "\u22C7",
                        divonx: "\u22C7",
                        DJcy: "\u0402",
                        djcy: "\u0452",
                        dlcorn: "\u231E",
                        dlcrop: "\u230D",
                        dollar: "$",
                        Dopf: "\u{1D53B}",
                        dopf: "\u{1D555}",
                        Dot: "\xA8",
                        dot: "\u02D9",
                        DotDot: "\u20DC",
                        doteq: "\u2250",
                        doteqdot: "\u2251",
                        DotEqual: "\u2250",
                        dotminus: "\u2238",
                        dotplus: "\u2214",
                        dotsquare: "\u22A1",
                        doublebarwedge: "\u2306",
                        DoubleContourIntegral: "\u222F",
                        DoubleDot: "\xA8",
                        DoubleDownArrow: "\u21D3",
                        DoubleLeftArrow: "\u21D0",
                        DoubleLeftRightArrow: "\u21D4",
                        DoubleLeftTee: "\u2AE4",
                        DoubleLongLeftArrow: "\u27F8",
                        DoubleLongLeftRightArrow: "\u27FA",
                        DoubleLongRightArrow: "\u27F9",
                        DoubleRightArrow: "\u21D2",
                        DoubleRightTee: "\u22A8",
                        DoubleUpArrow: "\u21D1",
                        DoubleUpDownArrow: "\u21D5",
                        DoubleVerticalBar: "\u2225",
                        DownArrow: "\u2193",
                        Downarrow: "\u21D3",
                        downarrow: "\u2193",
                        DownArrowBar: "\u2913",
                        DownArrowUpArrow: "\u21F5",
                        DownBreve: "\u0311",
                        downdownarrows: "\u21CA",
                        downharpoonleft: "\u21C3",
                        downharpoonright: "\u21C2",
                        DownLeftRightVector: "\u2950",
                        DownLeftTeeVector: "\u295E",
                        DownLeftVector: "\u21BD",
                        DownLeftVectorBar: "\u2956",
                        DownRightTeeVector: "\u295F",
                        DownRightVector: "\u21C1",
                        DownRightVectorBar: "\u2957",
                        DownTee: "\u22A4",
                        DownTeeArrow: "\u21A7",
                        drbkarow: "\u2910",
                        drcorn: "\u231F",
                        drcrop: "\u230C",
                        Dscr: "\u{1D49F}",
                        dscr: "\u{1D4B9}",
                        DScy: "\u0405",
                        dscy: "\u0455",
                        dsol: "\u29F6",
                        Dstrok: "\u0110",
                        dstrok: "\u0111",
                        dtdot: "\u22F1",
                        dtri: "\u25BF",
                        dtrif: "\u25BE",
                        duarr: "\u21F5",
                        duhar: "\u296F",
                        dwangle: "\u29A6",
                        DZcy: "\u040F",
                        dzcy: "\u045F",
                        dzigrarr: "\u27FF",
                        Eacute: "\xC9",
                        eacute: "\xE9",
                        easter: "\u2A6E",
                        Ecaron: "\u011A",
                        ecaron: "\u011B",
                        ecir: "\u2256",
                        Ecirc: "\xCA",
                        ecirc: "\xEA",
                        ecolon: "\u2255",
                        Ecy: "\u042D",
                        ecy: "\u044D",
                        eDDot: "\u2A77",
                        Edot: "\u0116",
                        eDot: "\u2251",
                        edot: "\u0117",
                        ee: "\u2147",
                        efDot: "\u2252",
                        Efr: "\u{1D508}",
                        efr: "\u{1D522}",
                        eg: "\u2A9A",
                        Egrave: "\xC8",
                        egrave: "\xE8",
                        egs: "\u2A96",
                        egsdot: "\u2A98",
                        el: "\u2A99",
                        Element: "\u2208",
                        elinters: "\u23E7",
                        ell: "\u2113",
                        els: "\u2A95",
                        elsdot: "\u2A97",
                        Emacr: "\u0112",
                        emacr: "\u0113",
                        empty: "\u2205",
                        emptyset: "\u2205",
                        EmptySmallSquare: "\u25FB",
                        emptyv: "\u2205",
                        EmptyVerySmallSquare: "\u25AB",
                        emsp: "\u2003",
                        emsp13: "\u2004",
                        emsp14: "\u2005",
                        ENG: "\u014A",
                        eng: "\u014B",
                        ensp: "\u2002",
                        Eogon: "\u0118",
                        eogon: "\u0119",
                        Eopf: "\u{1D53C}",
                        eopf: "\u{1D556}",
                        epar: "\u22D5",
                        eparsl: "\u29E3",
                        eplus: "\u2A71",
                        epsi: "\u03B5",
                        Epsilon: "\u0395",
                        epsilon: "\u03B5",
                        epsiv: "\u03F5",
                        eqcirc: "\u2256",
                        eqcolon: "\u2255",
                        eqsim: "\u2242",
                        eqslantgtr: "\u2A96",
                        eqslantless: "\u2A95",
                        Equal: "\u2A75",
                        equals: "=",
                        EqualTilde: "\u2242",
                        equest: "\u225F",
                        Equilibrium: "\u21CC",
                        equiv: "\u2261",
                        equivDD: "\u2A78",
                        eqvparsl: "\u29E5",
                        erarr: "\u2971",
                        erDot: "\u2253",
                        Escr: "\u2130",
                        escr: "\u212F",
                        esdot: "\u2250",
                        Esim: "\u2A73",
                        esim: "\u2242",
                        Eta: "\u0397",
                        eta: "\u03B7",
                        ETH: "\xD0",
                        eth: "\xF0",
                        Euml: "\xCB",
                        euml: "\xEB",
                        euro: "\u20AC",
                        excl: "!",
                        exist: "\u2203",
                        Exists: "\u2203",
                        expectation: "\u2130",
                        ExponentialE: "\u2147",
                        exponentiale: "\u2147",
                        fallingdotseq: "\u2252",
                        Fcy: "\u0424",
                        fcy: "\u0444",
                        female: "\u2640",
                        ffilig: "\uFB03",
                        fflig: "\uFB00",
                        ffllig: "\uFB04",
                        Ffr: "\u{1D509}",
                        ffr: "\u{1D523}",
                        filig: "\uFB01",
                        FilledSmallSquare: "\u25FC",
                        FilledVerySmallSquare: "\u25AA",
                        fjlig: "fj",
                        flat: "\u266D",
                        fllig: "\uFB02",
                        fltns: "\u25B1",
                        fnof: "\u0192",
                        Fopf: "\u{1D53D}",
                        fopf: "\u{1D557}",
                        ForAll: "\u2200",
                        forall: "\u2200",
                        fork: "\u22D4",
                        forkv: "\u2AD9",
                        Fouriertrf: "\u2131",
                        fpartint: "\u2A0D",
                        frac12: "\xBD",
                        frac13: "\u2153",
                        frac14: "\xBC",
                        frac15: "\u2155",
                        frac16: "\u2159",
                        frac18: "\u215B",
                        frac23: "\u2154",
                        frac25: "\u2156",
                        frac34: "\xBE",
                        frac35: "\u2157",
                        frac38: "\u215C",
                        frac45: "\u2158",
                        frac56: "\u215A",
                        frac58: "\u215D",
                        frac78: "\u215E",
                        frasl: "\u2044",
                        frown: "\u2322",
                        Fscr: "\u2131",
                        fscr: "\u{1D4BB}",
                        gacute: "\u01F5",
                        Gamma: "\u0393",
                        gamma: "\u03B3",
                        Gammad: "\u03DC",
                        gammad: "\u03DD",
                        gap: "\u2A86",
                        Gbreve: "\u011E",
                        gbreve: "\u011F",
                        Gcedil: "\u0122",
                        Gcirc: "\u011C",
                        gcirc: "\u011D",
                        Gcy: "\u0413",
                        gcy: "\u0433",
                        Gdot: "\u0120",
                        gdot: "\u0121",
                        gE: "\u2267",
                        ge: "\u2265",
                        gEl: "\u2A8C",
                        gel: "\u22DB",
                        geq: "\u2265",
                        geqq: "\u2267",
                        geqslant: "\u2A7E",
                        ges: "\u2A7E",
                        gescc: "\u2AA9",
                        gesdot: "\u2A80",
                        gesdoto: "\u2A82",
                        gesdotol: "\u2A84",
                        gesl: "\u22DB\uFE00",
                        gesles: "\u2A94",
                        Gfr: "\u{1D50A}",
                        gfr: "\u{1D524}",
                        Gg: "\u22D9",
                        gg: "\u226B",
                        ggg: "\u22D9",
                        gimel: "\u2137",
                        GJcy: "\u0403",
                        gjcy: "\u0453",
                        gl: "\u2277",
                        gla: "\u2AA5",
                        glE: "\u2A92",
                        glj: "\u2AA4",
                        gnap: "\u2A8A",
                        gnapprox: "\u2A8A",
                        gnE: "\u2269",
                        gne: "\u2A88",
                        gneq: "\u2A88",
                        gneqq: "\u2269",
                        gnsim: "\u22E7",
                        Gopf: "\u{1D53E}",
                        gopf: "\u{1D558}",
                        grave: "`",
                        GreaterEqual: "\u2265",
                        GreaterEqualLess: "\u22DB",
                        GreaterFullEqual: "\u2267",
                        GreaterGreater: "\u2AA2",
                        GreaterLess: "\u2277",
                        GreaterSlantEqual: "\u2A7E",
                        GreaterTilde: "\u2273",
                        Gscr: "\u{1D4A2}",
                        gscr: "\u210A",
                        gsim: "\u2273",
                        gsime: "\u2A8E",
                        gsiml: "\u2A90",
                        Gt: "\u226B",
                        GT: ">",
                        gt: ">",
                        gtcc: "\u2AA7",
                        gtcir: "\u2A7A",
                        gtdot: "\u22D7",
                        gtlPar: "\u2995",
                        gtquest: "\u2A7C",
                        gtrapprox: "\u2A86",
                        gtrarr: "\u2978",
                        gtrdot: "\u22D7",
                        gtreqless: "\u22DB",
                        gtreqqless: "\u2A8C",
                        gtrless: "\u2277",
                        gtrsim: "\u2273",
                        gvertneqq: "\u2269\uFE00",
                        gvnE: "\u2269\uFE00",
                        Hacek: "\u02C7",
                        hairsp: "\u200A",
                        half: "\xBD",
                        hamilt: "\u210B",
                        HARDcy: "\u042A",
                        hardcy: "\u044A",
                        hArr: "\u21D4",
                        harr: "\u2194",
                        harrcir: "\u2948",
                        harrw: "\u21AD",
                        Hat: "^",
                        hbar: "\u210F",
                        Hcirc: "\u0124",
                        hcirc: "\u0125",
                        hearts: "\u2665",
                        heartsuit: "\u2665",
                        hellip: "\u2026",
                        hercon: "\u22B9",
                        Hfr: "\u210C",
                        hfr: "\u{1D525}",
                        HilbertSpace: "\u210B",
                        hksearow: "\u2925",
                        hkswarow: "\u2926",
                        hoarr: "\u21FF",
                        homtht: "\u223B",
                        hookleftarrow: "\u21A9",
                        hookrightarrow: "\u21AA",
                        Hopf: "\u210D",
                        hopf: "\u{1D559}",
                        horbar: "\u2015",
                        HorizontalLine: "\u2500",
                        Hscr: "\u210B",
                        hscr: "\u{1D4BD}",
                        hslash: "\u210F",
                        Hstrok: "\u0126",
                        hstrok: "\u0127",
                        HumpDownHump: "\u224E",
                        HumpEqual: "\u224F",
                        hybull: "\u2043",
                        hyphen: "\u2010",
                        Iacute: "\xCD",
                        iacute: "\xED",
                        ic: "\u2063",
                        Icirc: "\xCE",
                        icirc: "\xEE",
                        Icy: "\u0418",
                        icy: "\u0438",
                        Idot: "\u0130",
                        IEcy: "\u0415",
                        iecy: "\u0435",
                        iexcl: "\xA1",
                        iff: "\u21D4",
                        Ifr: "\u2111",
                        ifr: "\u{1D526}",
                        Igrave: "\xCC",
                        igrave: "\xEC",
                        ii: "\u2148",
                        iiiint: "\u2A0C",
                        iiint: "\u222D",
                        iinfin: "\u29DC",
                        iiota: "\u2129",
                        IJlig: "\u0132",
                        ijlig: "\u0133",
                        Im: "\u2111",
                        Imacr: "\u012A",
                        imacr: "\u012B",
                        image: "\u2111",
                        ImaginaryI: "\u2148",
                        imagline: "\u2110",
                        imagpart: "\u2111",
                        imath: "\u0131",
                        imof: "\u22B7",
                        imped: "\u01B5",
                        Implies: "\u21D2",
                        in: "\u2208",
                        incare: "\u2105",
                        infin: "\u221E",
                        infintie: "\u29DD",
                        inodot: "\u0131",
                        Int: "\u222C",
                        int: "\u222B",
                        intcal: "\u22BA",
                        integers: "\u2124",
                        Integral: "\u222B",
                        intercal: "\u22BA",
                        Intersection: "\u22C2",
                        intlarhk: "\u2A17",
                        intprod: "\u2A3C",
                        InvisibleComma: "\u2063",
                        InvisibleTimes: "\u2062",
                        IOcy: "\u0401",
                        iocy: "\u0451",
                        Iogon: "\u012E",
                        iogon: "\u012F",
                        Iopf: "\u{1D540}",
                        iopf: "\u{1D55A}",
                        Iota: "\u0399",
                        iota: "\u03B9",
                        iprod: "\u2A3C",
                        iquest: "\xBF",
                        Iscr: "\u2110",
                        iscr: "\u{1D4BE}",
                        isin: "\u2208",
                        isindot: "\u22F5",
                        isinE: "\u22F9",
                        isins: "\u22F4",
                        isinsv: "\u22F3",
                        isinv: "\u2208",
                        it: "\u2062",
                        Itilde: "\u0128",
                        itilde: "\u0129",
                        Iukcy: "\u0406",
                        iukcy: "\u0456",
                        Iuml: "\xCF",
                        iuml: "\xEF",
                        Jcirc: "\u0134",
                        jcirc: "\u0135",
                        Jcy: "\u0419",
                        jcy: "\u0439",
                        Jfr: "\u{1D50D}",
                        jfr: "\u{1D527}",
                        jmath: "\u0237",
                        Jopf: "\u{1D541}",
                        jopf: "\u{1D55B}",
                        Jscr: "\u{1D4A5}",
                        jscr: "\u{1D4BF}",
                        Jsercy: "\u0408",
                        jsercy: "\u0458",
                        Jukcy: "\u0404",
                        jukcy: "\u0454",
                        Kappa: "\u039A",
                        kappa: "\u03BA",
                        kappav: "\u03F0",
                        Kcedil: "\u0136",
                        kcedil: "\u0137",
                        Kcy: "\u041A",
                        kcy: "\u043A",
                        Kfr: "\u{1D50E}",
                        kfr: "\u{1D528}",
                        kgreen: "\u0138",
                        KHcy: "\u0425",
                        khcy: "\u0445",
                        KJcy: "\u040C",
                        kjcy: "\u045C",
                        Kopf: "\u{1D542}",
                        kopf: "\u{1D55C}",
                        Kscr: "\u{1D4A6}",
                        kscr: "\u{1D4C0}",
                        lAarr: "\u21DA",
                        Lacute: "\u0139",
                        lacute: "\u013A",
                        laemptyv: "\u29B4",
                        lagran: "\u2112",
                        Lambda: "\u039B",
                        lambda: "\u03BB",
                        Lang: "\u27EA",
                        lang: "\u27E8",
                        langd: "\u2991",
                        langle: "\u27E8",
                        lap: "\u2A85",
                        Laplacetrf: "\u2112",
                        laquo: "\xAB",
                        Larr: "\u219E",
                        lArr: "\u21D0",
                        larr: "\u2190",
                        larrb: "\u21E4",
                        larrbfs: "\u291F",
                        larrfs: "\u291D",
                        larrhk: "\u21A9",
                        larrlp: "\u21AB",
                        larrpl: "\u2939",
                        larrsim: "\u2973",
                        larrtl: "\u21A2",
                        lat: "\u2AAB",
                        lAtail: "\u291B",
                        latail: "\u2919",
                        late: "\u2AAD",
                        lates: "\u2AAD\uFE00",
                        lBarr: "\u290E",
                        lbarr: "\u290C",
                        lbbrk: "\u2772",
                        lbrace: "{",
                        lbrack: "[",
                        lbrke: "\u298B",
                        lbrksld: "\u298F",
                        lbrkslu: "\u298D",
                        Lcaron: "\u013D",
                        lcaron: "\u013E",
                        Lcedil: "\u013B",
                        lcedil: "\u013C",
                        lceil: "\u2308",
                        lcub: "{",
                        Lcy: "\u041B",
                        lcy: "\u043B",
                        ldca: "\u2936",
                        ldquo: "\u201C",
                        ldquor: "\u201E",
                        ldrdhar: "\u2967",
                        ldrushar: "\u294B",
                        ldsh: "\u21B2",
                        lE: "\u2266",
                        le: "\u2264",
                        LeftAngleBracket: "\u27E8",
                        LeftArrow: "\u2190",
                        Leftarrow: "\u21D0",
                        leftarrow: "\u2190",
                        LeftArrowBar: "\u21E4",
                        LeftArrowRightArrow: "\u21C6",
                        leftarrowtail: "\u21A2",
                        LeftCeiling: "\u2308",
                        LeftDoubleBracket: "\u27E6",
                        LeftDownTeeVector: "\u2961",
                        LeftDownVector: "\u21C3",
                        LeftDownVectorBar: "\u2959",
                        LeftFloor: "\u230A",
                        leftharpoondown: "\u21BD",
                        leftharpoonup: "\u21BC",
                        leftleftarrows: "\u21C7",
                        LeftRightArrow: "\u2194",
                        Leftrightarrow: "\u21D4",
                        leftrightarrow: "\u2194",
                        leftrightarrows: "\u21C6",
                        leftrightharpoons: "\u21CB",
                        leftrightsquigarrow: "\u21AD",
                        LeftRightVector: "\u294E",
                        LeftTee: "\u22A3",
                        LeftTeeArrow: "\u21A4",
                        LeftTeeVector: "\u295A",
                        leftthreetimes: "\u22CB",
                        LeftTriangle: "\u22B2",
                        LeftTriangleBar: "\u29CF",
                        LeftTriangleEqual: "\u22B4",
                        LeftUpDownVector: "\u2951",
                        LeftUpTeeVector: "\u2960",
                        LeftUpVector: "\u21BF",
                        LeftUpVectorBar: "\u2958",
                        LeftVector: "\u21BC",
                        LeftVectorBar: "\u2952",
                        lEg: "\u2A8B",
                        leg: "\u22DA",
                        leq: "\u2264",
                        leqq: "\u2266",
                        leqslant: "\u2A7D",
                        les: "\u2A7D",
                        lescc: "\u2AA8",
                        lesdot: "\u2A7F",
                        lesdoto: "\u2A81",
                        lesdotor: "\u2A83",
                        lesg: "\u22DA\uFE00",
                        lesges: "\u2A93",
                        lessapprox: "\u2A85",
                        lessdot: "\u22D6",
                        lesseqgtr: "\u22DA",
                        lesseqqgtr: "\u2A8B",
                        LessEqualGreater: "\u22DA",
                        LessFullEqual: "\u2266",
                        LessGreater: "\u2276",
                        lessgtr: "\u2276",
                        LessLess: "\u2AA1",
                        lesssim: "\u2272",
                        LessSlantEqual: "\u2A7D",
                        LessTilde: "\u2272",
                        lfisht: "\u297C",
                        lfloor: "\u230A",
                        Lfr: "\u{1D50F}",
                        lfr: "\u{1D529}",
                        lg: "\u2276",
                        lgE: "\u2A91",
                        lHar: "\u2962",
                        lhard: "\u21BD",
                        lharu: "\u21BC",
                        lharul: "\u296A",
                        lhblk: "\u2584",
                        LJcy: "\u0409",
                        ljcy: "\u0459",
                        Ll: "\u22D8",
                        ll: "\u226A",
                        llarr: "\u21C7",
                        llcorner: "\u231E",
                        Lleftarrow: "\u21DA",
                        llhard: "\u296B",
                        lltri: "\u25FA",
                        Lmidot: "\u013F",
                        lmidot: "\u0140",
                        lmoust: "\u23B0",
                        lmoustache: "\u23B0",
                        lnap: "\u2A89",
                        lnapprox: "\u2A89",
                        lnE: "\u2268",
                        lne: "\u2A87",
                        lneq: "\u2A87",
                        lneqq: "\u2268",
                        lnsim: "\u22E6",
                        loang: "\u27EC",
                        loarr: "\u21FD",
                        lobrk: "\u27E6",
                        LongLeftArrow: "\u27F5",
                        Longleftarrow: "\u27F8",
                        longleftarrow: "\u27F5",
                        LongLeftRightArrow: "\u27F7",
                        Longleftrightarrow: "\u27FA",
                        longleftrightarrow: "\u27F7",
                        longmapsto: "\u27FC",
                        LongRightArrow: "\u27F6",
                        Longrightarrow: "\u27F9",
                        longrightarrow: "\u27F6",
                        looparrowleft: "\u21AB",
                        looparrowright: "\u21AC",
                        lopar: "\u2985",
                        Lopf: "\u{1D543}",
                        lopf: "\u{1D55D}",
                        loplus: "\u2A2D",
                        lotimes: "\u2A34",
                        lowast: "\u2217",
                        lowbar: "_",
                        LowerLeftArrow: "\u2199",
                        LowerRightArrow: "\u2198",
                        loz: "\u25CA",
                        lozenge: "\u25CA",
                        lozf: "\u29EB",
                        lpar: "(",
                        lparlt: "\u2993",
                        lrarr: "\u21C6",
                        lrcorner: "\u231F",
                        lrhar: "\u21CB",
                        lrhard: "\u296D",
                        lrm: "\u200E",
                        lrtri: "\u22BF",
                        lsaquo: "\u2039",
                        Lscr: "\u2112",
                        lscr: "\u{1D4C1}",
                        Lsh: "\u21B0",
                        lsh: "\u21B0",
                        lsim: "\u2272",
                        lsime: "\u2A8D",
                        lsimg: "\u2A8F",
                        lsqb: "[",
                        lsquo: "\u2018",
                        lsquor: "\u201A",
                        Lstrok: "\u0141",
                        lstrok: "\u0142",
                        Lt: "\u226A",
                        LT: "<",
                        lt: "<",
                        ltcc: "\u2AA6",
                        ltcir: "\u2A79",
                        ltdot: "\u22D6",
                        lthree: "\u22CB",
                        ltimes: "\u22C9",
                        ltlarr: "\u2976",
                        ltquest: "\u2A7B",
                        ltri: "\u25C3",
                        ltrie: "\u22B4",
                        ltrif: "\u25C2",
                        ltrPar: "\u2996",
                        lurdshar: "\u294A",
                        luruhar: "\u2966",
                        lvertneqq: "\u2268\uFE00",
                        lvnE: "\u2268\uFE00",
                        macr: "\xAF",
                        male: "\u2642",
                        malt: "\u2720",
                        maltese: "\u2720",
                        Map: "\u2905",
                        map: "\u21A6",
                        mapsto: "\u21A6",
                        mapstodown: "\u21A7",
                        mapstoleft: "\u21A4",
                        mapstoup: "\u21A5",
                        marker: "\u25AE",
                        mcomma: "\u2A29",
                        Mcy: "\u041C",
                        mcy: "\u043C",
                        mdash: "\u2014",
                        mDDot: "\u223A",
                        measuredangle: "\u2221",
                        MediumSpace: "\u205F",
                        Mellintrf: "\u2133",
                        Mfr: "\u{1D510}",
                        mfr: "\u{1D52A}",
                        mho: "\u2127",
                        micro: "\xB5",
                        mid: "\u2223",
                        midast: "*",
                        midcir: "\u2AF0",
                        middot: "\xB7",
                        minus: "\u2212",
                        minusb: "\u229F",
                        minusd: "\u2238",
                        minusdu: "\u2A2A",
                        MinusPlus: "\u2213",
                        mlcp: "\u2ADB",
                        mldr: "\u2026",
                        mnplus: "\u2213",
                        models: "\u22A7",
                        Mopf: "\u{1D544}",
                        mopf: "\u{1D55E}",
                        mp: "\u2213",
                        Mscr: "\u2133",
                        mscr: "\u{1D4C2}",
                        mstpos: "\u223E",
                        Mu: "\u039C",
                        mu: "\u03BC",
                        multimap: "\u22B8",
                        mumap: "\u22B8",
                        nabla: "\u2207",
                        Nacute: "\u0143",
                        nacute: "\u0144",
                        nang: "\u2220\u20D2",
                        nap: "\u2249",
                        napE: "\u2A70\u0338",
                        napid: "\u224B\u0338",
                        napos: "\u0149",
                        napprox: "\u2249",
                        natur: "\u266E",
                        natural: "\u266E",
                        naturals: "\u2115",
                        nbsp: "\xA0",
                        nbump: "\u224E\u0338",
                        nbumpe: "\u224F\u0338",
                        ncap: "\u2A43",
                        Ncaron: "\u0147",
                        ncaron: "\u0148",
                        Ncedil: "\u0145",
                        ncedil: "\u0146",
                        ncong: "\u2247",
                        ncongdot: "\u2A6D\u0338",
                        ncup: "\u2A42",
                        Ncy: "\u041D",
                        ncy: "\u043D",
                        ndash: "\u2013",
                        ne: "\u2260",
                        nearhk: "\u2924",
                        neArr: "\u21D7",
                        nearr: "\u2197",
                        nearrow: "\u2197",
                        nedot: "\u2250\u0338",
                        NegativeMediumSpace: "\u200B",
                        NegativeThickSpace: "\u200B",
                        NegativeThinSpace: "\u200B",
                        NegativeVeryThinSpace: "\u200B",
                        nequiv: "\u2262",
                        nesear: "\u2928",
                        nesim: "\u2242\u0338",
                        NestedGreaterGreater: "\u226B",
                        NestedLessLess: "\u226A",
                        NewLine: `
`,
                        nexist: "\u2204",
                        nexists: "\u2204",
                        Nfr: "\u{1D511}",
                        nfr: "\u{1D52B}",
                        ngE: "\u2267\u0338",
                        nge: "\u2271",
                        ngeq: "\u2271",
                        ngeqq: "\u2267\u0338",
                        ngeqslant: "\u2A7E\u0338",
                        nges: "\u2A7E\u0338",
                        nGg: "\u22D9\u0338",
                        ngsim: "\u2275",
                        nGt: "\u226B\u20D2",
                        ngt: "\u226F",
                        ngtr: "\u226F",
                        nGtv: "\u226B\u0338",
                        nhArr: "\u21CE",
                        nharr: "\u21AE",
                        nhpar: "\u2AF2",
                        ni: "\u220B",
                        nis: "\u22FC",
                        nisd: "\u22FA",
                        niv: "\u220B",
                        NJcy: "\u040A",
                        njcy: "\u045A",
                        nlArr: "\u21CD",
                        nlarr: "\u219A",
                        nldr: "\u2025",
                        nlE: "\u2266\u0338",
                        nle: "\u2270",
                        nLeftarrow: "\u21CD",
                        nleftarrow: "\u219A",
                        nLeftrightarrow: "\u21CE",
                        nleftrightarrow: "\u21AE",
                        nleq: "\u2270",
                        nleqq: "\u2266\u0338",
                        nleqslant: "\u2A7D\u0338",
                        nles: "\u2A7D\u0338",
                        nless: "\u226E",
                        nLl: "\u22D8\u0338",
                        nlsim: "\u2274",
                        nLt: "\u226A\u20D2",
                        nlt: "\u226E",
                        nltri: "\u22EA",
                        nltrie: "\u22EC",
                        nLtv: "\u226A\u0338",
                        nmid: "\u2224",
                        NoBreak: "\u2060",
                        NonBreakingSpace: "\xA0",
                        Nopf: "\u2115",
                        nopf: "\u{1D55F}",
                        Not: "\u2AEC",
                        not: "\xAC",
                        NotCongruent: "\u2262",
                        NotCupCap: "\u226D",
                        NotDoubleVerticalBar: "\u2226",
                        NotElement: "\u2209",
                        NotEqual: "\u2260",
                        NotEqualTilde: "\u2242\u0338",
                        NotExists: "\u2204",
                        NotGreater: "\u226F",
                        NotGreaterEqual: "\u2271",
                        NotGreaterFullEqual: "\u2267\u0338",
                        NotGreaterGreater: "\u226B\u0338",
                        NotGreaterLess: "\u2279",
                        NotGreaterSlantEqual: "\u2A7E\u0338",
                        NotGreaterTilde: "\u2275",
                        NotHumpDownHump: "\u224E\u0338",
                        NotHumpEqual: "\u224F\u0338",
                        notin: "\u2209",
                        notindot: "\u22F5\u0338",
                        notinE: "\u22F9\u0338",
                        notinva: "\u2209",
                        notinvb: "\u22F7",
                        notinvc: "\u22F6",
                        NotLeftTriangle: "\u22EA",
                        NotLeftTriangleBar: "\u29CF\u0338",
                        NotLeftTriangleEqual: "\u22EC",
                        NotLess: "\u226E",
                        NotLessEqual: "\u2270",
                        NotLessGreater: "\u2278",
                        NotLessLess: "\u226A\u0338",
                        NotLessSlantEqual: "\u2A7D\u0338",
                        NotLessTilde: "\u2274",
                        NotNestedGreaterGreater: "\u2AA2\u0338",
                        NotNestedLessLess: "\u2AA1\u0338",
                        notni: "\u220C",
                        notniva: "\u220C",
                        notnivb: "\u22FE",
                        notnivc: "\u22FD",
                        NotPrecedes: "\u2280",
                        NotPrecedesEqual: "\u2AAF\u0338",
                        NotPrecedesSlantEqual: "\u22E0",
                        NotReverseElement: "\u220C",
                        NotRightTriangle: "\u22EB",
                        NotRightTriangleBar: "\u29D0\u0338",
                        NotRightTriangleEqual: "\u22ED",
                        NotSquareSubset: "\u228F\u0338",
                        NotSquareSubsetEqual: "\u22E2",
                        NotSquareSuperset: "\u2290\u0338",
                        NotSquareSupersetEqual: "\u22E3",
                        NotSubset: "\u2282\u20D2",
                        NotSubsetEqual: "\u2288",
                        NotSucceeds: "\u2281",
                        NotSucceedsEqual: "\u2AB0\u0338",
                        NotSucceedsSlantEqual: "\u22E1",
                        NotSucceedsTilde: "\u227F\u0338",
                        NotSuperset: "\u2283\u20D2",
                        NotSupersetEqual: "\u2289",
                        NotTilde: "\u2241",
                        NotTildeEqual: "\u2244",
                        NotTildeFullEqual: "\u2247",
                        NotTildeTilde: "\u2249",
                        NotVerticalBar: "\u2224",
                        npar: "\u2226",
                        nparallel: "\u2226",
                        nparsl: "\u2AFD\u20E5",
                        npart: "\u2202\u0338",
                        npolint: "\u2A14",
                        npr: "\u2280",
                        nprcue: "\u22E0",
                        npre: "\u2AAF\u0338",
                        nprec: "\u2280",
                        npreceq: "\u2AAF\u0338",
                        nrArr: "\u21CF",
                        nrarr: "\u219B",
                        nrarrc: "\u2933\u0338",
                        nrarrw: "\u219D\u0338",
                        nRightarrow: "\u21CF",
                        nrightarrow: "\u219B",
                        nrtri: "\u22EB",
                        nrtrie: "\u22ED",
                        nsc: "\u2281",
                        nsccue: "\u22E1",
                        nsce: "\u2AB0\u0338",
                        Nscr: "\u{1D4A9}",
                        nscr: "\u{1D4C3}",
                        nshortmid: "\u2224",
                        nshortparallel: "\u2226",
                        nsim: "\u2241",
                        nsime: "\u2244",
                        nsimeq: "\u2244",
                        nsmid: "\u2224",
                        nspar: "\u2226",
                        nsqsube: "\u22E2",
                        nsqsupe: "\u22E3",
                        nsub: "\u2284",
                        nsubE: "\u2AC5\u0338",
                        nsube: "\u2288",
                        nsubset: "\u2282\u20D2",
                        nsubseteq: "\u2288",
                        nsubseteqq: "\u2AC5\u0338",
                        nsucc: "\u2281",
                        nsucceq: "\u2AB0\u0338",
                        nsup: "\u2285",
                        nsupE: "\u2AC6\u0338",
                        nsupe: "\u2289",
                        nsupset: "\u2283\u20D2",
                        nsupseteq: "\u2289",
                        nsupseteqq: "\u2AC6\u0338",
                        ntgl: "\u2279",
                        Ntilde: "\xD1",
                        ntilde: "\xF1",
                        ntlg: "\u2278",
                        ntriangleleft: "\u22EA",
                        ntrianglelefteq: "\u22EC",
                        ntriangleright: "\u22EB",
                        ntrianglerighteq: "\u22ED",
                        Nu: "\u039D",
                        nu: "\u03BD",
                        num: "#",
                        numero: "\u2116",
                        numsp: "\u2007",
                        nvap: "\u224D\u20D2",
                        nVDash: "\u22AF",
                        nVdash: "\u22AE",
                        nvDash: "\u22AD",
                        nvdash: "\u22AC",
                        nvge: "\u2265\u20D2",
                        nvgt: ">\u20D2",
                        nvHarr: "\u2904",
                        nvinfin: "\u29DE",
                        nvlArr: "\u2902",
                        nvle: "\u2264\u20D2",
                        nvlt: "<\u20D2",
                        nvltrie: "\u22B4\u20D2",
                        nvrArr: "\u2903",
                        nvrtrie: "\u22B5\u20D2",
                        nvsim: "\u223C\u20D2",
                        nwarhk: "\u2923",
                        nwArr: "\u21D6",
                        nwarr: "\u2196",
                        nwarrow: "\u2196",
                        nwnear: "\u2927",
                        Oacute: "\xD3",
                        oacute: "\xF3",
                        oast: "\u229B",
                        ocir: "\u229A",
                        Ocirc: "\xD4",
                        ocirc: "\xF4",
                        Ocy: "\u041E",
                        ocy: "\u043E",
                        odash: "\u229D",
                        Odblac: "\u0150",
                        odblac: "\u0151",
                        odiv: "\u2A38",
                        odot: "\u2299",
                        odsold: "\u29BC",
                        OElig: "\u0152",
                        oelig: "\u0153",
                        ofcir: "\u29BF",
                        Ofr: "\u{1D512}",
                        ofr: "\u{1D52C}",
                        ogon: "\u02DB",
                        Ograve: "\xD2",
                        ograve: "\xF2",
                        ogt: "\u29C1",
                        ohbar: "\u29B5",
                        ohm: "\u03A9",
                        oint: "\u222E",
                        olarr: "\u21BA",
                        olcir: "\u29BE",
                        olcross: "\u29BB",
                        oline: "\u203E",
                        olt: "\u29C0",
                        Omacr: "\u014C",
                        omacr: "\u014D",
                        Omega: "\u03A9",
                        omega: "\u03C9",
                        Omicron: "\u039F",
                        omicron: "\u03BF",
                        omid: "\u29B6",
                        ominus: "\u2296",
                        Oopf: "\u{1D546}",
                        oopf: "\u{1D560}",
                        opar: "\u29B7",
                        OpenCurlyDoubleQuote: "\u201C",
                        OpenCurlyQuote: "\u2018",
                        operp: "\u29B9",
                        oplus: "\u2295",
                        Or: "\u2A54",
                        or: "\u2228",
                        orarr: "\u21BB",
                        ord: "\u2A5D",
                        order: "\u2134",
                        orderof: "\u2134",
                        ordf: "\xAA",
                        ordm: "\xBA",
                        origof: "\u22B6",
                        oror: "\u2A56",
                        orslope: "\u2A57",
                        orv: "\u2A5B",
                        oS: "\u24C8",
                        Oscr: "\u{1D4AA}",
                        oscr: "\u2134",
                        Oslash: "\xD8",
                        oslash: "\xF8",
                        osol: "\u2298",
                        Otilde: "\xD5",
                        otilde: "\xF5",
                        Otimes: "\u2A37",
                        otimes: "\u2297",
                        otimesas: "\u2A36",
                        Ouml: "\xD6",
                        ouml: "\xF6",
                        ovbar: "\u233D",
                        OverBar: "\u203E",
                        OverBrace: "\u23DE",
                        OverBracket: "\u23B4",
                        OverParenthesis: "\u23DC",
                        par: "\u2225",
                        para: "\xB6",
                        parallel: "\u2225",
                        parsim: "\u2AF3",
                        parsl: "\u2AFD",
                        part: "\u2202",
                        PartialD: "\u2202",
                        Pcy: "\u041F",
                        pcy: "\u043F",
                        percnt: "%",
                        period: ".",
                        permil: "\u2030",
                        perp: "\u22A5",
                        pertenk: "\u2031",
                        Pfr: "\u{1D513}",
                        pfr: "\u{1D52D}",
                        Phi: "\u03A6",
                        phi: "\u03C6",
                        phiv: "\u03D5",
                        phmmat: "\u2133",
                        phone: "\u260E",
                        Pi: "\u03A0",
                        pi: "\u03C0",
                        pitchfork: "\u22D4",
                        piv: "\u03D6",
                        planck: "\u210F",
                        planckh: "\u210E",
                        plankv: "\u210F",
                        plus: "+",
                        plusacir: "\u2A23",
                        plusb: "\u229E",
                        pluscir: "\u2A22",
                        plusdo: "\u2214",
                        plusdu: "\u2A25",
                        pluse: "\u2A72",
                        PlusMinus: "\xB1",
                        plusmn: "\xB1",
                        plussim: "\u2A26",
                        plustwo: "\u2A27",
                        pm: "\xB1",
                        Poincareplane: "\u210C",
                        pointint: "\u2A15",
                        Popf: "\u2119",
                        popf: "\u{1D561}",
                        pound: "\xA3",
                        Pr: "\u2ABB",
                        pr: "\u227A",
                        prap: "\u2AB7",
                        prcue: "\u227C",
                        prE: "\u2AB3",
                        pre: "\u2AAF",
                        prec: "\u227A",
                        precapprox: "\u2AB7",
                        preccurlyeq: "\u227C",
                        Precedes: "\u227A",
                        PrecedesEqual: "\u2AAF",
                        PrecedesSlantEqual: "\u227C",
                        PrecedesTilde: "\u227E",
                        preceq: "\u2AAF",
                        precnapprox: "\u2AB9",
                        precneqq: "\u2AB5",
                        precnsim: "\u22E8",
                        precsim: "\u227E",
                        Prime: "\u2033",
                        prime: "\u2032",
                        primes: "\u2119",
                        prnap: "\u2AB9",
                        prnE: "\u2AB5",
                        prnsim: "\u22E8",
                        prod: "\u220F",
                        Product: "\u220F",
                        profalar: "\u232E",
                        profline: "\u2312",
                        profsurf: "\u2313",
                        prop: "\u221D",
                        Proportion: "\u2237",
                        Proportional: "\u221D",
                        propto: "\u221D",
                        prsim: "\u227E",
                        prurel: "\u22B0",
                        Pscr: "\u{1D4AB}",
                        pscr: "\u{1D4C5}",
                        Psi: "\u03A8",
                        psi: "\u03C8",
                        puncsp: "\u2008",
                        Qfr: "\u{1D514}",
                        qfr: "\u{1D52E}",
                        qint: "\u2A0C",
                        Qopf: "\u211A",
                        qopf: "\u{1D562}",
                        qprime: "\u2057",
                        Qscr: "\u{1D4AC}",
                        qscr: "\u{1D4C6}",
                        quaternions: "\u210D",
                        quatint: "\u2A16",
                        quest: "?",
                        questeq: "\u225F",
                        QUOT: '"',
                        quot: '"',
                        rAarr: "\u21DB",
                        race: "\u223D\u0331",
                        Racute: "\u0154",
                        racute: "\u0155",
                        radic: "\u221A",
                        raemptyv: "\u29B3",
                        Rang: "\u27EB",
                        rang: "\u27E9",
                        rangd: "\u2992",
                        range: "\u29A5",
                        rangle: "\u27E9",
                        raquo: "\xBB",
                        Rarr: "\u21A0",
                        rArr: "\u21D2",
                        rarr: "\u2192",
                        rarrap: "\u2975",
                        rarrb: "\u21E5",
                        rarrbfs: "\u2920",
                        rarrc: "\u2933",
                        rarrfs: "\u291E",
                        rarrhk: "\u21AA",
                        rarrlp: "\u21AC",
                        rarrpl: "\u2945",
                        rarrsim: "\u2974",
                        Rarrtl: "\u2916",
                        rarrtl: "\u21A3",
                        rarrw: "\u219D",
                        rAtail: "\u291C",
                        ratail: "\u291A",
                        ratio: "\u2236",
                        rationals: "\u211A",
                        RBarr: "\u2910",
                        rBarr: "\u290F",
                        rbarr: "\u290D",
                        rbbrk: "\u2773",
                        rbrace: "}",
                        rbrack: "]",
                        rbrke: "\u298C",
                        rbrksld: "\u298E",
                        rbrkslu: "\u2990",
                        Rcaron: "\u0158",
                        rcaron: "\u0159",
                        Rcedil: "\u0156",
                        rcedil: "\u0157",
                        rceil: "\u2309",
                        rcub: "}",
                        Rcy: "\u0420",
                        rcy: "\u0440",
                        rdca: "\u2937",
                        rdldhar: "\u2969",
                        rdquo: "\u201D",
                        rdquor: "\u201D",
                        rdsh: "\u21B3",
                        Re: "\u211C",
                        real: "\u211C",
                        realine: "\u211B",
                        realpart: "\u211C",
                        reals: "\u211D",
                        rect: "\u25AD",
                        REG: "\xAE",
                        reg: "\xAE",
                        ReverseElement: "\u220B",
                        ReverseEquilibrium: "\u21CB",
                        ReverseUpEquilibrium: "\u296F",
                        rfisht: "\u297D",
                        rfloor: "\u230B",
                        Rfr: "\u211C",
                        rfr: "\u{1D52F}",
                        rHar: "\u2964",
                        rhard: "\u21C1",
                        rharu: "\u21C0",
                        rharul: "\u296C",
                        Rho: "\u03A1",
                        rho: "\u03C1",
                        rhov: "\u03F1",
                        RightAngleBracket: "\u27E9",
                        RightArrow: "\u2192",
                        Rightarrow: "\u21D2",
                        rightarrow: "\u2192",
                        RightArrowBar: "\u21E5",
                        RightArrowLeftArrow: "\u21C4",
                        rightarrowtail: "\u21A3",
                        RightCeiling: "\u2309",
                        RightDoubleBracket: "\u27E7",
                        RightDownTeeVector: "\u295D",
                        RightDownVector: "\u21C2",
                        RightDownVectorBar: "\u2955",
                        RightFloor: "\u230B",
                        rightharpoondown: "\u21C1",
                        rightharpoonup: "\u21C0",
                        rightleftarrows: "\u21C4",
                        rightleftharpoons: "\u21CC",
                        rightrightarrows: "\u21C9",
                        rightsquigarrow: "\u219D",
                        RightTee: "\u22A2",
                        RightTeeArrow: "\u21A6",
                        RightTeeVector: "\u295B",
                        rightthreetimes: "\u22CC",
                        RightTriangle: "\u22B3",
                        RightTriangleBar: "\u29D0",
                        RightTriangleEqual: "\u22B5",
                        RightUpDownVector: "\u294F",
                        RightUpTeeVector: "\u295C",
                        RightUpVector: "\u21BE",
                        RightUpVectorBar: "\u2954",
                        RightVector: "\u21C0",
                        RightVectorBar: "\u2953",
                        ring: "\u02DA",
                        risingdotseq: "\u2253",
                        rlarr: "\u21C4",
                        rlhar: "\u21CC",
                        rlm: "\u200F",
                        rmoust: "\u23B1",
                        rmoustache: "\u23B1",
                        rnmid: "\u2AEE",
                        roang: "\u27ED",
                        roarr: "\u21FE",
                        robrk: "\u27E7",
                        ropar: "\u2986",
                        Ropf: "\u211D",
                        ropf: "\u{1D563}",
                        roplus: "\u2A2E",
                        rotimes: "\u2A35",
                        RoundImplies: "\u2970",
                        rpar: ")",
                        rpargt: "\u2994",
                        rppolint: "\u2A12",
                        rrarr: "\u21C9",
                        Rrightarrow: "\u21DB",
                        rsaquo: "\u203A",
                        Rscr: "\u211B",
                        rscr: "\u{1D4C7}",
                        Rsh: "\u21B1",
                        rsh: "\u21B1",
                        rsqb: "]",
                        rsquo: "\u2019",
                        rsquor: "\u2019",
                        rthree: "\u22CC",
                        rtimes: "\u22CA",
                        rtri: "\u25B9",
                        rtrie: "\u22B5",
                        rtrif: "\u25B8",
                        rtriltri: "\u29CE",
                        RuleDelayed: "\u29F4",
                        ruluhar: "\u2968",
                        rx: "\u211E",
                        Sacute: "\u015A",
                        sacute: "\u015B",
                        sbquo: "\u201A",
                        Sc: "\u2ABC",
                        sc: "\u227B",
                        scap: "\u2AB8",
                        Scaron: "\u0160",
                        scaron: "\u0161",
                        sccue: "\u227D",
                        scE: "\u2AB4",
                        sce: "\u2AB0",
                        Scedil: "\u015E",
                        scedil: "\u015F",
                        Scirc: "\u015C",
                        scirc: "\u015D",
                        scnap: "\u2ABA",
                        scnE: "\u2AB6",
                        scnsim: "\u22E9",
                        scpolint: "\u2A13",
                        scsim: "\u227F",
                        Scy: "\u0421",
                        scy: "\u0441",
                        sdot: "\u22C5",
                        sdotb: "\u22A1",
                        sdote: "\u2A66",
                        searhk: "\u2925",
                        seArr: "\u21D8",
                        searr: "\u2198",
                        searrow: "\u2198",
                        sect: "\xA7",
                        semi: ";",
                        seswar: "\u2929",
                        setminus: "\u2216",
                        setmn: "\u2216",
                        sext: "\u2736",
                        Sfr: "\u{1D516}",
                        sfr: "\u{1D530}",
                        sfrown: "\u2322",
                        sharp: "\u266F",
                        SHCHcy: "\u0429",
                        shchcy: "\u0449",
                        SHcy: "\u0428",
                        shcy: "\u0448",
                        ShortDownArrow: "\u2193",
                        ShortLeftArrow: "\u2190",
                        shortmid: "\u2223",
                        shortparallel: "\u2225",
                        ShortRightArrow: "\u2192",
                        ShortUpArrow: "\u2191",
                        shy: "\xAD",
                        Sigma: "\u03A3",
                        sigma: "\u03C3",
                        sigmaf: "\u03C2",
                        sigmav: "\u03C2",
                        sim: "\u223C",
                        simdot: "\u2A6A",
                        sime: "\u2243",
                        simeq: "\u2243",
                        simg: "\u2A9E",
                        simgE: "\u2AA0",
                        siml: "\u2A9D",
                        simlE: "\u2A9F",
                        simne: "\u2246",
                        simplus: "\u2A24",
                        simrarr: "\u2972",
                        slarr: "\u2190",
                        SmallCircle: "\u2218",
                        smallsetminus: "\u2216",
                        smashp: "\u2A33",
                        smeparsl: "\u29E4",
                        smid: "\u2223",
                        smile: "\u2323",
                        smt: "\u2AAA",
                        smte: "\u2AAC",
                        smtes: "\u2AAC\uFE00",
                        SOFTcy: "\u042C",
                        softcy: "\u044C",
                        sol: "/",
                        solb: "\u29C4",
                        solbar: "\u233F",
                        Sopf: "\u{1D54A}",
                        sopf: "\u{1D564}",
                        spades: "\u2660",
                        spadesuit: "\u2660",
                        spar: "\u2225",
                        sqcap: "\u2293",
                        sqcaps: "\u2293\uFE00",
                        sqcup: "\u2294",
                        sqcups: "\u2294\uFE00",
                        Sqrt: "\u221A",
                        sqsub: "\u228F",
                        sqsube: "\u2291",
                        sqsubset: "\u228F",
                        sqsubseteq: "\u2291",
                        sqsup: "\u2290",
                        sqsupe: "\u2292",
                        sqsupset: "\u2290",
                        sqsupseteq: "\u2292",
                        squ: "\u25A1",
                        Square: "\u25A1",
                        square: "\u25A1",
                        SquareIntersection: "\u2293",
                        SquareSubset: "\u228F",
                        SquareSubsetEqual: "\u2291",
                        SquareSuperset: "\u2290",
                        SquareSupersetEqual: "\u2292",
                        SquareUnion: "\u2294",
                        squarf: "\u25AA",
                        squf: "\u25AA",
                        srarr: "\u2192",
                        Sscr: "\u{1D4AE}",
                        sscr: "\u{1D4C8}",
                        ssetmn: "\u2216",
                        ssmile: "\u2323",
                        sstarf: "\u22C6",
                        Star: "\u22C6",
                        star: "\u2606",
                        starf: "\u2605",
                        straightepsilon: "\u03F5",
                        straightphi: "\u03D5",
                        strns: "\xAF",
                        Sub: "\u22D0",
                        sub: "\u2282",
                        subdot: "\u2ABD",
                        subE: "\u2AC5",
                        sube: "\u2286",
                        subedot: "\u2AC3",
                        submult: "\u2AC1",
                        subnE: "\u2ACB",
                        subne: "\u228A",
                        subplus: "\u2ABF",
                        subrarr: "\u2979",
                        Subset: "\u22D0",
                        subset: "\u2282",
                        subseteq: "\u2286",
                        subseteqq: "\u2AC5",
                        SubsetEqual: "\u2286",
                        subsetneq: "\u228A",
                        subsetneqq: "\u2ACB",
                        subsim: "\u2AC7",
                        subsub: "\u2AD5",
                        subsup: "\u2AD3",
                        succ: "\u227B",
                        succapprox: "\u2AB8",
                        succcurlyeq: "\u227D",
                        Succeeds: "\u227B",
                        SucceedsEqual: "\u2AB0",
                        SucceedsSlantEqual: "\u227D",
                        SucceedsTilde: "\u227F",
                        succeq: "\u2AB0",
                        succnapprox: "\u2ABA",
                        succneqq: "\u2AB6",
                        succnsim: "\u22E9",
                        succsim: "\u227F",
                        SuchThat: "\u220B",
                        Sum: "\u2211",
                        sum: "\u2211",
                        sung: "\u266A",
                        Sup: "\u22D1",
                        sup: "\u2283",
                        sup1: "\xB9",
                        sup2: "\xB2",
                        sup3: "\xB3",
                        supdot: "\u2ABE",
                        supdsub: "\u2AD8",
                        supE: "\u2AC6",
                        supe: "\u2287",
                        supedot: "\u2AC4",
                        Superset: "\u2283",
                        SupersetEqual: "\u2287",
                        suphsol: "\u27C9",
                        suphsub: "\u2AD7",
                        suplarr: "\u297B",
                        supmult: "\u2AC2",
                        supnE: "\u2ACC",
                        supne: "\u228B",
                        supplus: "\u2AC0",
                        Supset: "\u22D1",
                        supset: "\u2283",
                        supseteq: "\u2287",
                        supseteqq: "\u2AC6",
                        supsetneq: "\u228B",
                        supsetneqq: "\u2ACC",
                        supsim: "\u2AC8",
                        supsub: "\u2AD4",
                        supsup: "\u2AD6",
                        swarhk: "\u2926",
                        swArr: "\u21D9",
                        swarr: "\u2199",
                        swarrow: "\u2199",
                        swnwar: "\u292A",
                        szlig: "\xDF",
                        Tab: "	",
                        target: "\u2316",
                        Tau: "\u03A4",
                        tau: "\u03C4",
                        tbrk: "\u23B4",
                        Tcaron: "\u0164",
                        tcaron: "\u0165",
                        Tcedil: "\u0162",
                        tcedil: "\u0163",
                        Tcy: "\u0422",
                        tcy: "\u0442",
                        tdot: "\u20DB",
                        telrec: "\u2315",
                        Tfr: "\u{1D517}",
                        tfr: "\u{1D531}",
                        there4: "\u2234",
                        Therefore: "\u2234",
                        therefore: "\u2234",
                        Theta: "\u0398",
                        theta: "\u03B8",
                        thetasym: "\u03D1",
                        thetav: "\u03D1",
                        thickapprox: "\u2248",
                        thicksim: "\u223C",
                        ThickSpace: "\u205F\u200A",
                        thinsp: "\u2009",
                        ThinSpace: "\u2009",
                        thkap: "\u2248",
                        thksim: "\u223C",
                        THORN: "\xDE",
                        thorn: "\xFE",
                        Tilde: "\u223C",
                        tilde: "\u02DC",
                        TildeEqual: "\u2243",
                        TildeFullEqual: "\u2245",
                        TildeTilde: "\u2248",
                        times: "\xD7",
                        timesb: "\u22A0",
                        timesbar: "\u2A31",
                        timesd: "\u2A30",
                        tint: "\u222D",
                        toea: "\u2928",
                        top: "\u22A4",
                        topbot: "\u2336",
                        topcir: "\u2AF1",
                        Topf: "\u{1D54B}",
                        topf: "\u{1D565}",
                        topfork: "\u2ADA",
                        tosa: "\u2929",
                        tprime: "\u2034",
                        TRADE: "\u2122",
                        trade: "\u2122",
                        triangle: "\u25B5",
                        triangledown: "\u25BF",
                        triangleleft: "\u25C3",
                        trianglelefteq: "\u22B4",
                        triangleq: "\u225C",
                        triangleright: "\u25B9",
                        trianglerighteq: "\u22B5",
                        tridot: "\u25EC",
                        trie: "\u225C",
                        triminus: "\u2A3A",
                        TripleDot: "\u20DB",
                        triplus: "\u2A39",
                        trisb: "\u29CD",
                        tritime: "\u2A3B",
                        trpezium: "\u23E2",
                        Tscr: "\u{1D4AF}",
                        tscr: "\u{1D4C9}",
                        TScy: "\u0426",
                        tscy: "\u0446",
                        TSHcy: "\u040B",
                        tshcy: "\u045B",
                        Tstrok: "\u0166",
                        tstrok: "\u0167",
                        twixt: "\u226C",
                        twoheadleftarrow: "\u219E",
                        twoheadrightarrow: "\u21A0",
                        Uacute: "\xDA",
                        uacute: "\xFA",
                        Uarr: "\u219F",
                        uArr: "\u21D1",
                        uarr: "\u2191",
                        Uarrocir: "\u2949",
                        Ubrcy: "\u040E",
                        ubrcy: "\u045E",
                        Ubreve: "\u016C",
                        ubreve: "\u016D",
                        Ucirc: "\xDB",
                        ucirc: "\xFB",
                        Ucy: "\u0423",
                        ucy: "\u0443",
                        udarr: "\u21C5",
                        Udblac: "\u0170",
                        udblac: "\u0171",
                        udhar: "\u296E",
                        ufisht: "\u297E",
                        Ufr: "\u{1D518}",
                        ufr: "\u{1D532}",
                        Ugrave: "\xD9",
                        ugrave: "\xF9",
                        uHar: "\u2963",
                        uharl: "\u21BF",
                        uharr: "\u21BE",
                        uhblk: "\u2580",
                        ulcorn: "\u231C",
                        ulcorner: "\u231C",
                        ulcrop: "\u230F",
                        ultri: "\u25F8",
                        Umacr: "\u016A",
                        umacr: "\u016B",
                        uml: "\xA8",
                        UnderBar: "_",
                        UnderBrace: "\u23DF",
                        UnderBracket: "\u23B5",
                        UnderParenthesis: "\u23DD",
                        Union: "\u22C3",
                        UnionPlus: "\u228E",
                        Uogon: "\u0172",
                        uogon: "\u0173",
                        Uopf: "\u{1D54C}",
                        uopf: "\u{1D566}",
                        UpArrow: "\u2191",
                        Uparrow: "\u21D1",
                        uparrow: "\u2191",
                        UpArrowBar: "\u2912",
                        UpArrowDownArrow: "\u21C5",
                        UpDownArrow: "\u2195",
                        Updownarrow: "\u21D5",
                        updownarrow: "\u2195",
                        UpEquilibrium: "\u296E",
                        upharpoonleft: "\u21BF",
                        upharpoonright: "\u21BE",
                        uplus: "\u228E",
                        UpperLeftArrow: "\u2196",
                        UpperRightArrow: "\u2197",
                        Upsi: "\u03D2",
                        upsi: "\u03C5",
                        upsih: "\u03D2",
                        Upsilon: "\u03A5",
                        upsilon: "\u03C5",
                        UpTee: "\u22A5",
                        UpTeeArrow: "\u21A5",
                        upuparrows: "\u21C8",
                        urcorn: "\u231D",
                        urcorner: "\u231D",
                        urcrop: "\u230E",
                        Uring: "\u016E",
                        uring: "\u016F",
                        urtri: "\u25F9",
                        Uscr: "\u{1D4B0}",
                        uscr: "\u{1D4CA}",
                        utdot: "\u22F0",
                        Utilde: "\u0168",
                        utilde: "\u0169",
                        utri: "\u25B5",
                        utrif: "\u25B4",
                        uuarr: "\u21C8",
                        Uuml: "\xDC",
                        uuml: "\xFC",
                        uwangle: "\u29A7",
                        vangrt: "\u299C",
                        varepsilon: "\u03F5",
                        varkappa: "\u03F0",
                        varnothing: "\u2205",
                        varphi: "\u03D5",
                        varpi: "\u03D6",
                        varpropto: "\u221D",
                        vArr: "\u21D5",
                        varr: "\u2195",
                        varrho: "\u03F1",
                        varsigma: "\u03C2",
                        varsubsetneq: "\u228A\uFE00",
                        varsubsetneqq: "\u2ACB\uFE00",
                        varsupsetneq: "\u228B\uFE00",
                        varsupsetneqq: "\u2ACC\uFE00",
                        vartheta: "\u03D1",
                        vartriangleleft: "\u22B2",
                        vartriangleright: "\u22B3",
                        Vbar: "\u2AEB",
                        vBar: "\u2AE8",
                        vBarv: "\u2AE9",
                        Vcy: "\u0412",
                        vcy: "\u0432",
                        VDash: "\u22AB",
                        Vdash: "\u22A9",
                        vDash: "\u22A8",
                        vdash: "\u22A2",
                        Vdashl: "\u2AE6",
                        Vee: "\u22C1",
                        vee: "\u2228",
                        veebar: "\u22BB",
                        veeeq: "\u225A",
                        vellip: "\u22EE",
                        Verbar: "\u2016",
                        verbar: "|",
                        Vert: "\u2016",
                        vert: "|",
                        VerticalBar: "\u2223",
                        VerticalLine: "|",
                        VerticalSeparator: "\u2758",
                        VerticalTilde: "\u2240",
                        VeryThinSpace: "\u200A",
                        Vfr: "\u{1D519}",
                        vfr: "\u{1D533}",
                        vltri: "\u22B2",
                        vnsub: "\u2282\u20D2",
                        vnsup: "\u2283\u20D2",
                        Vopf: "\u{1D54D}",
                        vopf: "\u{1D567}",
                        vprop: "\u221D",
                        vrtri: "\u22B3",
                        Vscr: "\u{1D4B1}",
                        vscr: "\u{1D4CB}",
                        vsubnE: "\u2ACB\uFE00",
                        vsubne: "\u228A\uFE00",
                        vsupnE: "\u2ACC\uFE00",
                        vsupne: "\u228B\uFE00",
                        Vvdash: "\u22AA",
                        vzigzag: "\u299A",
                        Wcirc: "\u0174",
                        wcirc: "\u0175",
                        wedbar: "\u2A5F",
                        Wedge: "\u22C0",
                        wedge: "\u2227",
                        wedgeq: "\u2259",
                        weierp: "\u2118",
                        Wfr: "\u{1D51A}",
                        wfr: "\u{1D534}",
                        Wopf: "\u{1D54E}",
                        wopf: "\u{1D568}",
                        wp: "\u2118",
                        wr: "\u2240",
                        wreath: "\u2240",
                        Wscr: "\u{1D4B2}",
                        wscr: "\u{1D4CC}",
                        xcap: "\u22C2",
                        xcirc: "\u25EF",
                        xcup: "\u22C3",
                        xdtri: "\u25BD",
                        Xfr: "\u{1D51B}",
                        xfr: "\u{1D535}",
                        xhArr: "\u27FA",
                        xharr: "\u27F7",
                        Xi: "\u039E",
                        xi: "\u03BE",
                        xlArr: "\u27F8",
                        xlarr: "\u27F5",
                        xmap: "\u27FC",
                        xnis: "\u22FB",
                        xodot: "\u2A00",
                        Xopf: "\u{1D54F}",
                        xopf: "\u{1D569}",
                        xoplus: "\u2A01",
                        xotime: "\u2A02",
                        xrArr: "\u27F9",
                        xrarr: "\u27F6",
                        Xscr: "\u{1D4B3}",
                        xscr: "\u{1D4CD}",
                        xsqcup: "\u2A06",
                        xuplus: "\u2A04",
                        xutri: "\u25B3",
                        xvee: "\u22C1",
                        xwedge: "\u22C0",
                        Yacute: "\xDD",
                        yacute: "\xFD",
                        YAcy: "\u042F",
                        yacy: "\u044F",
                        Ycirc: "\u0176",
                        ycirc: "\u0177",
                        Ycy: "\u042B",
                        ycy: "\u044B",
                        yen: "\xA5",
                        Yfr: "\u{1D51C}",
                        yfr: "\u{1D536}",
                        YIcy: "\u0407",
                        yicy: "\u0457",
                        Yopf: "\u{1D550}",
                        yopf: "\u{1D56A}",
                        Yscr: "\u{1D4B4}",
                        yscr: "\u{1D4CE}",
                        YUcy: "\u042E",
                        yucy: "\u044E",
                        Yuml: "\u0178",
                        yuml: "\xFF",
                        Zacute: "\u0179",
                        zacute: "\u017A",
                        Zcaron: "\u017D",
                        zcaron: "\u017E",
                        Zcy: "\u0417",
                        zcy: "\u0437",
                        Zdot: "\u017B",
                        zdot: "\u017C",
                        zeetrf: "\u2128",
                        ZeroWidthSpace: "\u200B",
                        Zeta: "\u0396",
                        zeta: "\u03B6",
                        Zfr: "\u2128",
                        zfr: "\u{1D537}",
                        ZHcy: "\u0416",
                        zhcy: "\u0436",
                        zigrarr: "\u21DD",
                        Zopf: "\u2124",
                        zopf: "\u{1D56B}",
                        Zscr: "\u{1D4B5}",
                        zscr: "\u{1D4CF}",
                        zwj: "\u200D",
                        zwnj: "\u200C"
                    }),
                    t.entityMap = t.HTML_ENTITIES
            }
        })
        , Ry = Ke({
            "node_modules/@xmldom/xmldom/lib/sax.js"(t) {
                var e = Uo().NAMESPACE
                    , s = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
                    , r = new RegExp("[\\-\\.0-9" + s.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]")
                    , n = new RegExp("^" + s.source + r.source + "*(?::" + s.source + r.source + "*)?$")
                    , a = 0
                    , o = 1
                    , u = 2
                    , c = 3
                    , f = 4
                    , v = 5
                    , T = 6
                    , D = 7;
                function _(G, A) {
                    this.message = G,
                        this.locator = A,
                        Error.captureStackTrace && Error.captureStackTrace(this, _)
                }
                _.prototype = new Error,
                    _.prototype.name = _.name;
                function L() { }
                L.prototype = {
                    parse: function (G, A, w) {
                        var H = this.domBuilder;
                        H.startDocument(),
                            F(A, A = {}),
                            M(G, A, w, H, this.errorHandler),
                            H.endDocument()
                    }
                };
                function M(G, A, w, H, X) {
                    function Z($e) {
                        if ($e > 65535) {
                            $e -= 65536;
                            var Nt = 55296 + ($e >> 10)
                                , Yt = 56320 + ($e & 1023);
                            return String.fromCharCode(Nt, Yt)
                        } else
                            return String.fromCharCode($e)
                    }
                    function re($e) {
                        var Nt = $e.slice(1, -1);
                        return Object.hasOwnProperty.call(w, Nt) ? w[Nt] : Nt.charAt(0) === "#" ? Z(parseInt(Nt.substr(1).replace("x", "0x"))) : (X.error("entity not found:" + $e),
                            $e)
                    }
                    function he($e) {
                        if ($e > ge) {
                            var Nt = G.substring(ge, $e).replace(/&#?\w+;/g, re);
                            se && oe(ge),
                                H.characters(Nt, 0, $e - ge),
                                ge = $e
                        }
                    }
                    function oe($e, Nt) {
                        for (; $e >= ae && (Nt = ce.exec(G));)
                            ie = Nt.index,
                                ae = ie + Nt[0].length,
                                se.lineNumber++;
                        se.columnNumber = $e - ie + 1
                    }
                    for (var ie = 0, ae = 0, ce = /.*(?:\r\n?|\n)|.*$/g, se = H.locator, ve = [{
                        currentNSMap: A
                    }], Me = {}, ge = 0; ;) {
                        try {
                            var Ce = G.indexOf("<", ge);
                            if (Ce < 0) {
                                if (!G.substr(ge).match(/^\s*$/)) {
                                    var ke = H.doc
                                        , At = ke.createTextNode(G.substr(ge));
                                    ke.appendChild(At),
                                        H.currentElement = At
                                }
                                return
                            }
                            switch (Ce > ge && he(Ce),
                            G.charAt(Ce + 1)) {
                                case "/":
                                    var Ze = G.indexOf(">", Ce + 3)
                                        , qe = G.substring(Ce + 2, Ze).replace(/[ \t\n\r]+$/g, "")
                                        , wt = ve.pop();
                                    Ze < 0 ? (qe = G.substring(Ce + 2).replace(/[\s<].*/, ""),
                                        X.error("end tag name: " + qe + " is not complete:" + wt.tagName),
                                        Ze = Ce + 1 + qe.length) : qe.match(/\s</) && (qe = qe.replace(/[\s<].*/, ""),
                                            X.error("end tag name: " + qe + " maybe not complete"),
                                            Ze = Ce + 1 + qe.length);
                                    var $i = wt.localNSMap
                                        , yi = wt.tagName == qe
                                        , Fs = yi || wt.tagName && wt.tagName.toLowerCase() == qe.toLowerCase();
                                    if (Fs) {
                                        if (H.endElement(wt.uri, wt.localName, qe),
                                            $i)
                                            for (var Pe in $i)
                                                Object.prototype.hasOwnProperty.call($i, Pe) && H.endPrefixMapping(Pe);
                                        yi || X.fatalError("end tag name: " + qe + " is not match the current start tagName:" + wt.tagName)
                                    } else
                                        ve.push(wt);
                                    Ze++;
                                    break;
                                case "?":
                                    se && oe(Ce),
                                        Ze = ue(G, Ce, H);
                                    break;
                                case "!":
                                    se && oe(Ce),
                                        Ze = Y(G, Ce, H, X);
                                    break;
                                default:
                                    se && oe(Ce);
                                    var vt = new de
                                        , Vi = ve[ve.length - 1].currentNSMap
                                        , Ze = x(G, Ce, vt, Vi, re, X)
                                        , _i = vt.length;
                                    if (!vt.closed && R(G, Ze, vt.tagName, Me) && (vt.closed = !0,
                                        w.nbsp || X.warning("unclosed xml attribute")),
                                        se && _i) {
                                        for (var dr = N(se, {}), xe = 0; xe < _i; xe++) {
                                            var Hr = vt[xe];
                                            oe(Hr.offset),
                                                Hr.locator = N(se, {})
                                        }
                                        H.locator = dr,
                                            B(vt, H, Vi) && ve.push(vt),
                                            H.locator = se
                                    } else
                                        B(vt, H, Vi) && ve.push(vt);
                                    e.isHTML(vt.uri) && !vt.closed ? Ze = z(G, Ze, vt.tagName, re, H) : Ze++
                            }
                        } catch ($e) {
                            if ($e instanceof _)
                                throw $e;
                            X.error("element parse error: " + $e),
                                Ze = -1
                        }
                        Ze > ge ? ge = Ze : he(Math.max(Ce, ge) + 1)
                    }
                }
                function N(G, A) {
                    return A.lineNumber = G.lineNumber,
                        A.columnNumber = G.columnNumber,
                        A
                }
                function x(G, A, w, H, X, Z) {
                    function re(ve, Me, ge) {
                        w.attributeNames.hasOwnProperty(ve) && Z.fatalError("Attribute " + ve + " redefined"),
                            w.addValue(ve, Me.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, X), ge)
                    }
                    for (var he, oe, ie = ++A, ae = a; ;) {
                        var ce = G.charAt(ie);
                        switch (ce) {
                            case "=":
                                if (ae === o)
                                    he = G.slice(A, ie),
                                        ae = c;
                                else if (ae === u)
                                    ae = c;
                                else
                                    throw new Error("attribute equal must after attrName");
                                break;
                            case "'":
                            case '"':
                                if (ae === c || ae === o)
                                    if (ae === o && (Z.warning('attribute value must after "="'),
                                        he = G.slice(A, ie)),
                                        A = ie + 1,
                                        ie = G.indexOf(ce, A),
                                        ie > 0)
                                        oe = G.slice(A, ie),
                                            re(he, oe, A - 1),
                                            ae = v;
                                    else
                                        throw new Error("attribute value no end '" + ce + "' match");
                                else if (ae == f)
                                    oe = G.slice(A, ie),
                                        re(he, oe, A),
                                        Z.warning('attribute "' + he + '" missed start quot(' + ce + ")!!"),
                                        A = ie + 1,
                                        ae = v;
                                else
                                    throw new Error('attribute value must after "="');
                                break;
                            case "/":
                                switch (ae) {
                                    case a:
                                        w.setTagName(G.slice(A, ie));
                                    case v:
                                    case T:
                                    case D:
                                        ae = D,
                                            w.closed = !0;
                                    case f:
                                    case o:
                                        break;
                                    case u:
                                        w.closed = !0;
                                        break;
                                    default:
                                        throw new Error("attribute invalid close char('/')")
                                }
                                break;
                            case "":
                                return Z.error("unexpected end of input"),
                                    ae == a && w.setTagName(G.slice(A, ie)),
                                    ie;
                            case ">":
                                switch (ae) {
                                    case a:
                                        w.setTagName(G.slice(A, ie));
                                    case v:
                                    case T:
                                    case D:
                                        break;
                                    case f:
                                    case o:
                                        oe = G.slice(A, ie),
                                            oe.slice(-1) === "/" && (w.closed = !0,
                                                oe = oe.slice(0, -1));
                                    case u:
                                        ae === u && (oe = he),
                                            ae == f ? (Z.warning('attribute "' + oe + '" missed quot(")!'),
                                                re(he, oe, A)) : ((!e.isHTML(H[""]) || !oe.match(/^(?:disabled|checked|selected)$/i)) && Z.warning('attribute "' + oe + '" missed value!! "' + oe + '" instead!!'),
                                                    re(oe, oe, A));
                                        break;
                                    case c:
                                        throw new Error("attribute value missed!!")
                                }
                                return ie;
                            case "\x80":
                                ce = " ";
                            default:
                                if (ce <= " ")
                                    switch (ae) {
                                        case a:
                                            w.setTagName(G.slice(A, ie)),
                                                ae = T;
                                            break;
                                        case o:
                                            he = G.slice(A, ie),
                                                ae = u;
                                            break;
                                        case f:
                                            var oe = G.slice(A, ie);
                                            Z.warning('attribute "' + oe + '" missed quot(")!!'),
                                                re(he, oe, A);
                                        case v:
                                            ae = T;
                                            break
                                    }
                                else
                                    switch (ae) {
                                        case u:
                                            var se = w.tagName;
                                            (!e.isHTML(H[""]) || !he.match(/^(?:disabled|checked|selected)$/i)) && Z.warning('attribute "' + he + '" missed value!! "' + he + '" instead2!!'),
                                                re(he, he, A),
                                                A = ie,
                                                ae = o;
                                            break;
                                        case v:
                                            Z.warning('attribute space is required"' + he + '"!!');
                                        case T:
                                            ae = o,
                                                A = ie;
                                            break;
                                        case c:
                                            ae = f,
                                                A = ie;
                                            break;
                                        case D:
                                            throw new Error("elements closed character '/' and '>' must be connected to")
                                    }
                        }
                        ie++
                    }
                }
                function B(G, A, w) {
                    for (var H = G.tagName, X = null, ce = G.length; ce--;) {
                        var Z = G[ce]
                            , re = Z.qName
                            , he = Z.value
                            , se = re.indexOf(":");
                        if (se > 0)
                            var oe = Z.prefix = re.slice(0, se)
                                , ie = re.slice(se + 1)
                                , ae = oe === "xmlns" && ie;
                        else
                            ie = re,
                                oe = null,
                                ae = re === "xmlns" && "";
                        Z.localName = ie,
                            ae !== !1 && (X == null && (X = {},
                                F(w, w = {})),
                                w[ae] = X[ae] = he,
                                Z.uri = e.XMLNS,
                                A.startPrefixMapping(ae, he))
                    }
                    for (var ce = G.length; ce--;) {
                        Z = G[ce];
                        var oe = Z.prefix;
                        oe && (oe === "xml" && (Z.uri = e.XML),
                            oe !== "xmlns" && (Z.uri = w[oe || ""]))
                    }
                    var se = H.indexOf(":");
                    se > 0 ? (oe = G.prefix = H.slice(0, se),
                        ie = G.localName = H.slice(se + 1)) : (oe = null,
                            ie = G.localName = H);
                    var ve = G.uri = w[oe || ""];
                    if (A.startElement(ve, ie, H, G),
                        G.closed) {
                        if (A.endElement(ve, ie, H),
                            X)
                            for (oe in X)
                                Object.prototype.hasOwnProperty.call(X, oe) && A.endPrefixMapping(oe)
                    } else
                        return G.currentNSMap = w,
                            G.localNSMap = X,
                            !0
                }
                function z(G, A, w, H, X) {
                    if (/^(?:script|textarea)$/i.test(w)) {
                        var Z = G.indexOf("</" + w + ">", A)
                            , re = G.substring(A + 1, Z);
                        if (/[&<]/.test(re))
                            return /^script$/i.test(w) ? (X.characters(re, 0, re.length),
                                Z) : (re = re.replace(/&#?\w+;/g, H),
                                    X.characters(re, 0, re.length),
                                    Z)
                    }
                    return A + 1
                }
                function R(G, A, w, H) {
                    var X = H[w];
                    return X == null && (X = G.lastIndexOf("</" + w + ">"),
                        X < A && (X = G.lastIndexOf("</" + w)),
                        H[w] = X),
                        X < A
                }
                function F(G, A) {
                    for (var w in G)
                        Object.prototype.hasOwnProperty.call(G, w) && (A[w] = G[w])
                }
                function Y(G, A, w, H) {
                    var X = G.charAt(A + 2);
                    switch (X) {
                        case "-":
                            if (G.charAt(A + 3) === "-") {
                                var Z = G.indexOf("-->", A + 4);
                                return Z > A ? (w.comment(G, A + 4, Z - A - 4),
                                    Z + 3) : (H.error("Unclosed comment"),
                                        -1)
                            } else
                                return -1;
                        default:
                            if (G.substr(A + 3, 6) == "CDATA[") {
                                var Z = G.indexOf("]]>", A + 9);
                                return w.startCDATA(),
                                    w.characters(G, A + 9, Z - A - 9),
                                    w.endCDATA(),
                                    Z + 3
                            }
                            var re = ee(G, A)
                                , he = re.length;
                            if (he > 1 && /!doctype/i.test(re[0][0])) {
                                var oe = re[1][0]
                                    , ie = !1
                                    , ae = !1;
                                he > 3 && (/^public$/i.test(re[2][0]) ? (ie = re[3][0],
                                    ae = he > 4 && re[4][0]) : /^system$/i.test(re[2][0]) && (ae = re[3][0]));
                                var ce = re[he - 1];
                                return w.startDTD(oe, ie, ae),
                                    w.endDTD(),
                                    ce.index + ce[0].length
                            }
                    }
                    return -1
                }
                function ue(G, A, w) {
                    var H = G.indexOf("?>", A);
                    if (H) {
                        var X = G.substring(A, H).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
                        if (X) {
                            var Z = X[0].length;
                            return w.processingInstruction(X[1], X[2]),
                                H + 2
                        } else
                            return -1
                    }
                    return -1
                }
                function de() {
                    this.attributeNames = {}
                }
                de.prototype = {
                    setTagName: function (G) {
                        if (!n.test(G))
                            throw new Error("invalid tagName:" + G);
                        this.tagName = G
                    },
                    addValue: function (G, A, w) {
                        if (!n.test(G))
                            throw new Error("invalid attribute:" + G);
                        this.attributeNames[G] = this.length,
                            this[this.length++] = {
                                qName: G,
                                value: A,
                                offset: w
                            }
                    },
                    length: 0,
                    getLocalName: function (G) {
                        return this[G].localName
                    },
                    getLocator: function (G) {
                        return this[G].locator
                    },
                    getQName: function (G) {
                        return this[G].qName
                    },
                    getURI: function (G) {
                        return this[G].uri
                    },
                    getValue: function (G) {
                        return this[G].value
                    }
                };
                function ee(G, A) {
                    var w, H = [], X = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
                    for (X.lastIndex = A,
                        X.exec(G); w = X.exec(G);)
                        if (H.push(w),
                            w[1])
                            return H
                }
                t.XMLReader = L,
                    t.ParseError = _
            }
        })
        , Ny = Ke({
            "node_modules/@xmldom/xmldom/lib/dom-parser.js"(t) {
                var e = Uo()
                    , s = wc()
                    , r = My()
                    , n = Ry()
                    , a = s.DOMImplementation
                    , o = e.NAMESPACE
                    , u = n.ParseError
                    , c = n.XMLReader;
                function f(x) {
                    return x.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`)
                }
                function v(x) {
                    this.options = x || {
                        locator: {}
                    }
                }
                v.prototype.parseFromString = function (x, B) {
                    var z = this.options
                        , R = new c
                        , F = z.domBuilder || new D
                        , Y = z.errorHandler
                        , ue = z.locator
                        , de = z.xmlns || {}
                        , ee = /\/x?html?$/.test(B)
                        , G = ee ? r.HTML_ENTITIES : r.XML_ENTITIES;
                    ue && F.setDocumentLocator(ue),
                        R.errorHandler = T(Y, F, ue),
                        R.domBuilder = z.domBuilder || F,
                        ee && (de[""] = o.HTML),
                        de.xml = de.xml || o.XML;
                    var A = z.normalizeLineEndings || f;
                    return x && typeof x == "string" ? R.parse(A(x), de, G) : R.errorHandler.error("invalid doc source"),
                        F.doc
                }
                    ;
                function T(x, B, z) {
                    if (!x) {
                        if (B instanceof D)
                            return B;
                        x = B
                    }
                    var R = {}
                        , F = x instanceof Function;
                    z = z || {};
                    function Y(ue) {
                        var de = x[ue];
                        !de && F && (de = x.length == 2 ? function (ee) {
                            x(ue, ee)
                        }
                            : x),
                            R[ue] = de && function (ee) {
                                de("[xmldom " + ue + "]	" + ee + L(z))
                            }
                            || function () { }
                    }
                    return Y("warning"),
                        Y("error"),
                        Y("fatalError"),
                        R
                }
                function D() {
                    this.cdata = !1
                }
                function _(x, B) {
                    B.lineNumber = x.lineNumber,
                        B.columnNumber = x.columnNumber
                }
                D.prototype = {
                    startDocument: function () {
                        this.doc = new a().createDocument(null, null, null),
                            this.locator && (this.doc.documentURI = this.locator.systemId)
                    },
                    startElement: function (x, B, z, R) {
                        var F = this.doc
                            , Y = F.createElementNS(x, z || B)
                            , ue = R.length;
                        N(this, Y),
                            this.currentElement = Y,
                            this.locator && _(this.locator, Y);
                        for (var de = 0; de < ue; de++) {
                            var x = R.getURI(de)
                                , ee = R.getValue(de)
                                , z = R.getQName(de)
                                , G = F.createAttributeNS(x, z);
                            this.locator && _(R.getLocator(de), G),
                                G.value = G.nodeValue = ee,
                                Y.setAttributeNode(G)
                        }
                    },
                    endElement: function (x, B, z) {
                        var R = this.currentElement
                            , F = R.tagName;
                        this.currentElement = R.parentNode
                    },
                    startPrefixMapping: function (x, B) { },
                    endPrefixMapping: function (x) { },
                    processingInstruction: function (x, B) {
                        var z = this.doc.createProcessingInstruction(x, B);
                        this.locator && _(this.locator, z),
                            N(this, z)
                    },
                    ignorableWhitespace: function (x, B, z) { },
                    characters: function (x, B, z) {
                        if (x = M.apply(this, arguments),
                            x) {
                            if (this.cdata)
                                var R = this.doc.createCDATASection(x);
                            else
                                var R = this.doc.createTextNode(x);
                            this.currentElement ? this.currentElement.appendChild(R) : /^\s*$/.test(x) && this.doc.appendChild(R),
                                this.locator && _(this.locator, R)
                        }
                    },
                    skippedEntity: function (x) { },
                    endDocument: function () {
                        this.doc.normalize()
                    },
                    setDocumentLocator: function (x) {
                        (this.locator = x) && (x.lineNumber = 0)
                    },
                    comment: function (x, B, z) {
                        x = M.apply(this, arguments);
                        var R = this.doc.createComment(x);
                        this.locator && _(this.locator, R),
                            N(this, R)
                    },
                    startCDATA: function () {
                        this.cdata = !0
                    },
                    endCDATA: function () {
                        this.cdata = !1
                    },
                    startDTD: function (x, B, z) {
                        var R = this.doc.implementation;
                        if (R && R.createDocumentType) {
                            var F = R.createDocumentType(x, B, z);
                            this.locator && _(this.locator, F),
                                N(this, F),
                                this.doc.doctype = F
                        }
                    },
                    warning: function (x) {
                        console.warn("[xmldom warning]	" + x, L(this.locator))
                    },
                    error: function (x) {
                        console.error("[xmldom error]	" + x, L(this.locator))
                    },
                    fatalError: function (x) {
                        throw new u(x, this.locator)
                    }
                };
                function L(x) {
                    if (x)
                        return `
@` + (x.systemId || "") + "#[line:" + x.lineNumber + ",col:" + x.columnNumber + "]"
                }
                function M(x, B, z) {
                    return typeof x == "string" ? x.substr(B, z) : x.length >= B + z || B ? new java.lang.String(x, B, z) + "" : x
                }
                "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (x) {
                    D.prototype[x] = function () {
                        return null
                    }
                });
                function N(x, B) {
                    x.currentElement ? x.currentElement.appendChild(B) : x.doc.appendChild(B)
                }
                t.__DOMHandler = D,
                    t.normalizeLineEndings = f,
                    t.DOMParser = v
            }
        })
        , By = Ke({
            "node_modules/@xmldom/xmldom/lib/index.js"(t) {
                var e = wc();
                t.DOMImplementation = e.DOMImplementation,
                    t.XMLSerializer = e.XMLSerializer,
                    t.DOMParser = Ny().DOMParser
            }
        })
        , Fy = Ke({
            "node_modules/mux.js/lib/utils/numbers.js"(t, e) {
                var s = Math.pow(2, 32)
                    , r = function (n) {
                        var a = new DataView(n.buffer, n.byteOffset, n.byteLength), o;
                        return a.getBigUint64 ? (o = a.getBigUint64(0),
                            o < Number.MAX_SAFE_INTEGER ? Number(o) : o) : a.getUint32(0) * s + a.getUint32(4)
                    };
                e.exports = {
                    getUint64: r,
                    MAX_UINT32: s
                }
            }
        })
        , Uy = Ke({
            "node_modules/mux.js/lib/tools/parse-sidx.js"(t, e) {
                var s = Fy().getUint64
                    , r = function (n) {
                        var a = new DataView(n.buffer, n.byteOffset, n.byteLength)
                            , o = {
                                version: n[0],
                                flags: new Uint8Array(n.subarray(1, 4)),
                                references: [],
                                referenceId: a.getUint32(4),
                                timescale: a.getUint32(8)
                            }
                            , u = 12;
                        o.version === 0 ? (o.earliestPresentationTime = a.getUint32(u),
                            o.firstOffset = a.getUint32(u + 4),
                            u += 8) : (o.earliestPresentationTime = s(n.subarray(u)),
                                o.firstOffset = s(n.subarray(u + 8)),
                                u += 16),
                            u += 2;
                        var c = a.getUint16(u);
                        for (u += 2; c > 0; u += 12,
                            c--)
                            o.references.push({
                                referenceType: (n[u] & 128) >>> 7,
                                referencedSize: a.getUint32(u) & 2147483647,
                                subsegmentDuration: a.getUint32(u + 4),
                                startsWithSap: !!(n[u + 8] & 128),
                                sapType: (n[u + 8] & 112) >>> 4,
                                sapDeltaTime: a.getUint32(u + 8) & 268435455
                            });
                        return o
                    };
                e.exports = r
            }
        })
        , jy = Ke({
            "node_modules/mux.js/lib/utils/clock.js"(t, e) {
                var s = 9e4, r, n, a, o, u, c, f;
                r = function (v) {
                    return v * s
                }
                    ,
                    n = function (v, T) {
                        return v * T
                    }
                    ,
                    a = function (v) {
                        return v / s
                    }
                    ,
                    o = function (v, T) {
                        return v / T
                    }
                    ,
                    u = function (v, T) {
                        return r(o(v, T))
                    }
                    ,
                    c = function (v, T) {
                        return n(a(v), T)
                    }
                    ,
                    f = function (v, T, D) {
                        return a(D ? v : v - T)
                    }
                    ,
                    e.exports = {
                        ONE_SECOND_IN_TS: s,
                        secondsToVideoTs: r,
                        secondsToAudioTs: n,
                        videoTsToSeconds: a,
                        audioTsToSeconds: o,
                        audioTsToVideoTs: u,
                        videoTsToAudioTs: c,
                        metadataTsToSeconds: f
                    }
            }
        })
        , Hy = Ke({
            "node_modules/clusterize.js/clusterize.js"(t, e) {
                (function (s, r) {
                    typeof e < "u" ? e.exports = r() : typeof define == "function" && typeof define.amd == "object" ? define(r) : this[s] = r()
                }
                )("Clusterize", function () {
                    "use strict";
                    var s = function () {
                        for (var f = 3, v = document.createElement("b"), T = v.all || []; v.innerHTML = "<!--[if gt IE " + ++f + "]><i><![endif]-->",
                            T[0];)
                            ;
                        return f > 4 ? f : document.documentMode
                    }()
                        , r = navigator.platform.toLowerCase().indexOf("mac") + 1
                        , n = function (f) {
                            if (!(this instanceof n))
                                return new n(f);
                            var v = this
                                , T = {
                                    rows_in_block: 50,
                                    blocks_in_cluster: 4,
                                    tag: null,
                                    show_no_data_row: !0,
                                    no_data_class: "clusterize-no-data",
                                    no_data_text: "No data",
                                    keep_parity: !0,
                                    callbacks: {}
                                };
                            v.options = {};
                            for (var D = ["rows_in_block", "blocks_in_cluster", "show_no_data_row", "no_data_class", "no_data_text", "keep_parity", "tag", "callbacks"], _ = 0, L; L = D[_]; _++)
                                v.options[L] = typeof f[L] < "u" && f[L] != null ? f[L] : T[L];
                            for (var M = ["scroll", "content"], _ = 0, N; N = M[_]; _++)
                                if (v[N + "_elem"] = f[N + "Id"] ? document.getElementById(f[N + "Id"]) : f[N + "Elem"],
                                    !v[N + "_elem"])
                                    throw new Error("Error! Could not find " + N + " element");
                            v.content_elem.hasAttribute("tabindex") || v.content_elem.setAttribute("tabindex", 0);
                            var x = u(f.rows) ? f.rows : v.fetchMarkup()
                                , B = {}
                                , z = v.scroll_elem.scrollTop;
                            v.insertToDOM(x, B),
                                v.scroll_elem.scrollTop = z;
                            var R = !1
                                , F = 0
                                , Y = !1
                                , ue = function () {
                                    r && (Y || (v.content_elem.style.pointerEvents = "none"),
                                        Y = !0,
                                        clearTimeout(F),
                                        F = setTimeout(function () {
                                            v.content_elem.style.pointerEvents = "auto",
                                                Y = !1
                                        }, 50)),
                                        R != (R = v.getClusterNum(x)) && v.insertToDOM(x, B),
                                        v.options.callbacks.scrollingProgress && v.options.callbacks.scrollingProgress(v.getScrollProgress())
                                }
                                , de = 0
                                , ee = function () {
                                    clearTimeout(de),
                                        de = setTimeout(v.refresh, 100)
                                };
                            a("scroll", v.scroll_elem, ue),
                                a("resize", window, ee),
                                v.destroy = function (A) {
                                    o("scroll", v.scroll_elem, ue),
                                        o("resize", window, ee),
                                        v.html((A ? v.generateEmptyRow() : x).join(""))
                                }
                                ,
                                v.refresh = function (A) {
                                    (v.getRowsHeight(x) || A) && v.update(x)
                                }
                                ,
                                v.update = function (A) {
                                    x = u(A) ? A : [];
                                    var w = v.scroll_elem.scrollTop;
                                    x.length * v.options.item_height < w && (v.scroll_elem.scrollTop = 0,
                                        R = 0),
                                        v.insertToDOM(x, B),
                                        v.scroll_elem.scrollTop = w
                                }
                                ,
                                v.clear = function () {
                                    v.update([])
                                }
                                ,
                                v.getRowsAmount = function () {
                                    return x.length
                                }
                                ,
                                v.getScrollProgress = function () {
                                    return this.options.scroll_top / (x.length * this.options.item_height) * 100 || 0
                                }
                                ;
                            var G = function (A, w) {
                                var H = u(w) ? w : [];
                                H.length && (x = A == "append" ? x.concat(H) : H.concat(x),
                                    v.insertToDOM(x, B))
                            };
                            v.append = function (A) {
                                G("append", A)
                            }
                                ,
                                v.prepend = function (A) {
                                    G("prepend", A)
                                }
                        };
                    n.prototype = {
                        constructor: n,
                        fetchMarkup: function () {
                            for (var f = [], v = this.getChildNodes(this.content_elem); v.length;)
                                f.push(v.shift().outerHTML);
                            return f
                        },
                        exploreEnvironment: function (f, v) {
                            var T = this.options;
                            T.content_tag = this.content_elem.tagName.toLowerCase(),
                                f.length && (s && s <= 9 && !T.tag && (T.tag = f[0].match(/<([^>\s/]*)/)[1].toLowerCase()),
                                    this.content_elem.children.length <= 1 && (v.data = this.html(f[0] + f[0] + f[0])),
                                    T.tag || (T.tag = this.content_elem.children[0].tagName.toLowerCase()),
                                    this.getRowsHeight(f))
                        },
                        getRowsHeight: function (f) {
                            var v = this.options
                                , T = v.item_height;
                            if (v.cluster_height = 0,
                                !!f.length) {
                                var D = this.content_elem.children;
                                if (D.length) {
                                    var _ = D[Math.floor(D.length / 2)];
                                    if (v.item_height = _.offsetHeight,
                                        v.tag == "tr" && c("borderCollapse", this.content_elem) != "collapse" && (v.item_height += parseInt(c("borderSpacing", this.content_elem), 10) || 0),
                                        v.tag != "tr") {
                                        var L = parseInt(c("marginTop", _), 10) || 0
                                            , M = parseInt(c("marginBottom", _), 10) || 0;
                                        v.item_height += Math.max(L, M)
                                    }
                                    return v.block_height = v.item_height * v.rows_in_block,
                                        v.rows_in_cluster = v.blocks_in_cluster * v.rows_in_block,
                                        v.cluster_height = v.blocks_in_cluster * v.block_height,
                                        T != v.item_height
                                }
                            }
                        },
                        getClusterNum: function (f) {
                            var v = this.options;
                            v.scroll_top = this.scroll_elem.scrollTop;
                            var T = v.cluster_height - v.block_height
                                , D = Math.floor(v.scroll_top / T)
                                , _ = Math.floor(f.length * v.item_height / T);
                            return Math.min(D, _)
                        },
                        generateEmptyRow: function () {
                            var f = this.options;
                            if (!f.tag || !f.show_no_data_row)
                                return [];
                            var v = document.createElement(f.tag), T = document.createTextNode(f.no_data_text), D;
                            return v.className = f.no_data_class,
                                f.tag == "tr" && (D = document.createElement("td"),
                                    D.colSpan = 100,
                                    D.appendChild(T)),
                                v.appendChild(D || T),
                                [v.outerHTML]
                        },
                        generate: function (f) {
                            var v = this.options
                                , T = f.length;
                            if (T < v.rows_in_block)
                                return {
                                    top_offset: 0,
                                    bottom_offset: 0,
                                    rows_above: 0,
                                    rows: T ? f : this.generateEmptyRow()
                                };
                            var D = Math.max((v.rows_in_cluster - v.rows_in_block) * this.getClusterNum(f), 0)
                                , _ = D + v.rows_in_cluster
                                , L = Math.max(D * v.item_height, 0)
                                , M = Math.max((T - _) * v.item_height, 0)
                                , N = []
                                , x = D;
                            L < 1 && x++;
                            for (var B = D; B < _; B++)
                                f[B] && N.push(f[B]);
                            return {
                                top_offset: L,
                                bottom_offset: M,
                                rows_above: x,
                                rows: N
                            }
                        },
                        renderExtraTag: function (f, v) {
                            var T = document.createElement(this.options.tag)
                                , D = "clusterize-";
                            return T.className = [D + "extra-row", D + f].join(" "),
                                v && (T.style.height = v + "px"),
                                T.outerHTML
                        },
                        insertToDOM: function (f, v) {
                            this.options.cluster_height || this.exploreEnvironment(f, v);
                            var T = this.generate(f)
                                , D = T.rows.join("")
                                , _ = this.checkChanges("data", D, v)
                                , L = this.checkChanges("top", T.top_offset, v)
                                , M = this.checkChanges("bottom", T.bottom_offset, v)
                                , N = this.options.callbacks
                                , x = [];
                            _ || L ? (T.top_offset && (this.options.keep_parity && x.push(this.renderExtraTag("keep-parity")),
                                x.push(this.renderExtraTag("top-space", T.top_offset))),
                                x.push(D),
                                T.bottom_offset && x.push(this.renderExtraTag("bottom-space", T.bottom_offset)),
                                N.clusterWillChange && N.clusterWillChange(),
                                this.html(x.join("")),
                                this.options.content_tag == "ol" && this.content_elem.setAttribute("start", T.rows_above),
                                this.content_elem.style["counter-increment"] = "clusterize-counter " + (T.rows_above - 1),
                                N.clusterChanged && N.clusterChanged()) : M && (this.content_elem.lastChild.style.height = T.bottom_offset + "px")
                        },
                        html: function (f) {
                            var v = this.content_elem;
                            if (s && s <= 9 && this.options.tag == "tr") {
                                var T = document.createElement("div"), D;
                                for (T.innerHTML = "<table><tbody>" + f + "</tbody></table>"; D = v.lastChild;)
                                    v.removeChild(D);
                                for (var _ = this.getChildNodes(T.firstChild.firstChild); _.length;)
                                    v.appendChild(_.shift())
                            } else
                                v.innerHTML = f
                        },
                        getChildNodes: function (f) {
                            for (var v = f.children, T = [], D = 0, _ = v.length; D < _; D++)
                                T.push(v[D]);
                            return T
                        },
                        checkChanges: function (f, v, T) {
                            var D = v != T[f];
                            return T[f] = v,
                                D
                        }
                    };
                    function a(f, v, T) {
                        return v.addEventListener ? v.addEventListener(f, T, !1) : v.attachEvent("on" + f, T)
                    }
                    function o(f, v, T) {
                        return v.removeEventListener ? v.removeEventListener(f, T, !1) : v.detachEvent("on" + f, T)
                    }
                    function u(f) {
                        return Object.prototype.toString.call(f) === "[object Array]"
                    }
                    function c(f, v) {
                        return window.getComputedStyle ? window.getComputedStyle(v)[f] : v.currentStyle[f]
                    }
                    return n
                })
            }
        })
        , O = _t(Ki())
        , le = _t(Ac())
        , we = _t(Sy())
        , qy = _t(Cy())
        , Dc = _t(ky())
        , kc = _t(Ly());
    function Pi() {
        return Pi = Object.assign ? Object.assign.bind() : function (t) {
            for (var e = 1; e < arguments.length; e++) {
                var s = arguments[e];
                for (var r in s)
                    Object.prototype.hasOwnProperty.call(s, r) && (t[r] = s[r])
            }
            return t
        }
            ,
            Pi.apply(this, arguments)
    }
    var xc = _t(Oy())
        , Hs = _t(Ki())
        , Ic = "http://example.com"
        , $y = function (e, s) {
            if (/^[a-z]+:/i.test(s))
                return s;
            /^data:/.test(e) && (e = Hs.default.location && Hs.default.location.href || "");
            var r = typeof Hs.default.URL == "function"
                , n = /^\/\//.test(e)
                , a = !Hs.default.location && !/\/\//i.test(e);
            if (r ? e = new Hs.default.URL(e, Hs.default.location || Ic) : /\/\//i.test(e) || (e = xc.default.buildAbsoluteURL(Hs.default.location && Hs.default.location.href || "", e)),
                r) {
                var o = new URL(s, e);
                return a ? o.href.slice(Ic.length) : n ? o.href.slice(o.protocol.length) : o.href
            }
            return xc.default.buildAbsoluteURL(e, s)
        }
        , jo = $y
        , oh = function () {
            function t() {
                this.listeners = {}
            }
            var e = t.prototype;
            return e.on = function (r, n) {
                this.listeners[r] || (this.listeners[r] = []),
                    this.listeners[r].push(n)
            }
                ,
                e.off = function (r, n) {
                    if (!this.listeners[r])
                        return !1;
                    var a = this.listeners[r].indexOf(n);
                    return this.listeners[r] = this.listeners[r].slice(0),
                        this.listeners[r].splice(a, 1),
                        a > -1
                }
                ,
                e.trigger = function (r) {
                    var n = this.listeners[r];
                    if (n)
                        if (arguments.length === 2)
                            for (var a = n.length, o = 0; o < a; ++o)
                                n[o].call(this, arguments[1]);
                        else
                            for (var u = Array.prototype.slice.call(arguments, 1), c = n.length, f = 0; f < c; ++f)
                                n[f].apply(this, u)
                }
                ,
                e.dispose = function () {
                    this.listeners = {}
                }
                ,
                e.pipe = function (r) {
                    this.on("data", function (n) {
                        r.push(n)
                    })
                }
                ,
                t
        }()
        , Pc = _t(Ki())
        , Vy = function (e) {
            return Pc.default.atob ? Pc.default.atob(e) : Buffer.from(e, "base64").toString("binary")
        };
    function zy(t) {
        for (var e = Vy(t), s = new Uint8Array(e.length), r = 0; r < e.length; r++)
            s[r] = e.charCodeAt(r);
        return s
    }
    var Gy = class extends oh {
        constructor() {
            super(),
                this.buffer = ""
        }
        push(t) {
            let e;
            for (this.buffer += t,
                e = this.buffer.indexOf(`
`); e > -1; e = this.buffer.indexOf(`
`))
                this.trigger("data", this.buffer.substring(0, e)),
                    this.buffer = this.buffer.substring(e + 1)
        }
    }
        , Wy = String.fromCharCode(9)
        , lh = function (t) {
            const e = /([0-9.]*)?@?([0-9.]*)?/.exec(t || "")
                , s = {};
            return e[1] && (s.length = parseInt(e[1], 10)),
                e[2] && (s.offset = parseInt(e[2], 10)),
                s
        }
        , Ky = function () {
            const t = "[^=]*"
                , e = '"[^"]*"|[^,]*'
                , s = "(?:" + t + ")=(?:" + e + ")";
            return new RegExp("(?:^|,)(" + s + ")")
        }
        , li = function (t) {
            const e = {};
            if (!t)
                return e;
            const s = t.split(Ky());
            let r = s.length, n;
            for (; r--;)
                s[r] !== "" && (n = /([^=]*)=(.*)/.exec(s[r]).slice(1),
                    n[0] = n[0].replace(/^\s+|\s+$/g, ""),
                    n[1] = n[1].replace(/^\s+|\s+$/g, ""),
                    n[1] = n[1].replace(/^['"](.*)['"]$/g, "$1"),
                    e[n[0]] = n[1]);
            return e
        }
        , Xy = class extends oh {
            constructor() {
                super(),
                    this.customParsers = [],
                    this.tagMappers = []
            }
            push(t) {
                let e, s;
                if (t = t.trim(),
                    t.length === 0)
                    return;
                if (t[0] !== "#") {
                    this.trigger("data", {
                        type: "uri",
                        uri: t
                    });
                    return
                }
                this.tagMappers.reduce((n, a) => {
                    const o = a(t);
                    return o === t ? n : n.concat([o])
                }
                    , [t]).forEach(n => {
                        for (let a = 0; a < this.customParsers.length; a++)
                            if (this.customParsers[a].call(this, n))
                                return;
                        if (n.indexOf("#EXT") !== 0) {
                            this.trigger("data", {
                                type: "comment",
                                text: n.slice(1)
                            });
                            return
                        }
                        if (n = n.replace("\r", ""),
                            e = /^#EXTM3U/.exec(n),
                            e) {
                            this.trigger("data", {
                                type: "tag",
                                tagType: "m3u"
                            });
                            return
                        }
                        if (e = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "inf"
                            },
                                e[1] && (s.duration = parseFloat(e[1])),
                                e[2] && (s.title = e[2]),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "targetduration"
                            },
                                e[1] && (s.duration = parseInt(e[1], 10)),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-VERSION:([0-9.]*)?/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "version"
                            },
                                e[1] && (s.version = parseInt(e[1], 10)),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "media-sequence"
                            },
                                e[1] && (s.number = parseInt(e[1], 10)),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "discontinuity-sequence"
                            },
                                e[1] && (s.number = parseInt(e[1], 10)),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "playlist-type"
                            },
                                e[1] && (s.playlistType = e[1]),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-BYTERANGE:(.*)?$/.exec(n),
                            e) {
                            s = Pi(lh(e[1]), {
                                type: "tag",
                                tagType: "byterange"
                            }),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "allow-cache"
                            },
                                e[1] && (s.allowed = !/NO/.test(e[1])),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-MAP:(.*)$/.exec(n),
                            e) {
                            if (s = {
                                type: "tag",
                                tagType: "map"
                            },
                                e[1]) {
                                const a = li(e[1]);
                                a.URI && (s.uri = a.URI),
                                    a.BYTERANGE && (s.byterange = lh(a.BYTERANGE))
                            }
                            this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-STREAM-INF:(.*)$/.exec(n),
                            e) {
                            if (s = {
                                type: "tag",
                                tagType: "stream-inf"
                            },
                                e[1]) {
                                if (s.attributes = li(e[1]),
                                    s.attributes.RESOLUTION) {
                                    const a = s.attributes.RESOLUTION.split("x")
                                        , o = {};
                                    a[0] && (o.width = parseInt(a[0], 10)),
                                        a[1] && (o.height = parseInt(a[1], 10)),
                                        s.attributes.RESOLUTION = o
                                }
                                s.attributes.BANDWIDTH && (s.attributes.BANDWIDTH = parseInt(s.attributes.BANDWIDTH, 10)),
                                    s.attributes["FRAME-RATE"] && (s.attributes["FRAME-RATE"] = parseFloat(s.attributes["FRAME-RATE"])),
                                    s.attributes["PROGRAM-ID"] && (s.attributes["PROGRAM-ID"] = parseInt(s.attributes["PROGRAM-ID"], 10))
                            }
                            this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-MEDIA:(.*)$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "media"
                            },
                                e[1] && (s.attributes = li(e[1])),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-ENDLIST/.exec(n),
                            e) {
                            this.trigger("data", {
                                type: "tag",
                                tagType: "endlist"
                            });
                            return
                        }
                        if (e = /^#EXT-X-DISCONTINUITY/.exec(n),
                            e) {
                            this.trigger("data", {
                                type: "tag",
                                tagType: "discontinuity"
                            });
                            return
                        }
                        if (e = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "program-date-time"
                            },
                                e[1] && (s.dateTimeString = e[1],
                                    s.dateTimeObject = new Date(e[1])),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-KEY:(.*)$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "key"
                            },
                                e[1] && (s.attributes = li(e[1]),
                                    s.attributes.IV && (s.attributes.IV.substring(0, 2).toLowerCase() === "0x" && (s.attributes.IV = s.attributes.IV.substring(2)),
                                        s.attributes.IV = s.attributes.IV.match(/.{8}/g),
                                        s.attributes.IV[0] = parseInt(s.attributes.IV[0], 16),
                                        s.attributes.IV[1] = parseInt(s.attributes.IV[1], 16),
                                        s.attributes.IV[2] = parseInt(s.attributes.IV[2], 16),
                                        s.attributes.IV[3] = parseInt(s.attributes.IV[3], 16),
                                        s.attributes.IV = new Uint32Array(s.attributes.IV))),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-START:(.*)$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "start"
                            },
                                e[1] && (s.attributes = li(e[1]),
                                    s.attributes["TIME-OFFSET"] = parseFloat(s.attributes["TIME-OFFSET"]),
                                    s.attributes.PRECISE = /YES/.test(s.attributes.PRECISE)),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "cue-out-cont"
                            },
                                e[1] ? s.data = e[1] : s.data = "",
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-CUE-OUT:(.*)?$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "cue-out"
                            },
                                e[1] ? s.data = e[1] : s.data = "",
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-CUE-IN:(.*)?$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "cue-in"
                            },
                                e[1] ? s.data = e[1] : s.data = "",
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-SKIP:(.*)$/.exec(n),
                            e && e[1]) {
                            s = {
                                type: "tag",
                                tagType: "skip"
                            },
                                s.attributes = li(e[1]),
                                s.attributes.hasOwnProperty("SKIPPED-SEGMENTS") && (s.attributes["SKIPPED-SEGMENTS"] = parseInt(s.attributes["SKIPPED-SEGMENTS"], 10)),
                                s.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES") && (s.attributes["RECENTLY-REMOVED-DATERANGES"] = s.attributes["RECENTLY-REMOVED-DATERANGES"].split(Wy)),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-PART:(.*)$/.exec(n),
                            e && e[1]) {
                            s = {
                                type: "tag",
                                tagType: "part"
                            },
                                s.attributes = li(e[1]),
                                ["DURATION"].forEach(function (a) {
                                    s.attributes.hasOwnProperty(a) && (s.attributes[a] = parseFloat(s.attributes[a]))
                                }),
                                ["INDEPENDENT", "GAP"].forEach(function (a) {
                                    s.attributes.hasOwnProperty(a) && (s.attributes[a] = /YES/.test(s.attributes[a]))
                                }),
                                s.attributes.hasOwnProperty("BYTERANGE") && (s.attributes.byterange = lh(s.attributes.BYTERANGE)),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(n),
                            e && e[1]) {
                            s = {
                                type: "tag",
                                tagType: "server-control"
                            },
                                s.attributes = li(e[1]),
                                ["CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK"].forEach(function (a) {
                                    s.attributes.hasOwnProperty(a) && (s.attributes[a] = parseFloat(s.attributes[a]))
                                }),
                                ["CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD"].forEach(function (a) {
                                    s.attributes.hasOwnProperty(a) && (s.attributes[a] = /YES/.test(s.attributes[a]))
                                }),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-PART-INF:(.*)$/.exec(n),
                            e && e[1]) {
                            s = {
                                type: "tag",
                                tagType: "part-inf"
                            },
                                s.attributes = li(e[1]),
                                ["PART-TARGET"].forEach(function (a) {
                                    s.attributes.hasOwnProperty(a) && (s.attributes[a] = parseFloat(s.attributes[a]))
                                }),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(n),
                            e && e[1]) {
                            s = {
                                type: "tag",
                                tagType: "preload-hint"
                            },
                                s.attributes = li(e[1]),
                                ["BYTERANGE-START", "BYTERANGE-LENGTH"].forEach(function (a) {
                                    if (s.attributes.hasOwnProperty(a)) {
                                        s.attributes[a] = parseInt(s.attributes[a], 10);
                                        const o = a === "BYTERANGE-LENGTH" ? "length" : "offset";
                                        s.attributes.byterange = s.attributes.byterange || {},
                                            s.attributes.byterange[o] = s.attributes[a],
                                            delete s.attributes[a]
                                    }
                                }),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(n),
                            e && e[1]) {
                            s = {
                                type: "tag",
                                tagType: "rendition-report"
                            },
                                s.attributes = li(e[1]),
                                ["LAST-MSN", "LAST-PART"].forEach(function (a) {
                                    s.attributes.hasOwnProperty(a) && (s.attributes[a] = parseInt(s.attributes[a], 10))
                                }),
                                this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-DATERANGE:(.*)$/.exec(n),
                            e && e[1]) {
                            s = {
                                type: "tag",
                                tagType: "daterange"
                            },
                                s.attributes = li(e[1]),
                                ["ID", "CLASS"].forEach(function (o) {
                                    s.attributes.hasOwnProperty(o) && (s.attributes[o] = String(s.attributes[o]))
                                }),
                                ["START-DATE", "END-DATE"].forEach(function (o) {
                                    s.attributes.hasOwnProperty(o) && (s.attributes[o] = new Date(s.attributes[o]))
                                }),
                                ["DURATION", "PLANNED-DURATION"].forEach(function (o) {
                                    s.attributes.hasOwnProperty(o) && (s.attributes[o] = parseFloat(s.attributes[o]))
                                }),
                                ["END-ON-NEXT"].forEach(function (o) {
                                    s.attributes.hasOwnProperty(o) && (s.attributes[o] = /YES/i.test(s.attributes[o]))
                                }),
                                ["SCTE35-CMD", " SCTE35-OUT", "SCTE35-IN"].forEach(function (o) {
                                    s.attributes.hasOwnProperty(o) && (s.attributes[o] = s.attributes[o].toString(16))
                                });
                            const a = /^X-([A-Z]+-)+[A-Z]+$/;
                            for (const o in s.attributes) {
                                if (!a.test(o))
                                    continue;
                                const u = /[0-9A-Fa-f]{6}/g.test(s.attributes[o])
                                    , c = /^\d+(\.\d+)?$/.test(s.attributes[o]);
                                s.attributes[o] = u ? s.attributes[o].toString(16) : c ? parseFloat(s.attributes[o]) : String(s.attributes[o])
                            }
                            this.trigger("data", s);
                            return
                        }
                        if (e = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(n),
                            e) {
                            this.trigger("data", {
                                type: "tag",
                                tagType: "independent-segments"
                            });
                            return
                        }
                        if (e = /^#EXT-X-CONTENT-STEERING:(.*)$/.exec(n),
                            e) {
                            s = {
                                type: "tag",
                                tagType: "content-steering"
                            },
                                s.attributes = li(e[1]),
                                this.trigger("data", s);
                            return
                        }
                        this.trigger("data", {
                            type: "tag",
                            data: n.slice(4)
                        })
                    }
                    )
            }
            addParser({ expression: t, customType: e, dataParser: s, segment: r }) {
                typeof s != "function" && (s = n => n),
                    this.customParsers.push(n => {
                        if (t.exec(n))
                            return this.trigger("data", {
                                type: "custom",
                                data: s(n),
                                customType: e,
                                segment: r
                            }),
                                !0
                    }
                    )
            }
            addTagMapper({ expression: t, map: e }) {
                const s = r => t.test(r) ? e(r) : r;
                this.tagMappers.push(s)
            }
        }
        , Yy = t => t.toLowerCase().replace(/-(\w)/g, e => e[1].toUpperCase())
        , qs = function (t) {
            const e = {};
            return Object.keys(t).forEach(function (s) {
                e[Yy(s)] = t[s]
            }),
                e
        }
        , uh = function (t) {
            const { serverControl: e, targetDuration: s, partTargetDuration: r } = t;
            if (!e)
                return;
            const n = "#EXT-X-SERVER-CONTROL"
                , a = "holdBack"
                , o = "partHoldBack"
                , u = s && s * 3
                , c = r && r * 2;
            s && !e.hasOwnProperty(a) && (e[a] = u,
                this.trigger("info", {
                    message: `${n} defaulting HOLD-BACK to targetDuration * 3 (${u}).`
                })),
                u && e[a] < u && (this.trigger("warn", {
                    message: `${n} clamping HOLD-BACK (${e[a]}) to targetDuration * 3 (${u})`
                }),
                    e[a] = u),
                r && !e.hasOwnProperty(o) && (e[o] = r * 3,
                    this.trigger("info", {
                        message: `${n} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${e[o]}).`
                    })),
                r && e[o] < c && (this.trigger("warn", {
                    message: `${n} clamping PART-HOLD-BACK (${e[o]}) to partTargetDuration * 2 (${c}).`
                }),
                    e[o] = c)
        }
        , Qy = class extends oh {
            constructor() {
                super(),
                    this.lineStream = new Gy,
                    this.parseStream = new Xy,
                    this.lineStream.pipe(this.parseStream),
                    this.lastProgramDateTime = null;
                const t = this
                    , e = [];
                let s = {}, r, n, a = !1;
                const o = function () { }
                    , u = {
                        AUDIO: {},
                        VIDEO: {},
                        "CLOSED-CAPTIONS": {},
                        SUBTITLES: {}
                    }
                    , c = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
                let f = 0;
                this.manifest = {
                    allowCache: !0,
                    discontinuityStarts: [],
                    dateRanges: [],
                    segments: []
                };
                let v = 0
                    , T = 0;
                const D = {};
                this.on("end", () => {
                    s.uri || !s.parts && !s.preloadHints || (!s.map && r && (s.map = r),
                        !s.key && n && (s.key = n),
                        !s.timeline && typeof f == "number" && (s.timeline = f),
                        this.manifest.preloadSegment = s)
                }
                ),
                    this.parseStream.on("data", function (_) {
                        let L, M;
                        ({
                            tag() {
                                ({
                                    version() {
                                        _.version && (this.manifest.version = _.version)
                                    },
                                    "allow-cache"() {
                                        this.manifest.allowCache = _.allowed,
                                            "allowed" in _ || (this.trigger("info", {
                                                message: "defaulting allowCache to YES"
                                            }),
                                                this.manifest.allowCache = !0)
                                    },
                                    byterange() {
                                        const N = {};
                                        "length" in _ && (s.byterange = N,
                                            N.length = _.length,
                                            "offset" in _ || (_.offset = v)),
                                            "offset" in _ && (s.byterange = N,
                                                N.offset = _.offset),
                                            v = N.offset + N.length
                                    },
                                    endlist() {
                                        this.manifest.endList = !0
                                    },
                                    inf() {
                                        "mediaSequence" in this.manifest || (this.manifest.mediaSequence = 0,
                                            this.trigger("info", {
                                                message: "defaulting media sequence to zero"
                                            })),
                                            "discontinuitySequence" in this.manifest || (this.manifest.discontinuitySequence = 0,
                                                this.trigger("info", {
                                                    message: "defaulting discontinuity sequence to zero"
                                                })),
                                            _.title && (s.title = _.title),
                                            _.duration > 0 && (s.duration = _.duration),
                                            _.duration === 0 && (s.duration = .01,
                                                this.trigger("info", {
                                                    message: "updating zero segment duration to a small value"
                                                })),
                                            this.manifest.segments = e
                                    },
                                    key() {
                                        if (!_.attributes) {
                                            this.trigger("warn", {
                                                message: "ignoring key declaration without attribute list"
                                            });
                                            return
                                        }
                                        if (_.attributes.METHOD === "NONE") {
                                            n = null;
                                            return
                                        }
                                        if (!_.attributes.URI) {
                                            this.trigger("warn", {
                                                message: "ignoring key declaration without URI"
                                            });
                                            return
                                        }
                                        if (_.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                                            this.manifest.contentProtection = this.manifest.contentProtection || {},
                                                this.manifest.contentProtection["com.apple.fps.1_0"] = {
                                                    attributes: _.attributes
                                                };
                                            return
                                        }
                                        if (_.attributes.KEYFORMAT === "com.microsoft.playready") {
                                            this.manifest.contentProtection = this.manifest.contentProtection || {},
                                                this.manifest.contentProtection["com.microsoft.playready"] = {
                                                    uri: _.attributes.URI
                                                };
                                            return
                                        }
                                        if (_.attributes.KEYFORMAT === c) {
                                            if (["SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC"].indexOf(_.attributes.METHOD) === -1) {
                                                this.trigger("warn", {
                                                    message: "invalid key method provided for Widevine"
                                                });
                                                return
                                            }
                                            if (_.attributes.METHOD === "SAMPLE-AES-CENC" && this.trigger("warn", {
                                                message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                                            }),
                                                _.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                                                this.trigger("warn", {
                                                    message: "invalid key URI provided for Widevine"
                                                });
                                                return
                                            }
                                            if (!(_.attributes.KEYID && _.attributes.KEYID.substring(0, 2) === "0x")) {
                                                this.trigger("warn", {
                                                    message: "invalid key ID provided for Widevine"
                                                });
                                                return
                                            }
                                            this.manifest.contentProtection = this.manifest.contentProtection || {},
                                                this.manifest.contentProtection["com.widevine.alpha"] = {
                                                    attributes: {
                                                        schemeIdUri: _.attributes.KEYFORMAT,
                                                        keyId: _.attributes.KEYID.substring(2)
                                                    },
                                                    pssh: zy(_.attributes.URI.split(",")[1])
                                                };
                                            return
                                        }
                                        _.attributes.METHOD || this.trigger("warn", {
                                            message: "defaulting key method to AES-128"
                                        }),
                                            n = {
                                                method: _.attributes.METHOD || "AES-128",
                                                uri: _.attributes.URI
                                            },
                                            typeof _.attributes.IV < "u" && (n.iv = _.attributes.IV)
                                    },
                                    "media-sequence"() {
                                        if (!isFinite(_.number)) {
                                            this.trigger("warn", {
                                                message: "ignoring invalid media sequence: " + _.number
                                            });
                                            return
                                        }
                                        this.manifest.mediaSequence = _.number
                                    },
                                    "discontinuity-sequence"() {
                                        if (!isFinite(_.number)) {
                                            this.trigger("warn", {
                                                message: "ignoring invalid discontinuity sequence: " + _.number
                                            });
                                            return
                                        }
                                        this.manifest.discontinuitySequence = _.number,
                                            f = _.number
                                    },
                                    "playlist-type"() {
                                        if (!/VOD|EVENT/.test(_.playlistType)) {
                                            this.trigger("warn", {
                                                message: "ignoring unknown playlist type: " + _.playlist
                                            });
                                            return
                                        }
                                        this.manifest.playlistType = _.playlistType
                                    },
                                    map() {
                                        r = {},
                                            _.uri && (r.uri = _.uri),
                                            _.byterange && (r.byterange = _.byterange),
                                            n && (r.key = n)
                                    },
                                    "stream-inf"() {
                                        if (this.manifest.playlists = e,
                                            this.manifest.mediaGroups = this.manifest.mediaGroups || u,
                                            !_.attributes) {
                                            this.trigger("warn", {
                                                message: "ignoring empty stream-inf attributes"
                                            });
                                            return
                                        }
                                        s.attributes || (s.attributes = {}),
                                            Pi(s.attributes, _.attributes)
                                    },
                                    media() {
                                        if (this.manifest.mediaGroups = this.manifest.mediaGroups || u,
                                            !(_.attributes && _.attributes.TYPE && _.attributes["GROUP-ID"] && _.attributes.NAME)) {
                                            this.trigger("warn", {
                                                message: "ignoring incomplete or missing media group"
                                            });
                                            return
                                        }
                                        const N = this.manifest.mediaGroups[_.attributes.TYPE];
                                        N[_.attributes["GROUP-ID"]] = N[_.attributes["GROUP-ID"]] || {},
                                            L = N[_.attributes["GROUP-ID"]],
                                            M = {
                                                default: /yes/i.test(_.attributes.DEFAULT)
                                            },
                                            M.default ? M.autoselect = !0 : M.autoselect = /yes/i.test(_.attributes.AUTOSELECT),
                                            _.attributes.LANGUAGE && (M.language = _.attributes.LANGUAGE),
                                            _.attributes.URI && (M.uri = _.attributes.URI),
                                            _.attributes["INSTREAM-ID"] && (M.instreamId = _.attributes["INSTREAM-ID"]),
                                            _.attributes.CHARACTERISTICS && (M.characteristics = _.attributes.CHARACTERISTICS),
                                            _.attributes.FORCED && (M.forced = /yes/i.test(_.attributes.FORCED)),
                                            L[_.attributes.NAME] = M
                                    },
                                    discontinuity() {
                                        f += 1,
                                            s.discontinuity = !0,
                                            this.manifest.discontinuityStarts.push(e.length)
                                    },
                                    "program-date-time"() {
                                        typeof this.manifest.dateTimeString > "u" && (this.manifest.dateTimeString = _.dateTimeString,
                                            this.manifest.dateTimeObject = _.dateTimeObject),
                                            s.dateTimeString = _.dateTimeString,
                                            s.dateTimeObject = _.dateTimeObject;
                                        const { lastProgramDateTime: N } = this;
                                        this.lastProgramDateTime = new Date(_.dateTimeString).getTime(),
                                            N === null && this.manifest.segments.reduceRight((x, B) => (B.programDateTime = x - B.duration * 1e3,
                                                B.programDateTime), this.lastProgramDateTime)
                                    },
                                    targetduration() {
                                        if (!isFinite(_.duration) || _.duration < 0) {
                                            this.trigger("warn", {
                                                message: "ignoring invalid target duration: " + _.duration
                                            });
                                            return
                                        }
                                        this.manifest.targetDuration = _.duration,
                                            uh.call(this, this.manifest)
                                    },
                                    start() {
                                        if (!_.attributes || isNaN(_.attributes["TIME-OFFSET"])) {
                                            this.trigger("warn", {
                                                message: "ignoring start declaration without appropriate attribute list"
                                            });
                                            return
                                        }
                                        this.manifest.start = {
                                            timeOffset: _.attributes["TIME-OFFSET"],
                                            precise: _.attributes.PRECISE
                                        }
                                    },
                                    "cue-out"() {
                                        s.cueOut = _.data
                                    },
                                    "cue-out-cont"() {
                                        s.cueOutCont = _.data
                                    },
                                    "cue-in"() {
                                        s.cueIn = _.data
                                    },
                                    skip() {
                                        this.manifest.skip = qs(_.attributes),
                                            this.warnOnMissingAttributes_("#EXT-X-SKIP", _.attributes, ["SKIPPED-SEGMENTS"])
                                    },
                                    part() {
                                        a = !0;
                                        const N = this.manifest.segments.length
                                            , x = qs(_.attributes);
                                        s.parts = s.parts || [],
                                            s.parts.push(x),
                                            x.byterange && (x.byterange.hasOwnProperty("offset") || (x.byterange.offset = T),
                                                T = x.byterange.offset + x.byterange.length);
                                        const B = s.parts.length - 1;
                                        this.warnOnMissingAttributes_(`#EXT-X-PART #${B} for segment #${N}`, _.attributes, ["URI", "DURATION"]),
                                            this.manifest.renditionReports && this.manifest.renditionReports.forEach((z, R) => {
                                                z.hasOwnProperty("lastPart") || this.trigger("warn", {
                                                    message: `#EXT-X-RENDITION-REPORT #${R} lacks required attribute(s): LAST-PART`
                                                })
                                            }
                                            )
                                    },
                                    "server-control"() {
                                        const N = this.manifest.serverControl = qs(_.attributes);
                                        N.hasOwnProperty("canBlockReload") || (N.canBlockReload = !1,
                                            this.trigger("info", {
                                                message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                                            })),
                                            uh.call(this, this.manifest),
                                            N.canSkipDateranges && !N.hasOwnProperty("canSkipUntil") && this.trigger("warn", {
                                                message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                                            })
                                    },
                                    "preload-hint"() {
                                        const N = this.manifest.segments.length
                                            , x = qs(_.attributes)
                                            , B = x.type && x.type === "PART";
                                        s.preloadHints = s.preloadHints || [],
                                            s.preloadHints.push(x),
                                            x.byterange && (x.byterange.hasOwnProperty("offset") || (x.byterange.offset = B ? T : 0,
                                                B && (T = x.byterange.offset + x.byterange.length)));
                                        const z = s.preloadHints.length - 1;
                                        if (this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${z} for segment #${N}`, _.attributes, ["TYPE", "URI"]),
                                            !!x.type)
                                            for (let R = 0; R < s.preloadHints.length - 1; R++) {
                                                const F = s.preloadHints[R];
                                                F.type && F.type === x.type && this.trigger("warn", {
                                                    message: `#EXT-X-PRELOAD-HINT #${z} for segment #${N} has the same TYPE ${x.type} as preload hint #${R}`
                                                })
                                            }
                                    },
                                    "rendition-report"() {
                                        const N = qs(_.attributes);
                                        this.manifest.renditionReports = this.manifest.renditionReports || [],
                                            this.manifest.renditionReports.push(N);
                                        const x = this.manifest.renditionReports.length - 1
                                            , B = ["LAST-MSN", "URI"];
                                        a && B.push("LAST-PART"),
                                            this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${x}`, _.attributes, B)
                                    },
                                    "part-inf"() {
                                        this.manifest.partInf = qs(_.attributes),
                                            this.warnOnMissingAttributes_("#EXT-X-PART-INF", _.attributes, ["PART-TARGET"]),
                                            this.manifest.partInf.partTarget && (this.manifest.partTargetDuration = this.manifest.partInf.partTarget),
                                            uh.call(this, this.manifest)
                                    },
                                    daterange() {
                                        this.manifest.dateRanges.push(qs(_.attributes));
                                        const N = this.manifest.dateRanges.length - 1;
                                        this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${N}`, _.attributes, ["ID", "START-DATE"]);
                                        const x = this.manifest.dateRanges[N];
                                        x.endDate && x.startDate && new Date(x.endDate) < new Date(x.startDate) && this.trigger("warn", {
                                            message: "EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"
                                        }),
                                            x.duration && x.duration < 0 && this.trigger("warn", {
                                                message: "EXT-X-DATERANGE DURATION must not be negative"
                                            }),
                                            x.plannedDuration && x.plannedDuration < 0 && this.trigger("warn", {
                                                message: "EXT-X-DATERANGE PLANNED-DURATION must not be negative"
                                            });
                                        const B = !!x.endOnNext;
                                        if (B && !x.class && this.trigger("warn", {
                                            message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"
                                        }),
                                            B && (x.duration || x.endDate) && this.trigger("warn", {
                                                message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"
                                            }),
                                            x.duration && x.endDate) {
                                            const R = x.startDate.getTime() + x.duration * 1e3;
                                            this.manifest.dateRanges[N].endDate = new Date(R)
                                        }
                                        if (!D[x.id])
                                            D[x.id] = x;
                                        else {
                                            for (const R in D[x.id])
                                                if (x[R] && JSON.stringify(D[x.id][R]) !== JSON.stringify(x[R])) {
                                                    this.trigger("warn", {
                                                        message: "EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes values"
                                                    });
                                                    break
                                                }
                                            const z = this.manifest.dateRanges.findIndex(R => R.id === x.id);
                                            this.manifest.dateRanges[z] = Pi(this.manifest.dateRanges[z], x),
                                                D[x.id] = Pi(D[x.id], x),
                                                this.manifest.dateRanges.pop()
                                        }
                                    },
                                    "independent-segments"() {
                                        this.manifest.independentSegments = !0
                                    },
                                    "content-steering"() {
                                        this.manifest.contentSteering = qs(_.attributes),
                                            this.warnOnMissingAttributes_("#EXT-X-CONTENT-STEERING", _.attributes, ["SERVER-URI"])
                                    }
                                }[_.tagType] || o).call(t)
                            },
                            uri() {
                                s.uri = _.uri,
                                    e.push(s),
                                    this.manifest.targetDuration && !("duration" in s) && (this.trigger("warn", {
                                        message: "defaulting segment duration to the target duration"
                                    }),
                                        s.duration = this.manifest.targetDuration),
                                    n && (s.key = n),
                                    s.timeline = f,
                                    r && (s.map = r),
                                    T = 0,
                                    this.lastProgramDateTime !== null && (s.programDateTime = this.lastProgramDateTime,
                                        this.lastProgramDateTime += s.duration * 1e3),
                                    s = {}
                            },
                            comment() { },
                            custom() {
                                _.segment ? (s.custom = s.custom || {},
                                    s.custom[_.customType] = _.data) : (this.manifest.custom = this.manifest.custom || {},
                                        this.manifest.custom[_.customType] = _.data)
                            }
                        })[_.type].call(t)
                    })
            }
            warnOnMissingAttributes_(t, e, s) {
                const r = [];
                s.forEach(function (n) {
                    e.hasOwnProperty(n) || r.push(n)
                }),
                    r.length && this.trigger("warn", {
                        message: `${t} lacks required attribute(s): ${r.join(", ")}`
                    })
            }
            push(t) {
                this.lineStream.push(t)
            }
            end() {
                this.lineStream.push(`
`),
                    this.manifest.dateRanges.length && this.lastProgramDateTime === null && this.trigger("warn", {
                        message: "A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"
                    }),
                    this.lastProgramDateTime = null,
                    this.trigger("end")
            }
            addParser(t) {
                this.parseStream.addParser(t)
            }
            addTagMapper(t) {
                this.parseStream.addTagMapper(t)
            }
        }
        , hh = _t(Ki())
        , gr = {
            mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
            webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
            ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
            video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
            audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
            text: /^(stpp.ttml.im1t)/,
            muxerVideo: /^(avc0?1)/,
            muxerAudio: /^(mp4a)/,
            muxerText: /a^/
        }
        , Jy = ["video", "audio", "text"]
        , Lc = ["Video", "Audio", "Text"]
        , Oc = function (e) {
            return e && e.replace(/avc1\.(\d+)\.(\d+)/i, function (s, r, n) {
                var a = ("00" + Number(r).toString(16)).slice(-2)
                    , o = ("00" + Number(n).toString(16)).slice(-2);
                return "avc1." + a + "00" + o
            })
        }
        , Xi = function (e) {
            e === void 0 && (e = "");
            var s = e.split(",")
                , r = [];
            return s.forEach(function (n) {
                n = n.trim();
                var a;
                Jy.forEach(function (o) {
                    var u = gr[o].exec(n.toLowerCase());
                    if (!(!u || u.length <= 1)) {
                        a = o;
                        var c = n.substring(0, u[1].length)
                            , f = n.replace(c, "");
                        r.push({
                            type: c,
                            details: f,
                            mediaType: o
                        })
                    }
                }),
                    a || r.push({
                        type: n,
                        details: "",
                        mediaType: "unknown"
                    })
            }),
                r
        }
        , Zy = function (e, s) {
            if (!e.mediaGroups.AUDIO || !s)
                return null;
            var r = e.mediaGroups.AUDIO[s];
            if (!r)
                return null;
            for (var n in r) {
                var a = r[n];
                if (a.default && a.playlists)
                    return Xi(a.playlists[0].attributes.CODECS)
            }
            return null
        }
        , Mc = function (e) {
            return e === void 0 && (e = ""),
                gr.audio.test(e.trim().toLowerCase())
        }
        , e_ = function (e) {
            return e === void 0 && (e = ""),
                gr.text.test(e.trim().toLowerCase())
        }
        , ma = function (e) {
            if (!(!e || typeof e != "string")) {
                var s = e.toLowerCase().split(",").map(function (a) {
                    return Oc(a.trim())
                })
                    , r = "video";
                s.length === 1 && Mc(s[0]) ? r = "audio" : s.length === 1 && e_(s[0]) && (r = "application");
                var n = "mp4";
                return s.every(function (a) {
                    return gr.mp4.test(a)
                }) ? n = "mp4" : s.every(function (a) {
                    return gr.webm.test(a)
                }) ? n = "webm" : s.every(function (a) {
                    return gr.ogg.test(a)
                }) && (n = "ogg"),
                    r + "/" + n + ';codecs="' + e + '"'
            }
        }
        , Ho = function (e) {
            return e === void 0 && (e = ""),
                hh.default.MediaSource && hh.default.MediaSource.isTypeSupported && hh.default.MediaSource.isTypeSupported(ma(e)) || !1
        }
        , dh = function (e) {
            return e === void 0 && (e = ""),
                e.toLowerCase().split(",").every(function (s) {
                    s = s.trim();
                    for (var r = 0; r < Lc.length; r++) {
                        var n = Lc[r];
                        if (gr["muxer" + n].test(s))
                            return !0
                    }
                    return !1
                })
        }
        , Rc = "mp4a.40.2"
        , t_ = "avc1.4d400d"
        , i_ = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i
        , s_ = /^application\/dash\+xml/i
        , Nc = function (e) {
            return i_.test(e) ? "hls" : s_.test(e) ? "dash" : e === "application/vnd.videojs.vhs+json" ? "vhs-json" : null
        }
        , r_ = _t(Ki())
        , n_ = function (e) {
            return e.toString(2).length
        }
        , a_ = function (e) {
            return Math.ceil(n_(e) / 8)
        }
        , Bc = function (e) {
            return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer
        }
        , o_ = function (e) {
            return Bc(e)
        }
        , ye = function (e) {
            return e instanceof Uint8Array ? e : (!Array.isArray(e) && !o_(e) && !(e instanceof ArrayBuffer) && (typeof e != "number" || typeof e == "number" && e !== e ? e = 0 : e = [e]),
                new Uint8Array(e && e.buffer || e, e && e.byteOffset || 0, e && e.byteLength || 0))
        }
        , Tt = r_.default.BigInt || Number
        , ch = [Tt("0x1"), Tt("0x100"), Tt("0x10000"), Tt("0x1000000"), Tt("0x100000000"), Tt("0x10000000000"), Tt("0x1000000000000"), Tt("0x100000000000000"), Tt("0x10000000000000000")]
        , pC = function () {
            var t = new Uint16Array([65484])
                , e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
            return e[0] === 255 ? "big" : e[0] === 204 ? "little" : "unknown"
        }()
        , l_ = function (e, s) {
            var r = s === void 0 ? {} : s
                , n = r.signed
                , a = n === void 0 ? !1 : n
                , o = r.le
                , u = o === void 0 ? !1 : o;
            e = ye(e);
            var c = u ? "reduce" : "reduceRight"
                , f = e[c] ? e[c] : Array.prototype[c]
                , v = f.call(e, function (D, _, L) {
                    var M = u ? L : Math.abs(L + 1 - e.length);
                    return D + Tt(_) * ch[M]
                }, Tt(0));
            if (a) {
                var T = ch[e.length] / Tt(2) - Tt(1);
                v = Tt(v),
                    v > T && (v -= T,
                        v -= T,
                        v -= Tt(2))
            }
            return Number(v)
        }
        , u_ = function (e, s) {
            var r = s === void 0 ? {} : s
                , n = r.le
                , a = n === void 0 ? !1 : n;
            (typeof e != "bigint" && typeof e != "number" || typeof e == "number" && e !== e) && (e = 0),
                e = Tt(e);
            for (var o = a_(e), u = new Uint8Array(new ArrayBuffer(o)), c = 0; c < o; c++) {
                var f = a ? c : Math.abs(c + 1 - u.length);
                u[f] = Number(e / ch[c] & Tt(255)),
                    e < 0 && (u[f] = Math.abs(~u[f]),
                        u[f] -= c === 0 ? 1 : 2)
            }
            return u
        }
        , h_ = function (e) {
            if (!e)
                return "";
            e = Array.prototype.slice.call(e);
            var s = String.fromCharCode.apply(null, ye(e));
            try {
                return decodeURIComponent(escape(s))
            } catch (r) { }
            return s
        }
        , Fc = function (e, s) {
            if (typeof e != "string" && e && typeof e.toString == "function" && (e = e.toString()),
                typeof e != "string")
                return new Uint8Array;
            s || (e = unescape(encodeURIComponent(e)));
            for (var r = new Uint8Array(e.length), n = 0; n < e.length; n++)
                r[n] = e.charCodeAt(n);
            return r
        }
        , d_ = function () {
            for (var e = arguments.length, s = new Array(e), r = 0; r < e; r++)
                s[r] = arguments[r];
            if (s = s.filter(function (u) {
                return u && (u.byteLength || u.length) && typeof u != "string"
            }),
                s.length <= 1)
                return ye(s[0]);
            var n = s.reduce(function (u, c, f) {
                return u + (c.byteLength || c.length)
            }, 0)
                , a = new Uint8Array(n)
                , o = 0;
            return s.forEach(function (u) {
                u = ye(u),
                    a.set(u, o),
                    o += u.byteLength
            }),
                a
        }
        , Xe = function (e, s, r) {
            var n = r === void 0 ? {} : r
                , a = n.offset
                , o = a === void 0 ? 0 : a
                , u = n.mask
                , c = u === void 0 ? [] : u;
            e = ye(e),
                s = ye(s);
            var f = s.every ? s.every : Array.prototype.every;
            return s.length && e.length - o >= s.length && f.call(s, function (v, T) {
                var D = c[T] ? c[T] & e[o + T] : e[o + T];
                return v === D
            })
        }
        , ei = _t(Ki())
        , c_ = function (e, s, r) {
            s.forEach(function (n) {
                for (var a in e.mediaGroups[n])
                    for (var o in e.mediaGroups[n][a]) {
                        var u = e.mediaGroups[n][a][o];
                        r(u, n, a, o)
                    }
            })
        }
        , Uc = _t(Ki())
        , f_ = function (e) {
            return Uc.default.atob ? Uc.default.atob(e) : Buffer.from(e, "base64").toString("binary")
        };
    function p_(t) {
        for (var e = f_(t), s = new Uint8Array(e.length), r = 0; r < e.length; r++)
            s[r] = e.charCodeAt(r);
        return s
    }
    var m_ = _t(By()), jc = t => !!t && typeof t == "object", pt = (...t) => t.reduce((e, s) => (typeof s != "object" || Object.keys(s).forEach(r => {
        Array.isArray(e[r]) && Array.isArray(s[r]) ? e[r] = e[r].concat(s[r]) : jc(e[r]) && jc(s[r]) ? e[r] = pt(e[r], s[r]) : e[r] = s[r]
    }
    ),
        e), {}), Hc = t => Object.keys(t).map(e => t[e]), g_ = (t, e) => {
            const s = [];
            for (let r = t; r < e; r++)
                s.push(r);
            return s
        }
        , Zr = t => t.reduce((e, s) => e.concat(s), []), qc = t => {
            if (!t.length)
                return [];
            const e = [];
            for (let s = 0; s < t.length; s++)
                e.push(t[s]);
            return e
        }
        , v_ = (t, e) => t.reduce((s, r, n) => (r[e] && s.push(n),
            s), []), y_ = (t, e) => Hc(t.reduce((s, r) => (r.forEach(n => {
                s[e(n)] = n
            }
            ),
                s), {})), en = {
                    INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
                    INVALID_NUMBER_OF_CONTENT_STEERING: "INVALID_NUMBER_OF_CONTENT_STEERING",
                    DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
                    DASH_INVALID_XML: "DASH_INVALID_XML",
                    NO_BASE_URL: "NO_BASE_URL",
                    MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
                    SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
                    UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
                }, ga = ({ baseUrl: t = "", source: e = "", range: s = "", indexRange: r = "" }) => {
                    const n = {
                        uri: e,
                        resolvedUri: jo(t || "", e)
                    };
                    if (s || r) {
                        const o = (s || r).split("-");
                        let u = ei.default.BigInt ? ei.default.BigInt(o[0]) : parseInt(o[0], 10)
                            , c = ei.default.BigInt ? ei.default.BigInt(o[1]) : parseInt(o[1], 10);
                        u < Number.MAX_SAFE_INTEGER && typeof u == "bigint" && (u = Number(u)),
                            c < Number.MAX_SAFE_INTEGER && typeof c == "bigint" && (c = Number(c));
                        let f;
                        typeof c == "bigint" || typeof u == "bigint" ? f = ei.default.BigInt(c) - ei.default.BigInt(u) + ei.default.BigInt(1) : f = c - u + 1,
                            typeof f == "bigint" && f < Number.MAX_SAFE_INTEGER && (f = Number(f)),
                            n.byterange = {
                                length: f,
                                offset: u
                            }
                    }
                    return n
                }
        , __ = t => {
            let e;
            return typeof t.offset == "bigint" || typeof t.length == "bigint" ? e = ei.default.BigInt(t.offset) + ei.default.BigInt(t.length) - ei.default.BigInt(1) : e = t.offset + t.length - 1,
                `${t.offset}-${e}`
        }
        , $c = t => (t && typeof t != "number" && (t = parseInt(t, 10)),
            isNaN(t) ? null : t), T_ = {
                static(t) {
                    const { duration: e, timescale: s = 1, sourceDuration: r, periodDuration: n } = t
                        , a = $c(t.endNumber)
                        , o = e / s;
                    return typeof a == "number" ? {
                        start: 0,
                        end: a
                    } : typeof n == "number" ? {
                        start: 0,
                        end: n / o
                    } : {
                        start: 0,
                        end: r / o
                    }
                },
                dynamic(t) {
                    const { NOW: e, clientOffset: s, availabilityStartTime: r, timescale: n = 1, duration: a, periodStart: o = 0, minimumUpdatePeriod: u = 0, timeShiftBufferDepth: c = 1 / 0 } = t
                        , f = $c(t.endNumber)
                        , v = (e + s) / 1e3
                        , T = r + o
                        , _ = v + u - T
                        , L = Math.ceil(_ * n / a)
                        , M = Math.floor((v - T - c) * n / a)
                        , N = Math.floor((v - T) * n / a);
                    return {
                        start: Math.max(0, M),
                        end: typeof f == "number" ? f : Math.min(L, N)
                    }
                }
            }, b_ = t => e => {
                const { duration: s, timescale: r = 1, periodStart: n, startNumber: a = 1 } = t;
                return {
                    number: a + e,
                    duration: s / r,
                    timeline: n,
                    time: e * s
                }
            }
        , fh = t => {
            const { type: e, duration: s, timescale: r = 1, periodDuration: n, sourceDuration: a } = t
                , { start: o, end: u } = T_[e](t)
                , c = g_(o, u).map(b_(t));
            if (e === "static") {
                const f = c.length - 1
                    , v = typeof n == "number" ? n : a;
                c[f].duration = v - s / r * f
            }
            return c
        }
        , Vc = t => {
            const { baseUrl: e, initialization: s = {}, sourceDuration: r, indexRange: n = "", periodStart: a, presentationTime: o, number: u = 0, duration: c } = t;
            if (!e)
                throw new Error(en.NO_BASE_URL);
            const f = ga({
                baseUrl: e,
                source: s.sourceURL,
                range: s.range
            })
                , v = ga({
                    baseUrl: e,
                    source: e,
                    indexRange: n
                });
            if (v.map = f,
                c) {
                const T = fh(t);
                T.length && (v.duration = T[0].duration,
                    v.timeline = T[0].timeline)
            } else
                r && (v.duration = r,
                    v.timeline = a);
            return v.presentationTime = o || a,
                v.number = u,
                [v]
        }
        , ph = (t, e, s) => {
            const r = t.sidx.map ? t.sidx.map : null
                , n = t.sidx.duration
                , a = t.timeline || 0
                , o = t.sidx.byterange
                , u = o.offset + o.length
                , c = e.timescale
                , f = e.references.filter(N => N.referenceType !== 1)
                , v = []
                , T = t.endList ? "static" : "dynamic"
                , D = t.sidx.timeline;
            let _ = D, L = t.mediaSequence || 0, M;
            typeof e.firstOffset == "bigint" ? M = ei.default.BigInt(u) + e.firstOffset : M = u + e.firstOffset;
            for (let N = 0; N < f.length; N++) {
                const x = e.references[N]
                    , B = x.referencedSize
                    , z = x.subsegmentDuration;
                let R;
                typeof M == "bigint" ? R = M + ei.default.BigInt(B) - ei.default.BigInt(1) : R = M + B - 1;
                const F = `${M}-${R}`
                    , ue = Vc({
                        baseUrl: s,
                        timescale: c,
                        timeline: a,
                        periodStart: D,
                        presentationTime: _,
                        number: L,
                        duration: z,
                        sourceDuration: n,
                        indexRange: F,
                        type: T
                    })[0];
                r && (ue.map = r),
                    v.push(ue),
                    typeof M == "bigint" ? M += ei.default.BigInt(B) : M += B,
                    _ += z / c,
                    L++
            }
            return t.segments = v,
                t
        }
        , E_ = ["AUDIO", "SUBTITLES"], S_ = 1 / 60, zc = t => y_(t, ({ timeline: e }) => e).sort((e, s) => e.timeline > s.timeline ? 1 : -1), C_ = (t, e) => {
            for (let s = 0; s < t.length; s++)
                if (t[s].attributes.NAME === e)
                    return t[s];
            return null
        }
        , Gc = t => {
            let e = [];
            return c_(t, E_, (s, r, n, a) => {
                e = e.concat(s.playlists || [])
            }
            ),
                e
        }
        , Wc = ({ playlist: t, mediaSequence: e }) => {
            t.mediaSequence = e,
                t.segments.forEach((s, r) => {
                    s.number = t.mediaSequence + r
                }
                )
        }
        , A_ = ({ oldPlaylists: t, newPlaylists: e, timelineStarts: s }) => {
            e.forEach(r => {
                r.discontinuitySequence = s.findIndex(function ({ timeline: c }) {
                    return c === r.timeline
                });
                const n = C_(t, r.attributes.NAME);
                if (!n || r.sidx)
                    return;
                const a = r.segments[0]
                    , o = n.segments.findIndex(function (c) {
                        return Math.abs(c.presentationTime - a.presentationTime) < S_
                    });
                if (o === -1) {
                    Wc({
                        playlist: r,
                        mediaSequence: n.mediaSequence + n.segments.length
                    }),
                        r.segments[0].discontinuity = !0,
                        r.discontinuityStarts.unshift(0),
                        (!n.segments.length && r.timeline > n.timeline || n.segments.length && r.timeline > n.segments[n.segments.length - 1].timeline) && r.discontinuitySequence--;
                    return
                }
                n.segments[o].discontinuity && !a.discontinuity && (a.discontinuity = !0,
                    r.discontinuityStarts.unshift(0),
                    r.discontinuitySequence--),
                    Wc({
                        playlist: r,
                        mediaSequence: n.segments[o].number
                    })
            }
            )
        }
        , w_ = ({ oldManifest: t, newManifest: e }) => {
            const s = t.playlists.concat(Gc(t))
                , r = e.playlists.concat(Gc(e));
            return e.timelineStarts = zc([t.timelineStarts, e.timelineStarts]),
                A_({
                    oldPlaylists: s,
                    newPlaylists: r,
                    timelineStarts: e.timelineStarts
                }),
                e
        }
        , qo = t => t && t.uri + "-" + __(t.byterange), mh = t => {
            const e = t.reduce(function (r, n) {
                return r[n.attributes.baseUrl] || (r[n.attributes.baseUrl] = []),
                    r[n.attributes.baseUrl].push(n),
                    r
            }, {});
            let s = [];
            return Object.values(e).forEach(r => {
                const n = Hc(r.reduce((a, o) => {
                    const u = o.attributes.id + (o.attributes.lang || "");
                    return a[u] ? (o.segments && (o.segments[0] && (o.segments[0].discontinuity = !0),
                        a[u].segments.push(...o.segments)),
                        o.attributes.contentProtection && (a[u].attributes.contentProtection = o.attributes.contentProtection)) : (a[u] = o,
                            a[u].attributes.timelineStarts = []),
                        a[u].attributes.timelineStarts.push({
                            start: o.attributes.periodStart,
                            timeline: o.attributes.periodStart
                        }),
                        a
                }
                    , {}));
                s = s.concat(n)
            }
            ),
                s.map(r => (r.discontinuityStarts = v_(r.segments || [], "discontinuity"),
                    r))
        }
        , gh = (t, e) => {
            const s = qo(t.sidx)
                , r = s && e[s] && e[s].sidx;
            return r && ph(t, r, t.sidx.resolvedUri),
                t
        }
        , D_ = (t, e = {}) => {
            if (!Object.keys(e).length)
                return t;
            for (const s in t)
                t[s] = gh(t[s], e);
            return t
        }
        , k_ = ({ attributes: t, segments: e, sidx: s, mediaSequence: r, discontinuitySequence: n, discontinuityStarts: a }, o) => {
            const u = {
                attributes: {
                    NAME: t.id,
                    BANDWIDTH: t.bandwidth,
                    CODECS: t.codecs,
                    "PROGRAM-ID": 1
                },
                uri: "",
                endList: t.type === "static",
                timeline: t.periodStart,
                resolvedUri: t.baseUrl || "",
                targetDuration: t.duration,
                discontinuitySequence: n,
                discontinuityStarts: a,
                timelineStarts: t.timelineStarts,
                mediaSequence: r,
                segments: e
            };
            return t.contentProtection && (u.contentProtection = t.contentProtection),
                t.serviceLocation && (u.attributes.serviceLocation = t.serviceLocation),
                s && (u.sidx = s),
                o && (u.attributes.AUDIO = "audio",
                    u.attributes.SUBTITLES = "subs"),
                u
        }
        , x_ = ({ attributes: t, segments: e, mediaSequence: s, discontinuityStarts: r, discontinuitySequence: n }) => {
            typeof e > "u" && (e = [{
                uri: t.baseUrl,
                timeline: t.periodStart,
                resolvedUri: t.baseUrl || "",
                duration: t.sourceDuration,
                number: 0
            }],
                t.duration = t.sourceDuration);
            const a = {
                NAME: t.id,
                BANDWIDTH: t.bandwidth,
                "PROGRAM-ID": 1
            };
            t.codecs && (a.CODECS = t.codecs);
            const o = {
                attributes: a,
                uri: "",
                endList: t.type === "static",
                timeline: t.periodStart,
                resolvedUri: t.baseUrl || "",
                targetDuration: t.duration,
                timelineStarts: t.timelineStarts,
                discontinuityStarts: r,
                discontinuitySequence: n,
                mediaSequence: s,
                segments: e
            };
            return t.serviceLocation && (o.attributes.serviceLocation = t.serviceLocation),
                o
        }
        , I_ = (t, e = {}, s = !1) => {
            let r;
            const n = t.reduce((a, o) => {
                const u = o.attributes.role && o.attributes.role.value || ""
                    , c = o.attributes.lang || "";
                let f = o.attributes.label || "main";
                if (c && !o.attributes.label) {
                    const T = u ? ` (${u})` : "";
                    f = `${o.attributes.lang}${T}`
                }
                a[f] || (a[f] = {
                    language: c,
                    autoselect: !0,
                    default: u === "main",
                    playlists: [],
                    uri: ""
                });
                const v = gh(k_(o, s), e);
                return a[f].playlists.push(v),
                    typeof r > "u" && u === "main" && (r = o,
                        r.default = !0),
                    a
            }
                , {});
            if (!r) {
                const a = Object.keys(n)[0];
                n[a].default = !0
            }
            return n
        }
        , P_ = (t, e = {}) => t.reduce((s, r) => {
            const n = r.attributes.label || r.attributes.lang || "text";
            return s[n] || (s[n] = {
                language: n,
                default: !1,
                autoselect: !1,
                playlists: [],
                uri: ""
            }),
                s[n].playlists.push(gh(x_(r), e)),
                s
        }
            , {}), L_ = t => t.reduce((e, s) => (s && s.forEach(r => {
                const { channel: n, language: a } = r;
                e[a] = {
                    autoselect: !1,
                    default: !1,
                    instreamId: n,
                    language: a
                },
                    r.hasOwnProperty("aspectRatio") && (e[a].aspectRatio = r.aspectRatio),
                    r.hasOwnProperty("easyReader") && (e[a].easyReader = r.easyReader),
                    r.hasOwnProperty("3D") && (e[a]["3D"] = r["3D"])
            }
            ),
                e), {}), O_ = ({ attributes: t, segments: e, sidx: s, discontinuityStarts: r }) => {
                    const n = {
                        attributes: {
                            NAME: t.id,
                            AUDIO: "audio",
                            SUBTITLES: "subs",
                            RESOLUTION: {
                                width: t.width,
                                height: t.height
                            },
                            CODECS: t.codecs,
                            BANDWIDTH: t.bandwidth,
                            "PROGRAM-ID": 1
                        },
                        uri: "",
                        endList: t.type === "static",
                        timeline: t.periodStart,
                        resolvedUri: t.baseUrl || "",
                        targetDuration: t.duration,
                        discontinuityStarts: r,
                        timelineStarts: t.timelineStarts,
                        segments: e
                    };
                    return t.frameRate && (n.attributes["FRAME-RATE"] = t.frameRate),
                        t.contentProtection && (n.contentProtection = t.contentProtection),
                        t.serviceLocation && (n.attributes.serviceLocation = t.serviceLocation),
                        s && (n.sidx = s),
                        n
                }
        , M_ = ({ attributes: t }) => t.mimeType === "video/mp4" || t.mimeType === "video/webm" || t.contentType === "video", R_ = ({ attributes: t }) => t.mimeType === "audio/mp4" || t.mimeType === "audio/webm" || t.contentType === "audio", N_ = ({ attributes: t }) => t.mimeType === "text/vtt" || t.contentType === "text", B_ = (t, e) => {
            t.forEach(s => {
                s.mediaSequence = 0,
                    s.discontinuitySequence = e.findIndex(function ({ timeline: r }) {
                        return r === s.timeline
                    }),
                    s.segments && s.segments.forEach((r, n) => {
                        r.number = n
                    }
                    )
            }
            )
        }
        , Kc = t => t ? Object.keys(t).reduce((e, s) => {
            const r = t[s];
            return e.concat(r.playlists)
        }
            , []) : [], F_ = ({ dashPlaylists: t, locations: e, contentSteering: s, sidxMapping: r = {}, previousManifest: n, eventStream: a }) => {
                if (!t.length)
                    return {};
                const { sourceDuration: o, type: u, suggestedPresentationDelay: c, minimumUpdatePeriod: f } = t[0].attributes
                    , v = mh(t.filter(M_)).map(O_)
                    , T = mh(t.filter(R_))
                    , D = mh(t.filter(N_))
                    , _ = t.map(R => R.attributes.captionServices).filter(Boolean)
                    , L = {
                        allowCache: !0,
                        discontinuityStarts: [],
                        segments: [],
                        endList: !0,
                        mediaGroups: {
                            AUDIO: {},
                            VIDEO: {},
                            "CLOSED-CAPTIONS": {},
                            SUBTITLES: {}
                        },
                        uri: "",
                        duration: o,
                        playlists: D_(v, r)
                    };
                f >= 0 && (L.minimumUpdatePeriod = f * 1e3),
                    e && (L.locations = e),
                    s && (L.contentSteering = s),
                    u === "dynamic" && (L.suggestedPresentationDelay = c),
                    a && a.length > 0 && (L.eventStream = a);
                const M = L.playlists.length === 0
                    , N = T.length ? I_(T, r, M) : null
                    , x = D.length ? P_(D, r) : null
                    , B = v.concat(Kc(N), Kc(x))
                    , z = B.map(({ timelineStarts: R }) => R);
                return L.timelineStarts = zc(z),
                    B_(B, L.timelineStarts),
                    N && (L.mediaGroups.AUDIO.audio = N),
                    x && (L.mediaGroups.SUBTITLES.subs = x),
                    _.length && (L.mediaGroups["CLOSED-CAPTIONS"].cc = L_(_)),
                    n ? w_({
                        oldManifest: n,
                        newManifest: L
                    }) : L
            }
        , U_ = (t, e, s) => {
            const { NOW: r, clientOffset: n, availabilityStartTime: a, timescale: o = 1, periodStart: u = 0, minimumUpdatePeriod: c = 0 } = t
                , f = (r + n) / 1e3
                , v = a + u
                , D = f + c - v;
            return Math.ceil((D * o - e) / s)
        }
        , Xc = (t, e) => {
            const { type: s, minimumUpdatePeriod: r = 0, media: n = "", sourceDuration: a, timescale: o = 1, startNumber: u = 1, periodStart: c } = t
                , f = [];
            let v = -1;
            for (let T = 0; T < e.length; T++) {
                const D = e[T]
                    , _ = D.d
                    , L = D.r || 0
                    , M = D.t || 0;
                v < 0 && (v = M),
                    M && M > v && (v = M);
                let N;
                if (L < 0) {
                    const z = T + 1;
                    z === e.length ? s === "dynamic" && r > 0 && n.indexOf("$Number$") > 0 ? N = U_(t, v, _) : N = (a * o - v) / _ : N = (e[z].t - v) / _
                } else
                    N = L + 1;
                const x = u + f.length + N;
                let B = u + f.length;
                for (; B < x;)
                    f.push({
                        number: B,
                        duration: _ / o,
                        time: v,
                        timeline: c
                    }),
                        v += _,
                        B++
            }
            return f
        }
        , j_ = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g, H_ = t => (e, s, r, n) => {
            if (e === "$$")
                return "$";
            if (typeof t[s] > "u")
                return e;
            const a = "" + t[s];
            return s === "RepresentationID" || (r ? n = parseInt(n, 10) : n = 1,
                a.length >= n) ? a : `${new Array(n - a.length + 1).join("0")}${a}`
        }
        , Yc = (t, e) => t.replace(j_, H_(e)), q_ = (t, e) => !t.duration && !e ? [{
            number: t.startNumber || 1,
            duration: t.sourceDuration,
            time: 0,
            timeline: t.periodStart
        }] : t.duration ? fh(t) : Xc(t, e), $_ = (t, e) => {
            const s = {
                RepresentationID: t.id,
                Bandwidth: t.bandwidth || 0
            }
                , { initialization: r = {
                    sourceURL: "",
                    range: ""
                } } = t
                , n = ga({
                    baseUrl: t.baseUrl,
                    source: Yc(r.sourceURL, s),
                    range: r.range
                });
            return q_(t, e).map(o => {
                s.Number = o.number,
                    s.Time = o.time;
                const u = Yc(t.media || "", s)
                    , c = t.timescale || 1
                    , f = t.presentationTimeOffset || 0
                    , v = t.periodStart + (o.time - f) / c;
                return {
                    uri: u,
                    timeline: o.timeline,
                    duration: o.duration,
                    resolvedUri: jo(t.baseUrl || "", u),
                    map: n,
                    number: o.number,
                    presentationTime: v
                }
            }
            )
        }
        , V_ = (t, e) => {
            const { baseUrl: s, initialization: r = {} } = t
                , n = ga({
                    baseUrl: s,
                    source: r.sourceURL,
                    range: r.range
                })
                , a = ga({
                    baseUrl: s,
                    source: e.media,
                    range: e.mediaRange
                });
            return a.map = n,
                a
        }
        , z_ = (t, e) => {
            const { duration: s, segmentUrls: r = [], periodStart: n } = t;
            if (!s && !e || s && e)
                throw new Error(en.SEGMENT_TIME_UNSPECIFIED);
            const a = r.map(c => V_(t, c));
            let o;
            return s && (o = fh(t)),
                e && (o = Xc(t, e)),
                o.map((c, f) => {
                    if (a[f]) {
                        const v = a[f]
                            , T = t.timescale || 1
                            , D = t.presentationTimeOffset || 0;
                        return v.timeline = c.timeline,
                            v.duration = c.duration,
                            v.number = c.number,
                            v.presentationTime = n + (c.time - D) / T,
                            v
                    }
                }
                ).filter(c => c)
        }
        , G_ = ({ attributes: t, segmentInfo: e }) => {
            let s, r;
            e.template ? (r = $_,
                s = pt(t, e.template)) : e.base ? (r = Vc,
                    s = pt(t, e.base)) : e.list && (r = z_,
                        s = pt(t, e.list));
            const n = {
                attributes: t
            };
            if (!r)
                return n;
            const a = r(s, e.segmentTimeline);
            if (s.duration) {
                const { duration: o, timescale: u = 1 } = s;
                s.duration = o / u
            } else
                a.length ? s.duration = a.reduce((o, u) => Math.max(o, Math.ceil(u.duration)), 0) : s.duration = 0;
            return n.attributes = s,
                n.segments = a,
                e.base && s.indexRange && (n.sidx = a[0],
                    n.segments = []),
                n
        }
        , W_ = t => t.map(G_), Ye = (t, e) => qc(t.childNodes).filter(({ tagName: s }) => s === e), va = t => t.textContent.trim(), K_ = t => parseFloat(t.split("/").reduce((e, s) => e / s)), tn = t => {
            const u = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/.exec(t);
            if (!u)
                return 0;
            const [c, f, v, T, D, _] = u.slice(1);
            return parseFloat(c || 0) * 31536e3 + parseFloat(f || 0) * 2592e3 + parseFloat(v || 0) * 86400 + parseFloat(T || 0) * 3600 + parseFloat(D || 0) * 60 + parseFloat(_ || 0)
        }
        , X_ = t => (/^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/.test(t) && (t += "Z"),
            Date.parse(t)), Qc = {
                mediaPresentationDuration(t) {
                    return tn(t)
                },
                availabilityStartTime(t) {
                    return X_(t) / 1e3
                },
                minimumUpdatePeriod(t) {
                    return tn(t)
                },
                suggestedPresentationDelay(t) {
                    return tn(t)
                },
                type(t) {
                    return t
                },
                timeShiftBufferDepth(t) {
                    return tn(t)
                },
                start(t) {
                    return tn(t)
                },
                width(t) {
                    return parseInt(t, 10)
                },
                height(t) {
                    return parseInt(t, 10)
                },
                bandwidth(t) {
                    return parseInt(t, 10)
                },
                frameRate(t) {
                    return K_(t)
                },
                startNumber(t) {
                    return parseInt(t, 10)
                },
                timescale(t) {
                    return parseInt(t, 10)
                },
                presentationTimeOffset(t) {
                    return parseInt(t, 10)
                },
                duration(t) {
                    const e = parseInt(t, 10);
                    return isNaN(e) ? tn(t) : e
                },
                d(t) {
                    return parseInt(t, 10)
                },
                t(t) {
                    return parseInt(t, 10)
                },
                r(t) {
                    return parseInt(t, 10)
                },
                presentationTime(t) {
                    return parseInt(t, 10)
                },
                DEFAULT(t) {
                    return t
                }
            }, lt = t => t && t.attributes ? qc(t.attributes).reduce((e, s) => {
                const r = Qc[s.name] || Qc.DEFAULT;
                return e[s.name] = r(s.value),
                    e
            }
                , {}) : {}, Y_ = {
                    "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
                    "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
                    "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
                    "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime",
                    "urn:mpeg:dash:mp4protection:2011": "mp4protection"
                }, $o = (t, e) => e.length ? Zr(t.map(function (s) {
                    return e.map(function (r) {
                        const n = va(r)
                            , a = jo(s.baseUrl, n)
                            , o = pt(lt(r), {
                                baseUrl: a
                            });
                        return a !== n && !o.serviceLocation && s.serviceLocation && (o.serviceLocation = s.serviceLocation),
                            o
                    })
                })) : t, vh = t => {
                    const e = Ye(t, "SegmentTemplate")[0]
                        , s = Ye(t, "SegmentList")[0]
                        , r = s && Ye(s, "SegmentURL").map(T => pt({
                            tag: "SegmentURL"
                        }, lt(T)))
                        , n = Ye(t, "SegmentBase")[0]
                        , a = s || e
                        , o = a && Ye(a, "SegmentTimeline")[0]
                        , u = s || n || e
                        , c = u && Ye(u, "Initialization")[0]
                        , f = e && lt(e);
                    f && c ? f.initialization = c && lt(c) : f && f.initialization && (f.initialization = {
                        sourceURL: f.initialization
                    });
                    const v = {
                        template: f,
                        segmentTimeline: o && Ye(o, "S").map(T => lt(T)),
                        list: s && pt(lt(s), {
                            segmentUrls: r,
                            initialization: lt(c)
                        }),
                        base: n && pt(lt(n), {
                            initialization: lt(c)
                        })
                    };
                    return Object.keys(v).forEach(T => {
                        v[T] || delete v[T]
                    }
                    ),
                        v
                }
        , Q_ = (t, e, s) => r => {
            const n = Ye(r, "BaseURL")
                , a = $o(e, n)
                , o = pt(t, lt(r))
                , u = vh(r);
            return a.map(c => ({
                segmentInfo: pt(s, u),
                attributes: pt(o, c)
            }))
        }
        , J_ = t => t.reduce((e, s) => {
            const r = lt(s);
            r.schemeIdUri && (r.schemeIdUri = r.schemeIdUri.toLowerCase());
            const n = Y_[r.schemeIdUri];
            if (n) {
                e[n] = {
                    attributes: r
                };
                const a = Ye(s, "cenc:pssh")[0];
                if (a) {
                    const o = va(a);
                    e[n].pssh = o && p_(o)
                }
            }
            return e
        }
            , {}), Z_ = t => {
                if (t.schemeIdUri === "urn:scte:dash:cc:cea-608:2015")
                    return (typeof t.value != "string" ? [] : t.value.split(";")).map(s => {
                        let r, n;
                        return n = s,
                            /^CC\d=/.test(s) ? [r, n] = s.split("=") : /^CC\d$/.test(s) && (r = s),
                        {
                            channel: r,
                            language: n
                        }
                    }
                    );
                if (t.schemeIdUri === "urn:scte:dash:cc:cea-708:2015")
                    return (typeof t.value != "string" ? [] : t.value.split(";")).map(s => {
                        const r = {
                            channel: void 0,
                            language: void 0,
                            aspectRatio: 1,
                            easyReader: 0,
                            "3D": 0
                        };
                        if (/=/.test(s)) {
                            const [n, a = ""] = s.split("=");
                            r.channel = n,
                                r.language = s,
                                a.split(",").forEach(o => {
                                    const [u, c] = o.split(":");
                                    u === "lang" ? r.language = c : u === "er" ? r.easyReader = Number(c) : u === "war" ? r.aspectRatio = Number(c) : u === "3D" && (r["3D"] = Number(c))
                                }
                                )
                        } else
                            r.language = s;
                        return r.channel && (r.channel = "SERVICE" + r.channel),
                            r
                    }
                    )
            }
        , e0 = t => Zr(Ye(t.node, "EventStream").map(e => {
            const s = lt(e)
                , r = s.schemeIdUri;
            return Ye(e, "Event").map(n => {
                const a = lt(n)
                    , o = a.presentationTime || 0
                    , u = s.timescale || 1
                    , c = a.duration || 0
                    , f = o / u + t.attributes.start;
                return {
                    schemeIdUri: r,
                    value: s.value,
                    id: a.id,
                    start: f,
                    end: f + c / u,
                    messageData: va(n) || a.messageData,
                    contentEncoding: s.contentEncoding,
                    presentationTimeOffset: s.presentationTimeOffset || 0
                }
            }
            )
        }
        )), t0 = (t, e, s) => r => {
            const n = lt(r)
                , a = $o(e, Ye(r, "BaseURL"))
                , o = Ye(r, "Role")[0]
                , u = {
                    role: lt(o)
                };
            let c = pt(t, n, u);
            const f = Ye(r, "Accessibility")[0]
                , v = Z_(lt(f));
            v && (c = pt(c, {
                captionServices: v
            }));
            const T = Ye(r, "Label")[0];
            if (T && T.childNodes.length) {
                const N = T.childNodes[0].nodeValue.trim();
                c = pt(c, {
                    label: N
                })
            }
            const D = J_(Ye(r, "ContentProtection"));
            Object.keys(D).length && (c = pt(c, {
                contentProtection: D
            }));
            const _ = vh(r)
                , L = Ye(r, "Representation")
                , M = pt(s, _);
            return Zr(L.map(Q_(c, a, M)))
        }
        , i0 = (t, e) => (s, r) => {
            const n = $o(e, Ye(s.node, "BaseURL"))
                , a = pt(t, {
                    periodStart: s.attributes.start
                });
            typeof s.attributes.duration == "number" && (a.periodDuration = s.attributes.duration);
            const o = Ye(s.node, "AdaptationSet")
                , u = vh(s.node);
            return Zr(o.map(t0(a, n, u)))
        }
        , s0 = (t, e) => {
            if (t.length > 1 && e({
                type: "warn",
                message: "The MPD manifest should contain no more than one ContentSteering tag"
            }),
                !t.length)
                return null;
            const s = pt({
                serverURL: va(t[0])
            }, lt(t[0]));
            return s.queryBeforeStart = s.queryBeforeStart === "true",
                s
        }
        , r0 = ({ attributes: t, priorPeriodAttributes: e, mpdType: s }) => typeof t.start == "number" ? t.start : e && typeof e.start == "number" && typeof e.duration == "number" ? e.start + e.duration : !e && s === "static" ? 0 : null, n0 = (t, e = {}) => {
            const { manifestUri: s = "", NOW: r = Date.now(), clientOffset: n = 0, eventHandler: a = function () { }
            } = e
                , o = Ye(t, "Period");
            if (!o.length)
                throw new Error(en.INVALID_NUMBER_OF_PERIOD);
            const u = Ye(t, "Location")
                , c = lt(t)
                , f = $o([{
                    baseUrl: s
                }], Ye(t, "BaseURL"))
                , v = Ye(t, "ContentSteering");
            c.type = c.type || "static",
                c.sourceDuration = c.mediaPresentationDuration || 0,
                c.NOW = r,
                c.clientOffset = n,
                u.length && (c.locations = u.map(va));
            const T = [];
            return o.forEach((D, _) => {
                const L = lt(D)
                    , M = T[_ - 1];
                L.start = r0({
                    attributes: L,
                    priorPeriodAttributes: M ? M.attributes : null,
                    mpdType: c.type
                }),
                    T.push({
                        node: D,
                        attributes: L
                    })
            }
            ),
            {
                locations: c.locations,
                contentSteeringInfo: s0(v, a),
                representationInfo: Zr(T.map(i0(c, f))),
                eventStream: Zr(T.map(e0))
            }
        }
        , Jc = t => {
            if (t === "")
                throw new Error(en.DASH_EMPTY_MANIFEST);
            const e = new m_.DOMParser;
            let s, r;
            try {
                s = e.parseFromString(t, "application/xml"),
                    r = s && s.documentElement.tagName === "MPD" ? s.documentElement : null
            } catch (n) { }
            if (!r || r && r.getElementsByTagName("parsererror").length > 0)
                throw new Error(en.DASH_INVALID_XML);
            return r
        }
        , a0 = t => {
            const e = Ye(t, "UTCTiming")[0];
            if (!e)
                return null;
            const s = lt(e);
            switch (s.schemeIdUri) {
                case "urn:mpeg:dash:utc:http-head:2014":
                case "urn:mpeg:dash:utc:http-head:2012":
                    s.method = "HEAD";
                    break;
                case "urn:mpeg:dash:utc:http-xsdate:2014":
                case "urn:mpeg:dash:utc:http-iso:2014":
                case "urn:mpeg:dash:utc:http-xsdate:2012":
                case "urn:mpeg:dash:utc:http-iso:2012":
                    s.method = "GET";
                    break;
                case "urn:mpeg:dash:utc:direct:2014":
                case "urn:mpeg:dash:utc:direct:2012":
                    s.method = "DIRECT",
                        s.value = Date.parse(s.value);
                    break;
                case "urn:mpeg:dash:utc:http-ntp:2014":
                case "urn:mpeg:dash:utc:ntp:2014":
                case "urn:mpeg:dash:utc:sntp:2014":
                default:
                    throw new Error(en.UNSUPPORTED_UTC_TIMING_SCHEME)
            }
            return s
        }
        , o0 = (t, e = {}) => {
            const s = n0(Jc(t), e)
                , r = W_(s.representationInfo);
            return F_({
                dashPlaylists: r,
                locations: s.locations,
                contentSteering: s.contentSteeringInfo,
                sidxMapping: e.sidxMapping,
                previousManifest: e.previousManifest,
                eventStream: s.eventStream
            })
        }
        , l0 = t => a0(Jc(t)), u0 = _t(Uy()), h0 = ye([73, 68, 51]), d0 = function (e, s) {
            s === void 0 && (s = 0),
                e = ye(e);
            var r = e[s + 5]
                , n = e[s + 6] << 21 | e[s + 7] << 14 | e[s + 8] << 7 | e[s + 9]
                , a = (r & 16) >> 4;
            return a ? n + 20 : n + 10
        }, ya = function t(e, s) {
            return s === void 0 && (s = 0),
                e = ye(e),
                e.length - s < 10 || !Xe(e, h0, {
                    offset: s
                }) ? s : (s += d0(e, s),
                    t(e, s))
        }, mC = new Uint8Array([79, 112, 117, 115, 72, 101, 97, 100]), Zc = function (e) {
            return typeof e == "string" ? Fc(e) : e
        }, c0 = function (e) {
            return Array.isArray(e) ? e.map(function (s) {
                return Zc(s)
            }) : [Zc(e)]
        }, yh, ef = function (e) {
            e = ye(e);
            for (var s = [], r = 0; e.length > r;) {
                var n = e[r]
                    , a = 0
                    , o = 0;
                o++;
                var u = e[o];
                for (o++; u & 128;)
                    a = (u & 127) << 7,
                        u = e[o],
                        o++;
                a += u & 127;
                for (var c = 0; c < yh.length; c++) {
                    var f = yh[c]
                        , v = f.id
                        , T = f.parser;
                    if (n === v) {
                        s.push(T(e.subarray(o, o + a)));
                        break
                    }
                }
                r += a + o
            }
            return s
        };
    yh = [{
        id: 3,
        parser: function (e) {
            var s = {
                tag: 3,
                id: e[0] << 8 | e[1],
                flags: e[2],
                size: 3,
                dependsOnEsId: 0,
                ocrEsId: 0,
                descriptors: [],
                url: ""
            };
            if (s.flags & 128 && (s.dependsOnEsId = e[s.size] << 8 | e[s.size + 1],
                s.size += 2),
                s.flags & 64) {
                var r = e[s.size];
                s.url = h_(e.subarray(s.size + 1, s.size + 1 + r)),
                    s.size += r
            }
            return s.flags & 32 && (s.ocrEsId = e[s.size] << 8 | e[s.size + 1],
                s.size += 2),
                s.descriptors = ef(e.subarray(s.size)) || [],
                s
        }
    }, {
        id: 4,
        parser: function (e) {
            var s = {
                tag: 4,
                oti: e[0],
                streamType: e[1],
                bufferSize: e[2] << 16 | e[3] << 8 | e[4],
                maxBitrate: e[5] << 24 | e[6] << 16 | e[7] << 8 | e[8],
                avgBitrate: e[9] << 24 | e[10] << 16 | e[11] << 8 | e[12],
                descriptors: ef(e.subarray(13))
            };
            return s
        }
    }, {
        id: 5,
        parser: function (e) {
            return {
                tag: 5,
                bytes: e
            }
        }
    }, {
        id: 6,
        parser: function (e) {
            return {
                tag: 6,
                bytes: e
            }
        }
    }];
    var f0 = function t(e, s, r) {
        r === void 0 && (r = !1),
            s = c0(s),
            e = ye(e);
        var n = [];
        if (!s.length)
            return n;
        for (var a = 0; a < e.length;) {
            var o = (e[a] << 24 | e[a + 1] << 16 | e[a + 2] << 8 | e[a + 3]) >>> 0
                , u = e.subarray(a + 4, a + 8);
            if (o === 0)
                break;
            var c = a + o;
            if (c > e.length) {
                if (r)
                    break;
                c = e.length
            }
            var f = e.subarray(a + 8, c);
            Xe(u, s[0]) && (s.length === 1 ? n.push(f) : n.push.apply(n, t(f, s.slice(1), r))),
                a = c
        }
        return n
    }
        , Vo = {
            EBML: ye([26, 69, 223, 163]),
            DocType: ye([66, 130]),
            Segment: ye([24, 83, 128, 103]),
            SegmentInfo: ye([21, 73, 169, 102]),
            Tracks: ye([22, 84, 174, 107]),
            Track: ye([174]),
            TrackNumber: ye([215]),
            DefaultDuration: ye([35, 227, 131]),
            TrackEntry: ye([174]),
            TrackType: ye([131]),
            FlagDefault: ye([136]),
            CodecID: ye([134]),
            CodecPrivate: ye([99, 162]),
            VideoTrack: ye([224]),
            AudioTrack: ye([225]),
            Cluster: ye([31, 67, 182, 117]),
            Timestamp: ye([231]),
            TimestampScale: ye([42, 215, 177]),
            BlockGroup: ye([160]),
            BlockDuration: ye([155]),
            Block: ye([161]),
            SimpleBlock: ye([163])
        }
        , _h = [128, 64, 32, 16, 8, 4, 2, 1]
        , p0 = function (e) {
            for (var s = 1, r = 0; r < _h.length && !(e & _h[r]); r++)
                s++;
            return s
        }
        , zo = function (e, s, r, n) {
            r === void 0 && (r = !0),
                n === void 0 && (n = !1);
            var a = p0(e[s])
                , o = e.subarray(s, s + a);
            return r && (o = Array.prototype.slice.call(e, s, s + a),
                o[0] ^= _h[a - 1]),
            {
                length: a,
                value: l_(o, {
                    signed: n
                }),
                bytes: o
            }
        }
        , tf = function t(e) {
            return typeof e == "string" ? e.match(/.{1,2}/g).map(function (s) {
                return t(s)
            }) : typeof e == "number" ? u_(e) : e
        }
        , m0 = function (e) {
            return Array.isArray(e) ? e.map(function (s) {
                return tf(s)
            }) : [tf(e)]
        }
        , g0 = function t(e, s, r) {
            if (r >= s.length)
                return s.length;
            var n = zo(s, r, !1);
            if (Xe(e.bytes, n.bytes))
                return r;
            var a = zo(s, r + n.length);
            return t(e, s, r + a.length + a.value + n.length)
        }
        , sf = function t(e, s) {
            s = m0(s),
                e = ye(e);
            var r = [];
            if (!s.length)
                return r;
            for (var n = 0; n < e.length;) {
                var a = zo(e, n, !1)
                    , o = zo(e, n + a.length)
                    , u = n + a.length + o.length;
                o.value === 127 && (o.value = g0(a, e, u),
                    o.value !== e.length && (o.value -= u));
                var c = u + o.value > e.length ? e.length : u + o.value
                    , f = e.subarray(u, c);
                Xe(s[0], a.bytes) && (s.length === 1 ? r.push(f) : r = r.concat(t(f, s.slice(1))));
                var v = a.length + o.length + f.length;
                n += v
            }
            return r
        }
        , v0 = ye([0, 0, 0, 1])
        , y0 = ye([0, 0, 1])
        , _0 = ye([0, 0, 3])
        , T0 = function (e) {
            for (var s = [], r = 1; r < e.length - 2;)
                Xe(e.subarray(r, r + 3), _0) && (s.push(r + 2),
                    r++),
                    r++;
            if (s.length === 0)
                return e;
            var n = e.length - s.length
                , a = new Uint8Array(n)
                , o = 0;
            for (r = 0; r < n; o++,
                r++)
                o === s[0] && (o++,
                    s.shift()),
                    a[r] = e[o];
            return a
        }
        , rf = function (e, s, r, n) {
            n === void 0 && (n = 1 / 0),
                e = ye(e),
                r = [].concat(r);
            for (var a = 0, o, u = 0; a < e.length && (u < n || o);) {
                var c = void 0;
                if (Xe(e.subarray(a), v0) ? c = 4 : Xe(e.subarray(a), y0) && (c = 3),
                    !c) {
                    a++;
                    continue
                }
                if (u++,
                    o)
                    return T0(e.subarray(o, a));
                var f = void 0;
                s === "h264" ? f = e[a + c] & 31 : s === "h265" && (f = e[a + c] >> 1 & 63),
                    r.indexOf(f) !== -1 && (o = a + c),
                    a += c + (s === "h264" ? 1 : 2)
            }
            return e.subarray(0, 0)
        }
        , b0 = function (e, s, r) {
            return rf(e, "h264", s, r)
        }
        , E0 = function (e, s, r) {
            return rf(e, "h265", s, r)
        }
        , Ut = {
            webm: ye([119, 101, 98, 109]),
            matroska: ye([109, 97, 116, 114, 111, 115, 107, 97]),
            flac: ye([102, 76, 97, 67]),
            ogg: ye([79, 103, 103, 83]),
            ac3: ye([11, 119]),
            riff: ye([82, 73, 70, 70]),
            avi: ye([65, 86, 73]),
            wav: ye([87, 65, 86, 69]),
            "3gp": ye([102, 116, 121, 112, 51, 103]),
            mp4: ye([102, 116, 121, 112]),
            fmp4: ye([115, 116, 121, 112]),
            mov: ye([102, 116, 121, 112, 113, 116]),
            moov: ye([109, 111, 111, 118]),
            moof: ye([109, 111, 111, 102])
        }
        , sn = {
            aac: function (e) {
                var s = ya(e);
                return Xe(e, [255, 16], {
                    offset: s,
                    mask: [255, 22]
                })
            },
            mp3: function (e) {
                var s = ya(e);
                return Xe(e, [255, 2], {
                    offset: s,
                    mask: [255, 6]
                })
            },
            webm: function (e) {
                var s = sf(e, [Vo.EBML, Vo.DocType])[0];
                return Xe(s, Ut.webm)
            },
            mkv: function (e) {
                var s = sf(e, [Vo.EBML, Vo.DocType])[0];
                return Xe(s, Ut.matroska)
            },
            mp4: function (e) {
                if (sn["3gp"](e) || sn.mov(e))
                    return !1;
                if (Xe(e, Ut.mp4, {
                    offset: 4
                }) || Xe(e, Ut.fmp4, {
                    offset: 4
                }) || Xe(e, Ut.moof, {
                    offset: 4
                }) || Xe(e, Ut.moov, {
                    offset: 4
                }))
                    return !0
            },
            mov: function (e) {
                return Xe(e, Ut.mov, {
                    offset: 4
                })
            },
            "3gp": function (e) {
                return Xe(e, Ut["3gp"], {
                    offset: 4
                })
            },
            ac3: function (e) {
                var s = ya(e);
                return Xe(e, Ut.ac3, {
                    offset: s
                })
            },
            ts: function (e) {
                if (e.length < 189 && e.length >= 1)
                    return e[0] === 71;
                for (var s = 0; s + 188 < e.length && s < 188;) {
                    if (e[s] === 71 && e[s + 188] === 71)
                        return !0;
                    s += 1
                }
                return !1
            },
            flac: function (e) {
                var s = ya(e);
                return Xe(e, Ut.flac, {
                    offset: s
                })
            },
            ogg: function (e) {
                return Xe(e, Ut.ogg)
            },
            avi: function (e) {
                return Xe(e, Ut.riff) && Xe(e, Ut.avi, {
                    offset: 8
                })
            },
            wav: function (e) {
                return Xe(e, Ut.riff) && Xe(e, Ut.wav, {
                    offset: 8
                })
            },
            h264: function (e) {
                return b0(e, 7, 3).length
            },
            h265: function (e) {
                return E0(e, [32, 33], 3).length
            }
        }
        , Th = Object.keys(sn).filter(function (t) {
            return t !== "ts" && t !== "h264" && t !== "h265"
        }).concat(["ts", "h264", "h265"]);
    Th.forEach(function (t) {
        var e = sn[t];
        sn[t] = function (s) {
            return e(ye(s))
        }
    });
    var S0 = sn, bh = function (e) {
        e = ye(e);
        for (var s = 0; s < Th.length; s++) {
            var r = Th[s];
            if (S0[r](e))
                return r
        }
        return ""
    }, C0 = function (e) {
        return f0(e, ["moof"]).length > 0
    }, Go = _t(jy()), nf = "8.8.0", _s = {}, $s = function (t, e) {
        return _s[t] = _s[t] || [],
            e && (_s[t] = _s[t].concat(e)),
            _s[t]
    }, A0 = function (t, e) {
        $s(t, e)
    }, af = function (t, e) {
        const s = $s(t).indexOf(e);
        return s <= -1 ? !1 : (_s[t] = _s[t].slice(),
            _s[t].splice(s, 1),
            !0)
    }, w0 = function (t, e) {
        $s(t, [].concat(e).map(s => {
            const r = (...n) => (af(t, r),
                s(...n));
            return r
        }
        ))
    }, Wo = {
        prefixed: !0
    }, Ko = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen"]], of = Ko[0], _a;
    for (let t = 0; t < Ko.length; t++)
        if (Ko[t][1] in le.default) {
            _a = Ko[t];
            break
        }
    if (_a) {
        for (let t = 0; t < _a.length; t++)
            Wo[of[t]] = _a[t];
        Wo.prefixed = _a[0] !== of[0]
    }
    var ti = []
        , D0 = (t, e, s) => (r, n, a) => {
            const o = e.levels[n]
                , u = new RegExp(`^(${o})$`);
            let c = t;
            if (r !== "log" && a.unshift(r.toUpperCase() + ":"),
                s && (c = `%c${t}`,
                    a.unshift(s)),
                a.unshift(c + ":"),
                ti) {
                ti.push([].concat(a));
                const v = ti.length - 1e3;
                ti.splice(0, v > 0 ? v : 0)
            }
            if (!O.default.console)
                return;
            let f = O.default.console[r];
            !f && r === "debug" && (f = O.default.console.info || O.default.console.log),
                !(!f || !o || !u.test(r)) && f[Array.isArray(a) ? "apply" : "call"](O.default.console, a)
        }
        ;
    function Eh(t, e = ":", s = "") {
        let r = "info", n;
        const a = function (...o) {
            n("log", r, o)
        };
        return n = D0(t, a, s),
            a.createLogger = (o, u, c) => {
                const f = u !== void 0 ? u : e
                    , v = c !== void 0 ? c : s
                    , T = `${t} ${f} ${o}`;
                return Eh(T, f, v)
            }
            ,
            a.createNewLogger = (o, u, c) => Eh(o, u, c),
            a.levels = {
                all: "debug|log|warn|error",
                off: "",
                debug: "debug|log|warn|error",
                info: "log|warn|error",
                warn: "warn|error",
                error: "error",
                DEFAULT: r
            },
            a.level = o => {
                if (typeof o == "string") {
                    if (!a.levels.hasOwnProperty(o))
                        throw new Error(`"${o}" in not a valid log level`);
                    r = o
                }
                return r
            }
            ,
            a.history = () => ti ? [].concat(ti) : [],
            a.history.filter = o => (ti || []).filter(u => new RegExp(`.*${o}.*`).test(u[0])),
            a.history.clear = () => {
                ti && (ti.length = 0)
            }
            ,
            a.history.disable = () => {
                ti !== null && (ti.length = 0,
                    ti = null)
            }
            ,
            a.history.enable = () => {
                ti === null && (ti = [])
            }
            ,
            a.error = (...o) => n("error", r, o),
            a.warn = (...o) => n("warn", r, o),
            a.debug = (...o) => n("debug", r, o),
            a
    }
    var Ie = Eh("VIDEOJS")
        , lf = Ie.createLogger
        , k0 = Object.prototype.toString
        , uf = function (t) {
            return Yi(t) ? Object.keys(t) : []
        };
    function rn(t, e) {
        uf(t).forEach(s => e(t[s], s))
    }
    function hf(t, e, s = 0) {
        return uf(t).reduce((r, n) => e(r, t[n], n), s)
    }
    function Yi(t) {
        return !!t && typeof t == "object"
    }
    function nn(t) {
        return Yi(t) && k0.call(t) === "[object Object]" && t.constructor === Object
    }
    function ze(...t) {
        const e = {};
        return t.forEach(s => {
            s && rn(s, (r, n) => {
                if (!nn(r)) {
                    e[n] = r;
                    return
                }
                nn(e[n]) || (e[n] = {}),
                    e[n] = ze(e[n], r)
            }
            )
        }
        ),
            e
    }
    function df(t = {}) {
        const e = [];
        for (const s in t)
            if (t.hasOwnProperty(s)) {
                const r = t[s];
                e.push(r)
            }
        return e
    }
    function Xo(t, e, s, r = !0) {
        const n = o => Object.defineProperty(t, e, {
            value: o,
            enumerable: !0,
            writable: !0
        })
            , a = {
                configurable: !0,
                enumerable: !0,
                get() {
                    const o = s();
                    return n(o),
                        o
                }
            };
        return r && (a.set = n),
            Object.defineProperty(t, e, a)
    }
    var x0 = Object.freeze({
        __proto__: null,
        each: rn,
        reduce: hf,
        isObject: Yi,
        isPlain: nn,
        merge: ze,
        values: df,
        defineLazyProperty: Xo
    }), Sh = !1, cf = null, Qi = !1, ff, pf = !1, an = !1, on = !1, Ji = !1, Ch = null, Yo = null, mf = null, Qo = !1, Jo = !1, Zo = !1, el = !1, Ta = !!(ln() && ("ontouchstart" in O.default || O.default.navigator.maxTouchPoints || O.default.DocumentTouch && O.default.document instanceof O.default.DocumentTouch)), Vs = O.default.navigator && O.default.navigator.userAgentData;
    if (Vs && Vs.platform && Vs.brands && (Qi = Vs.platform === "Android",
        an = !!Vs.brands.find(t => t.brand === "Microsoft Edge"),
        on = !!Vs.brands.find(t => t.brand === "Chromium"),
        Ji = !an && on,
        Ch = Yo = (Vs.brands.find(t => t.brand === "Chromium") || {}).version || null,
        Jo = Vs.platform === "Windows"),
        !on) {
        const t = O.default.navigator && O.default.navigator.userAgent || "";
        Sh = /iPod/i.test(t),
            cf = function () {
                const e = t.match(/OS (\d+)_/i);
                return e && e[1] ? e[1] : null
            }(),
            Qi = /Android/i.test(t),
            ff = function () {
                const e = t.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
                if (!e)
                    return null;
                const s = e[1] && parseFloat(e[1])
                    , r = e[2] && parseFloat(e[2]);
                return s && r ? parseFloat(e[1] + "." + e[2]) : s || null
            }(),
            pf = /Firefox/i.test(t),
            an = /Edg/i.test(t),
            on = /Chrome/i.test(t) || /CriOS/i.test(t),
            Ji = !an && on,
            Ch = Yo = function () {
                const e = t.match(/(Chrome|CriOS)\/(\d+)/);
                return e && e[2] ? parseFloat(e[2]) : null
            }(),
            mf = function () {
                const e = /MSIE\s(\d+)\.\d/.exec(t);
                let s = e && parseFloat(e[1]);
                return !s && /Trident\/7.0/i.test(t) && /rv:11.0/.test(t) && (s = 11),
                    s
            }(),
            Qo = /Safari/i.test(t) && !Ji && !Qi && !an,
            Jo = /Windows/i.test(t),
            Zo = /iPad/i.test(t) || Qo && Ta && !/iPhone/i.test(t),
            el = /iPhone/i.test(t) && !Zo
    }
    var jt = el || Zo || Sh
        , tl = (Qo || jt) && !Ji
        , I0 = Object.freeze({
            __proto__: null,
            get IS_IPOD() {
                return Sh
            },
            get IOS_VERSION() {
                return cf
            },
            get IS_ANDROID() {
                return Qi
            },
            get ANDROID_VERSION() {
                return ff
            },
            get IS_FIREFOX() {
                return pf
            },
            get IS_EDGE() {
                return an
            },
            get IS_CHROMIUM() {
                return on
            },
            get IS_CHROME() {
                return Ji
            },
            get CHROMIUM_VERSION() {
                return Ch
            },
            get CHROME_VERSION() {
                return Yo
            },
            get IE_VERSION() {
                return mf
            },
            get IS_SAFARI() {
                return Qo
            },
            get IS_WINDOWS() {
                return Jo
            },
            get IS_IPAD() {
                return Zo
            },
            get IS_IPHONE() {
                return el
            },
            TOUCH_ENABLED: Ta,
            IS_IOS: jt,
            IS_ANY_SAFARI: tl
        });
    function gf(t) {
        return typeof t == "string" && !!t.trim()
    }
    function P0(t) {
        if (t.indexOf(" ") >= 0)
            throw new Error("class has illegal whitespace characters")
    }
    function ln() {
        return le.default === O.default.document
    }
    function un(t) {
        return Yi(t) && t.nodeType === 1
    }
    function vf() {
        try {
            return O.default.parent !== O.default.self
        } catch (t) {
            return !0
        }
    }
    function yf(t) {
        return function (e, s) {
            if (!gf(e))
                return le.default[t](null);
            gf(s) && (s = le.default.querySelector(s));
            const r = un(s) ? s : le.default;
            return r[t] && r[t](e)
        }
    }
    function De(t = "div", e = {}, s = {}, r) {
        const n = le.default.createElement(t);
        return Object.getOwnPropertyNames(e).forEach(function (a) {
            const o = e[a];
            a === "textContent" ? zs(n, o) : (n[a] !== o || a === "tabIndex") && (n[a] = o)
        }),
            Object.getOwnPropertyNames(s).forEach(function (a) {
                n.setAttribute(a, s[a])
            }),
            r && wh(n, r),
            n
    }
    function zs(t, e) {
        return typeof t.textContent > "u" ? t.innerText = e : t.textContent = e,
            t
    }
    function Ah(t, e) {
        e.firstChild ? e.insertBefore(t, e.firstChild) : e.appendChild(t)
    }
    function ba(t, e) {
        return P0(e),
            t.classList.contains(e)
    }
    function vr(t, ...e) {
        return t.classList.add(...e.reduce((s, r) => s.concat(r.split(/\s+/)), [])),
            t
    }
    function il(t, ...e) {
        return t ? (t.classList.remove(...e.reduce((s, r) => s.concat(r.split(/\s+/)), [])),
            t) : (Ie.warn("removeClass was called with an element that doesn't exist"),
                null)
    }
    function _f(t, e, s) {
        return typeof s == "function" && (s = s(t, e)),
            typeof s != "boolean" && (s = void 0),
            e.split(/\s+/).forEach(r => t.classList.toggle(r, s)),
            t
    }
    function Tf(t, e) {
        Object.getOwnPropertyNames(e).forEach(function (s) {
            const r = e[s];
            r === null || typeof r > "u" || r === !1 ? t.removeAttribute(s) : t.setAttribute(s, r === !0 ? "" : r)
        })
    }
    function Gs(t) {
        const e = {}
            , s = ["autoplay", "controls", "playsinline", "loop", "muted", "default", "defaultMuted"];
        if (t && t.attributes && t.attributes.length > 0) {
            const r = t.attributes;
            for (let n = r.length - 1; n >= 0; n--) {
                const a = r[n].name;
                let o = r[n].value;
                s.includes(a) && (o = o !== null),
                    e[a] = o
            }
        }
        return e
    }
    function bf(t, e) {
        return t.getAttribute(e)
    }
    function hn(t, e, s) {
        t.setAttribute(e, s)
    }
    function sl(t, e) {
        t.removeAttribute(e)
    }
    function Ef() {
        le.default.body.focus(),
            le.default.onselectstart = function () {
                return !1
            }
    }
    function Sf() {
        le.default.onselectstart = function () {
            return !0
        }
    }
    function dn(t) {
        if (t && t.getBoundingClientRect && t.parentNode) {
            const e = t.getBoundingClientRect()
                , s = {};
            return ["bottom", "height", "left", "right", "top", "width"].forEach(r => {
                e[r] !== void 0 && (s[r] = e[r])
            }
            ),
                s.height || (s.height = parseFloat(cn(t, "height"))),
                s.width || (s.width = parseFloat(cn(t, "width"))),
                s
        }
    }
    function Ea(t) {
        if (!t || t && !t.offsetParent)
            return {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            };
        const e = t.offsetWidth
            , s = t.offsetHeight;
        let r = 0
            , n = 0;
        for (; t.offsetParent && t !== le.default[Wo.fullscreenElement];)
            r += t.offsetLeft,
                n += t.offsetTop,
                t = t.offsetParent;
        return {
            left: r,
            top: n,
            width: e,
            height: s
        }
    }
    function rl(t, e) {
        const s = {
            x: 0,
            y: 0
        };
        if (jt) {
            let v = t;
            for (; v && v.nodeName.toLowerCase() !== "html";) {
                const T = cn(v, "transform");
                if (/^matrix/.test(T)) {
                    const D = T.slice(7, -1).split(/,\s/).map(Number);
                    s.x += D[4],
                        s.y += D[5]
                } else if (/^matrix3d/.test(T)) {
                    const D = T.slice(9, -1).split(/,\s/).map(Number);
                    s.x += D[12],
                        s.y += D[13]
                }
                v = v.parentNode
            }
        }
        const r = {}
            , n = Ea(e.target)
            , a = Ea(t)
            , o = a.width
            , u = a.height;
        let c = e.offsetY - (a.top - n.top)
            , f = e.offsetX - (a.left - n.left);
        return e.changedTouches && (f = e.changedTouches[0].pageX - a.left,
            c = e.changedTouches[0].pageY + a.top,
            jt && (f -= s.x,
                c -= s.y)),
            r.y = 1 - Math.max(0, Math.min(1, c / u)),
            r.x = Math.max(0, Math.min(1, f / o)),
            r
    }
    function Cf(t) {
        return Yi(t) && t.nodeType === 3
    }
    function nl(t) {
        for (; t.firstChild;)
            t.removeChild(t.firstChild);
        return t
    }
    function Af(t) {
        return typeof t == "function" && (t = t()),
            (Array.isArray(t) ? t : [t]).map(e => {
                if (typeof e == "function" && (e = e()),
                    un(e) || Cf(e))
                    return e;
                if (typeof e == "string" && /\S/.test(e))
                    return le.default.createTextNode(e)
            }
            ).filter(e => e)
    }
    function wh(t, e) {
        return Af(e).forEach(s => t.appendChild(s)),
            t
    }
    function wf(t, e) {
        return wh(nl(t), e)
    }
    function Sa(t) {
        return t.button === void 0 && t.buttons === void 0 || t.button === 0 && t.buttons === void 0 || t.type === "mouseup" && t.button === 0 && t.buttons === 0 ? !0 : !(t.button !== 0 || t.buttons !== 1)
    }
    var Ws = yf("querySelector")
        , Df = yf("querySelectorAll");
    function cn(t, e) {
        if (!t || !e)
            return "";
        if (typeof O.default.getComputedStyle == "function") {
            let s;
            try {
                s = O.default.getComputedStyle(t)
            } catch (r) {
                return ""
            }
            return s ? s.getPropertyValue(e) || s[e] : ""
        }
        return ""
    }
    function kf(t) {
        [...le.default.styleSheets].forEach(e => {
            try {
                const s = [...e.cssRules].map(n => n.cssText).join("")
                    , r = le.default.createElement("style");
                r.textContent = s,
                    t.document.head.appendChild(r)
            } catch (s) {
                const r = le.default.createElement("link");
                r.rel = "stylesheet",
                    r.type = e.type,
                    r.media = e.media.mediaText,
                    r.href = e.href,
                    t.document.head.appendChild(r)
            }
        }
        )
    }
    var xf = Object.freeze({
        __proto__: null,
        isReal: ln,
        isEl: un,
        isInFrame: vf,
        createEl: De,
        textContent: zs,
        prependTo: Ah,
        hasClass: ba,
        addClass: vr,
        removeClass: il,
        toggleClass: _f,
        setAttributes: Tf,
        getAttributes: Gs,
        getAttribute: bf,
        setAttribute: hn,
        removeAttribute: sl,
        blockTextSelection: Ef,
        unblockTextSelection: Sf,
        getBoundingClientRect: dn,
        findPosition: Ea,
        getPointerPosition: rl,
        isTextNode: Cf,
        emptyEl: nl,
        normalizeContent: Af,
        appendContent: wh,
        insertContent: wf,
        isSingleLeftClick: Sa,
        $: Ws,
        $$: Df,
        computedStyle: cn,
        copyStyleSheetsToWindow: kf
    }), If = !1, Dh, L0 = function () {
        if (Dh.options.autoSetup === !1)
            return;
        const t = Array.prototype.slice.call(le.default.getElementsByTagName("video"))
            , e = Array.prototype.slice.call(le.default.getElementsByTagName("audio"))
            , s = Array.prototype.slice.call(le.default.getElementsByTagName("video-js"))
            , r = t.concat(e, s);
        if (r && r.length > 0)
            for (let n = 0, a = r.length; n < a; n++) {
                const o = r[n];
                if (o && o.getAttribute)
                    o.player === void 0 && o.getAttribute("data-setup") !== null && Dh(o);
                else {
                    kh(1);
                    break
                }
            }
        else
            If || kh(1)
    };
    function kh(t, e) {
        ln() && (e && (Dh = e),
            O.default.setTimeout(L0, t))
    }
    function xh() {
        If = !0,
            O.default.removeEventListener("load", xh)
    }
    ln() && (le.default.readyState === "complete" ? xh() : O.default.addEventListener("load", xh));
    var Pf = function (t) {
        const e = le.default.createElement("style");
        return e.className = t,
            e
    }
        , Lf = function (t, e) {
            t.styleSheet ? t.styleSheet.cssText = e : t.textContent = e
        }
        , Ht = new WeakMap
        , O0 = 3
        , M0 = O0;
    function Zi() {
        return M0++
    }
    function Of(t, e) {
        if (!Ht.has(t))
            return;
        const s = Ht.get(t);
        s.handlers[e].length === 0 && (delete s.handlers[e],
            t.removeEventListener ? t.removeEventListener(e, s.dispatcher, !1) : t.detachEvent && t.detachEvent("on" + e, s.dispatcher)),
            Object.getOwnPropertyNames(s.handlers).length <= 0 && (delete s.handlers,
                delete s.dispatcher,
                delete s.disabled),
            Object.getOwnPropertyNames(s).length === 0 && Ht.delete(t)
    }
    function Ih(t, e, s, r) {
        s.forEach(function (n) {
            t(e, n, r)
        })
    }
    function al(t) {
        if (t.fixed_)
            return t;
        function e() {
            return !0
        }
        function s() {
            return !1
        }
        if (!t || !t.isPropagationStopped || !t.isImmediatePropagationStopped) {
            const r = t || O.default.event;
            t = {};
            for (const n in r)
                n !== "layerX" && n !== "layerY" && n !== "keyLocation" && n !== "webkitMovementX" && n !== "webkitMovementY" && n !== "path" && (n === "returnValue" && r.preventDefault || (t[n] = r[n]));
            if (t.target || (t.target = t.srcElement || le.default),
                t.relatedTarget || (t.relatedTarget = t.fromElement === t.target ? t.toElement : t.fromElement),
                t.preventDefault = function () {
                    r.preventDefault && r.preventDefault(),
                        t.returnValue = !1,
                        r.returnValue = !1,
                        t.defaultPrevented = !0
                }
                ,
                t.defaultPrevented = !1,
                t.stopPropagation = function () {
                    r.stopPropagation && r.stopPropagation(),
                        t.cancelBubble = !0,
                        r.cancelBubble = !0,
                        t.isPropagationStopped = e
                }
                ,
                t.isPropagationStopped = s,
                t.stopImmediatePropagation = function () {
                    r.stopImmediatePropagation && r.stopImmediatePropagation(),
                        t.isImmediatePropagationStopped = e,
                        t.stopPropagation()
                }
                ,
                t.isImmediatePropagationStopped = s,
                t.clientX !== null && t.clientX !== void 0) {
                const n = le.default.documentElement
                    , a = le.default.body;
                t.pageX = t.clientX + (n && n.scrollLeft || a && a.scrollLeft || 0) - (n && n.clientLeft || a && a.clientLeft || 0),
                    t.pageY = t.clientY + (n && n.scrollTop || a && a.scrollTop || 0) - (n && n.clientTop || a && a.clientTop || 0)
            }
            t.which = t.charCode || t.keyCode,
                t.button !== null && t.button !== void 0 && (t.button = t.button & 1 ? 0 : t.button & 4 ? 1 : t.button & 2 ? 2 : 0)
        }
        return t.fixed_ = !0,
            t
    }
    var ol, R0 = function () {
        if (typeof ol != "boolean") {
            ol = !1;
            try {
                const t = Object.defineProperty({}, "passive", {
                    get() {
                        ol = !0
                    }
                });
                O.default.addEventListener("test", null, t),
                    O.default.removeEventListener("test", null, t)
            } catch (t) { }
        }
        return ol
    }, N0 = ["touchstart", "touchmove"];
    function ui(t, e, s) {
        if (Array.isArray(e))
            return Ih(ui, t, e, s);
        Ht.has(t) || Ht.set(t, {});
        const r = Ht.get(t);
        if (r.handlers || (r.handlers = {}),
            r.handlers[e] || (r.handlers[e] = []),
            s.guid || (s.guid = Zi()),
            r.handlers[e].push(s),
            r.dispatcher || (r.disabled = !1,
                r.dispatcher = function (n, a) {
                    if (r.disabled)
                        return;
                    n = al(n);
                    const o = r.handlers[n.type];
                    if (o) {
                        const u = o.slice(0);
                        for (let c = 0, f = u.length; c < f && !n.isImmediatePropagationStopped(); c++)
                            try {
                                u[c].call(t, n, a)
                            } catch (v) {
                                Ie.error(v)
                            }
                    }
                }
            ),
            r.handlers[e].length === 1)
            if (t.addEventListener) {
                let n = !1;
                R0() && N0.indexOf(e) > -1 && (n = {
                    passive: !0
                }),
                    t.addEventListener(e, r.dispatcher, n)
            } else
                t.attachEvent && t.attachEvent("on" + e, r.dispatcher)
    }
    function kt(t, e, s) {
        if (!Ht.has(t))
            return;
        const r = Ht.get(t);
        if (!r.handlers)
            return;
        if (Array.isArray(e))
            return Ih(kt, t, e, s);
        const n = function (o, u) {
            r.handlers[u] = [],
                Of(o, u)
        };
        if (e === void 0) {
            for (const o in r.handlers)
                Object.prototype.hasOwnProperty.call(r.handlers || {}, o) && n(t, o);
            return
        }
        const a = r.handlers[e];
        if (a) {
            if (!s) {
                n(t, e);
                return
            }
            if (s.guid)
                for (let o = 0; o < a.length; o++)
                    a[o].guid === s.guid && a.splice(o--, 1);
            Of(t, e)
        }
    }
    function fn(t, e, s) {
        const r = Ht.has(t) ? Ht.get(t) : {}
            , n = t.parentNode || t.ownerDocument;
        if (typeof e == "string" ? e = {
            type: e,
            target: t
        } : e.target || (e.target = t),
            e = al(e),
            r.dispatcher && r.dispatcher.call(t, e, s),
            n && !e.isPropagationStopped() && e.bubbles === !0)
            fn.call(null, n, e, s);
        else if (!n && !e.defaultPrevented && e.target && e.target[e.type]) {
            Ht.has(e.target) || Ht.set(e.target, {});
            const a = Ht.get(e.target);
            e.target[e.type] && (a.disabled = !0,
                typeof e.target[e.type] == "function" && e.target[e.type](),
                a.disabled = !1)
        }
        return !e.defaultPrevented
    }
    function ll(t, e, s) {
        if (Array.isArray(e))
            return Ih(ll, t, e, s);
        const r = function () {
            kt(t, e, r),
                s.apply(this, arguments)
        };
        r.guid = s.guid = s.guid || Zi(),
            ui(t, e, r)
    }
    function Ph(t, e, s) {
        const r = function () {
            kt(t, e, r),
                s.apply(this, arguments)
        };
        r.guid = s.guid = s.guid || Zi(),
            ui(t, e, r)
    }
    var B0 = Object.freeze({
        __proto__: null,
        fixEvent: al,
        on: ui,
        off: kt,
        trigger: fn,
        one: ll,
        any: Ph
    }), Ti = 30, Ge = function (t, e, s) {
        e.guid || (e.guid = Zi());
        const r = e.bind(t);
        return r.guid = s ? s + "_" + e.guid : e.guid,
            r
    }, es = function (t, e) {
        let s = O.default.performance.now();
        return function (...n) {
            const a = O.default.performance.now();
            a - s >= e && (t(...n),
                s = a)
        }
    }, Mf = function (t, e, s, r = O.default) {
        let n;
        const a = () => {
            r.clearTimeout(n),
                n = null
        }
            , o = function () {
                const u = this
                    , c = arguments;
                let f = function () {
                    n = null,
                        f = null,
                        s || t.apply(u, c)
                };
                !n && s && t.apply(u, c),
                    r.clearTimeout(n),
                    n = r.setTimeout(f, e)
            };
        return o.cancel = a,
            o
    }, F0 = Object.freeze({
        __proto__: null,
        UPDATE_REFRESH_INTERVAL: Ti,
        bind_: Ge,
        throttle: es,
        debounce: Mf
    }), Ca, bi = class {
        on(t, e) {
            const s = this.addEventListener;
            this.addEventListener = () => { }
                ,
                ui(this, t, e),
                this.addEventListener = s
        }
        off(t, e) {
            kt(this, t, e)
        }
        one(t, e) {
            const s = this.addEventListener;
            this.addEventListener = () => { }
                ,
                ll(this, t, e),
                this.addEventListener = s
        }
        any(t, e) {
            const s = this.addEventListener;
            this.addEventListener = () => { }
                ,
                Ph(this, t, e),
                this.addEventListener = s
        }
        trigger(t) {
            const e = t.type || t;
            typeof t == "string" && (t = {
                type: e
            }),
                t = al(t),
                this.allowedEvents_[e] && this["on" + e] && this["on" + e](t),
                fn(this, t)
        }
        queueTrigger(t) {
            Ca || (Ca = new Map);
            const e = t.type || t;
            let s = Ca.get(this);
            s || (s = new Map,
                Ca.set(this, s));
            const r = s.get(e);
            s.delete(e),
                O.default.clearTimeout(r);
            const n = O.default.setTimeout(() => {
                s.delete(e),
                    s.size === 0 && (s = null,
                        Ca.delete(this)),
                    this.trigger(t)
            }
                , 0);
            s.set(e, n)
        }
    }
        ;
    bi.prototype.allowedEvents_ = {},
        bi.prototype.addEventListener = bi.prototype.on,
        bi.prototype.removeEventListener = bi.prototype.off,
        bi.prototype.dispatchEvent = bi.prototype.trigger;
    var ul = t => typeof t.name == "function" ? t.name() : typeof t.name == "string" ? t.name : t.name_ ? t.name_ : t.constructor && t.constructor.name ? t.constructor.name : typeof t
        , Ts = t => t instanceof bi || !!t.eventBusEl_ && ["on", "one", "off", "trigger"].every(e => typeof t[e] == "function")
        , U0 = (t, e) => {
            Ts(t) ? e() : (t.eventedCallbacks || (t.eventedCallbacks = []),
                t.eventedCallbacks.push(e))
        }
        , Lh = t => typeof t == "string" && /\S/.test(t) || Array.isArray(t) && !!t.length
        , hl = (t, e, s) => {
            if (!t || !t.nodeName && !Ts(t))
                throw new Error(`Invalid target for ${ul(e)}#${s}; must be a DOM node or evented object.`)
        }
        , Rf = (t, e, s) => {
            if (!Lh(t))
                throw new Error(`Invalid event type for ${ul(e)}#${s}; must be a non-empty string or array.`)
        }
        , Nf = (t, e, s) => {
            if (typeof t != "function")
                throw new Error(`Invalid listener for ${ul(e)}#${s}; must be a function.`)
        }
        , Oh = (t, e, s) => {
            const r = e.length < 3 || e[0] === t || e[0] === t.eventBusEl_;
            let n, a, o;
            return r ? (n = t.eventBusEl_,
                e.length >= 3 && e.shift(),
                [a, o] = e) : [n, a, o] = e,
                hl(n, t, s),
                Rf(a, t, s),
                Nf(o, t, s),
                o = Ge(t, o),
            {
                isTargetingSelf: r,
                target: n,
                type: a,
                listener: o
            }
        }
        , yr = (t, e, s, r) => {
            hl(t, t, e),
                t.nodeName ? B0[e](t, s, r) : t[e](s, r)
        }
        , j0 = {
            on(...t) {
                const { isTargetingSelf: e, target: s, type: r, listener: n } = Oh(this, t, "on");
                if (yr(s, "on", r, n),
                    !e) {
                    const a = () => this.off(s, r, n);
                    a.guid = n.guid;
                    const o = () => this.off("dispose", a);
                    o.guid = n.guid,
                        yr(this, "on", "dispose", a),
                        yr(s, "on", "dispose", o)
                }
            },
            one(...t) {
                const { isTargetingSelf: e, target: s, type: r, listener: n } = Oh(this, t, "one");
                if (e)
                    yr(s, "one", r, n);
                else {
                    const a = (...o) => {
                        this.off(s, r, a),
                            n.apply(null, o)
                    }
                        ;
                    a.guid = n.guid,
                        yr(s, "one", r, a)
                }
            },
            any(...t) {
                const { isTargetingSelf: e, target: s, type: r, listener: n } = Oh(this, t, "any");
                if (e)
                    yr(s, "any", r, n);
                else {
                    const a = (...o) => {
                        this.off(s, r, a),
                            n.apply(null, o)
                    }
                        ;
                    a.guid = n.guid,
                        yr(s, "any", r, a)
                }
            },
            off(t, e, s) {
                if (!t || Lh(t))
                    kt(this.eventBusEl_, t, e);
                else {
                    const r = t
                        , n = e;
                    hl(r, this, "off"),
                        Rf(n, this, "off"),
                        Nf(s, this, "off"),
                        s = Ge(this, s),
                        this.off("dispose", s),
                        r.nodeName ? (kt(r, n, s),
                            kt(r, "dispose", s)) : Ts(r) && (r.off(n, s),
                                r.off("dispose", s))
                }
            },
            trigger(t, e) {
                hl(this.eventBusEl_, this, "trigger");
                const s = t && typeof t != "string" ? t.type : t;
                if (!Lh(s))
                    throw new Error(`Invalid event type for ${ul(this)}#trigger; must be a non-empty string or object with a type key that has a non-empty value.`);
                return fn(this.eventBusEl_, t, e)
            }
        };
    function Mh(t, e = {}) {
        const { eventBusKey: s } = e;
        if (s) {
            if (!t[s].nodeName)
                throw new Error(`The eventBusKey "${s}" does not refer to an element.`);
            t.eventBusEl_ = t[s]
        } else
            t.eventBusEl_ = De("span", {
                className: "vjs-event-bus"
            });
        return Object.assign(t, j0),
            t.eventedCallbacks && t.eventedCallbacks.forEach(r => {
                r()
            }
            ),
            t.on("dispose", () => {
                t.off(),
                    [t, t.el_, t.eventBusEl_].forEach(function (r) {
                        r && Ht.has(r) && Ht.delete(r)
                    }),
                    O.default.setTimeout(() => {
                        t.eventBusEl_ = null
                    }
                        , 0)
            }
            ),
            t
    }
    var H0 = {
        state: {},
        setState(t) {
            typeof t == "function" && (t = t());
            let e;
            return rn(t, (s, r) => {
                this.state[r] !== s && (e = e || {},
                    e[r] = {
                        from: this.state[r],
                        to: s
                    }),
                    this.state[r] = s
            }
            ),
                e && Ts(this) && this.trigger({
                    changes: e,
                    type: "statechanged"
                }),
                e
        }
    };
    function Bf(t, e) {
        return Object.assign(t, H0),
            t.state = Object.assign({}, t.state, e),
            typeof t.handleStateChanged == "function" && Ts(t) && t.on("statechanged", t.handleStateChanged),
            t
    }
    var Aa = function (t) {
        return typeof t != "string" ? t : t.replace(/./, e => e.toLowerCase())
    }
        , tt = function (t) {
            return typeof t != "string" ? t : t.replace(/./, e => e.toUpperCase())
        }
        , Ff = function (t, e) {
            return tt(t) === tt(e)
        }
        , q0 = Object.freeze({
            __proto__: null,
            toLowerCase: Aa,
            toTitleCase: tt,
            titleCaseEquals: Ff
        })
        , J = class oi {
            constructor(e, s, r) {
                if (!e && this.play ? this.player_ = e = this : this.player_ = e,
                    this.isDisposed_ = !1,
                    this.parentComponent_ = null,
                    this.options_ = ze({}, this.options_),
                    s = this.options_ = ze(this.options_, s),
                    this.id_ = s.id || s.el && s.el.id,
                    !this.id_) {
                    const n = e && e.id && e.id() || "no_player";
                    this.id_ = `${n}_component_${Zi()}`
                }
                this.name_ = s.name || null,
                    s.el ? this.el_ = s.el : s.createEl !== !1 && (this.el_ = this.createEl()),
                    s.className && this.el_ && s.className.split(" ").forEach(n => this.addClass(n)),
                    ["on", "off", "one", "any", "trigger"].forEach(n => {
                        this[n] = void 0
                    }
                    ),
                    s.evented !== !1 && (Mh(this, {
                        eventBusKey: this.el_ ? "el_" : null
                    }),
                        this.handleLanguagechange = this.handleLanguagechange.bind(this),
                        this.on(this.player_, "languagechange", this.handleLanguagechange)),
                    Bf(this, this.constructor.defaultState),
                    this.children_ = [],
                    this.childIndex_ = {},
                    this.childNameIndex_ = {},
                    this.setTimeoutIds_ = new Set,
                    this.setIntervalIds_ = new Set,
                    this.rafIds_ = new Set,
                    this.namedRafs_ = new Map,
                    this.clearingTimersOnDispose_ = !1,
                    s.initChildren !== !1 && this.initChildren(),
                    this.ready(r),
                    s.reportTouchActivity !== !1 && this.enableTouchActivity()
            }
            on(e, s) { }
            off(e, s) { }
            one(e, s) { }
            any(e, s) { }
            trigger(e, s) { }
            dispose(e = {}) {
                if (!this.isDisposed_) {
                    if (this.readyQueue_ && (this.readyQueue_.length = 0),
                        this.trigger({
                            type: "dispose",
                            bubbles: !1
                        }),
                        this.isDisposed_ = !0,
                        this.children_)
                        for (let s = this.children_.length - 1; s >= 0; s--)
                            this.children_[s].dispose && this.children_[s].dispose();
                    this.children_ = null,
                        this.childIndex_ = null,
                        this.childNameIndex_ = null,
                        this.parentComponent_ = null,
                        this.el_ && (this.el_.parentNode && (e.restoreEl ? this.el_.parentNode.replaceChild(e.restoreEl, this.el_) : this.el_.parentNode.removeChild(this.el_)),
                            this.el_ = null),
                        this.player_ = null
                }
            }
            isDisposed() {
                return !!this.isDisposed_
            }
            player() {
                return this.player_
            }
            options(e) {
                return e ? (this.options_ = ze(this.options_, e),
                    this.options_) : this.options_
            }
            el() {
                return this.el_
            }
            createEl(e, s, r) {
                return De(e, s, r)
            }
            localize(e, s, r = e) {
                const n = this.player_.language && this.player_.language()
                    , a = this.player_.languages && this.player_.languages()
                    , o = a && a[n]
                    , u = n && n.split("-")[0]
                    , c = a && a[u];
                let f = r;
                return o && o[e] ? f = o[e] : c && c[e] && (f = c[e]),
                    s && (f = f.replace(/\{(\d+)\}/g, function (v, T) {
                        const D = s[T - 1];
                        let _ = D;
                        return typeof D > "u" && (_ = v),
                            _
                    })),
                    f
            }
            handleLanguagechange() { }
            contentEl() {
                return this.contentEl_ || this.el_
            }
            id() {
                return this.id_
            }
            name() {
                return this.name_
            }
            children() {
                return this.children_
            }
            getChildById(e) {
                return this.childIndex_[e]
            }
            getChild(e) {
                if (e)
                    return this.childNameIndex_[e]
            }
            getDescendant(...e) {
                e = e.reduce((r, n) => r.concat(n), []);
                let s = this;
                for (let r = 0; r < e.length; r++)
                    if (s = s.getChild(e[r]),
                        !s || !s.getChild)
                        return;
                return s
            }
            setIcon(e, s = this.el()) {
                if (!this.player_.options_.experimentalSvgIcons)
                    return;
                const r = "http://www.w3.org/2000/svg"
                    , n = De("span", {
                        className: "vjs-icon-placeholder vjs-svg-icon"
                    }, {
                        "aria-hidden": "true"
                    })
                    , a = le.default.createElementNS(r, "svg");
                a.setAttributeNS(null, "viewBox", "0 0 512 512");
                const o = le.default.createElementNS(r, "use");
                return a.appendChild(o),
                    o.setAttributeNS(null, "href", `#vjs-icon-${e}`),
                    n.appendChild(a),
                    this.iconIsSet_ ? s.replaceChild(n, s.querySelector(".vjs-icon-placeholder")) : s.appendChild(n),
                    this.iconIsSet_ = !0,
                    n
            }
            addChild(e, s = {}, r = this.children_.length) {
                let n, a;
                if (typeof e == "string") {
                    a = tt(e);
                    const o = s.componentClass || a;
                    s.name = a;
                    const u = oi.getComponent(o);
                    if (!u)
                        throw new Error(`Component ${o} does not exist`);
                    if (typeof u != "function")
                        return null;
                    n = new u(this.player_ || this, s)
                } else
                    n = e;
                if (n.parentComponent_ && n.parentComponent_.removeChild(n),
                    this.children_.splice(r, 0, n),
                    n.parentComponent_ = this,
                    typeof n.id == "function" && (this.childIndex_[n.id()] = n),
                    a = a || n.name && tt(n.name()),
                    a && (this.childNameIndex_[a] = n,
                        this.childNameIndex_[Aa(a)] = n),
                    typeof n.el == "function" && n.el()) {
                    let o = null;
                    this.children_[r + 1] && (this.children_[r + 1].el_ ? o = this.children_[r + 1].el_ : un(this.children_[r + 1]) && (o = this.children_[r + 1])),
                        this.contentEl().insertBefore(n.el(), o)
                }
                return n
            }
            removeChild(e) {
                if (typeof e == "string" && (e = this.getChild(e)),
                    !e || !this.children_)
                    return;
                let s = !1;
                for (let n = this.children_.length - 1; n >= 0; n--)
                    if (this.children_[n] === e) {
                        s = !0,
                            this.children_.splice(n, 1);
                        break
                    }
                if (!s)
                    return;
                e.parentComponent_ = null,
                    this.childIndex_[e.id()] = null,
                    this.childNameIndex_[tt(e.name())] = null,
                    this.childNameIndex_[Aa(e.name())] = null;
                const r = e.el();
                r && r.parentNode === this.contentEl() && this.contentEl().removeChild(e.el())
            }
            initChildren() {
                const e = this.options_.children;
                if (e) {
                    const s = this.options_
                        , r = o => {
                            const u = o.name;
                            let c = o.opts;
                            if (s[u] !== void 0 && (c = s[u]),
                                c === !1)
                                return;
                            c === !0 && (c = {}),
                                c.playerOptions = this.options_.playerOptions;
                            const f = this.addChild(u, c);
                            f && (this[u] = f)
                        }
                        ;
                    let n;
                    const a = oi.getComponent("Tech");
                    Array.isArray(e) ? n = e : n = Object.keys(e),
                        n.concat(Object.keys(this.options_).filter(function (o) {
                            return !n.some(function (u) {
                                return typeof u == "string" ? o === u : o === u.name
                            })
                        })).map(o => {
                            let u, c;
                            return typeof o == "string" ? (u = o,
                                c = e[u] || this.options_[u] || {}) : (u = o.name,
                                    c = o),
                            {
                                name: u,
                                opts: c
                            }
                        }
                        ).filter(o => {
                            const u = oi.getComponent(o.opts.componentClass || tt(o.name));
                            return u && !a.isTech(u)
                        }
                        ).forEach(r)
                }
            }
            buildCSSClass() {
                return ""
            }
            ready(e, s = !1) {
                if (e) {
                    if (!this.isReady_) {
                        this.readyQueue_ = this.readyQueue_ || [],
                            this.readyQueue_.push(e);
                        return
                    }
                    s ? e.call(this) : this.setTimeout(e, 1)
                }
            }
            triggerReady() {
                this.isReady_ = !0,
                    this.setTimeout(function () {
                        const e = this.readyQueue_;
                        this.readyQueue_ = [],
                            e && e.length > 0 && e.forEach(function (s) {
                                s.call(this)
                            }, this),
                            this.trigger("ready")
                    }, 1)
            }
            $(e, s) {
                return Ws(e, s || this.contentEl())
            }
            $$(e, s) {
                return Df(e, s || this.contentEl())
            }
            hasClass(e) {
                return ba(this.el_, e)
            }
            addClass(...e) {
                vr(this.el_, ...e)
            }
            removeClass(...e) {
                il(this.el_, ...e)
            }
            toggleClass(e, s) {
                _f(this.el_, e, s)
            }
            show() {
                this.removeClass("vjs-hidden")
            }
            hide() {
                this.addClass("vjs-hidden")
            }
            lockShowing() {
                this.addClass("vjs-lock-showing")
            }
            unlockShowing() {
                this.removeClass("vjs-lock-showing")
            }
            getAttribute(e) {
                return bf(this.el_, e)
            }
            setAttribute(e, s) {
                hn(this.el_, e, s)
            }
            removeAttribute(e) {
                sl(this.el_, e)
            }
            width(e, s) {
                return this.dimension("width", e, s)
            }
            height(e, s) {
                return this.dimension("height", e, s)
            }
            dimensions(e, s) {
                this.width(e, !0),
                    this.height(s)
            }
            dimension(e, s, r) {
                if (s !== void 0) {
                    (s === null || s !== s) && (s = 0),
                        ("" + s).indexOf("%") !== -1 || ("" + s).indexOf("px") !== -1 ? this.el_.style[e] = s : s === "auto" ? this.el_.style[e] = "" : this.el_.style[e] = s + "px",
                        r || this.trigger("componentresize");
                    return
                }
                if (!this.el_)
                    return 0;
                const n = this.el_.style[e]
                    , a = n.indexOf("px");
                return parseInt(a !== -1 ? n.slice(0, a) : this.el_["offset" + tt(e)], 10)
            }
            currentDimension(e) {
                let s = 0;
                if (e !== "width" && e !== "height")
                    throw new Error("currentDimension only accepts width or height value");
                if (s = cn(this.el_, e),
                    s = parseFloat(s),
                    s === 0 || isNaN(s)) {
                    const r = `offset${tt(e)}`;
                    s = this.el_[r]
                }
                return s
            }
            currentDimensions() {
                return {
                    width: this.currentDimension("width"),
                    height: this.currentDimension("height")
                }
            }
            currentWidth() {
                return this.currentDimension("width")
            }
            currentHeight() {
                return this.currentDimension("height")
            }
            focus() {
                this.el_.focus()
            }
            blur() {
                this.el_.blur()
            }
            handleKeyDown(e) {
                this.player_ && (we.default.isEventKey(e, "Tab") || e.stopPropagation(),
                    this.player_.handleKeyDown(e))
            }
            handleKeyPress(e) {
                this.handleKeyDown(e)
            }
            emitTapEvents() {
                let e = 0
                    , s = null;
                const r = 10
                    , n = 200;
                let a;
                this.on("touchstart", function (u) {
                    u.touches.length === 1 && (s = {
                        pageX: u.touches[0].pageX,
                        pageY: u.touches[0].pageY
                    },
                        e = O.default.performance.now(),
                        a = !0)
                }),
                    this.on("touchmove", function (u) {
                        if (u.touches.length > 1)
                            a = !1;
                        else if (s) {
                            const c = u.touches[0].pageX - s.pageX
                                , f = u.touches[0].pageY - s.pageY;
                            Math.sqrt(c * c + f * f) > r && (a = !1)
                        }
                    });
                const o = function () {
                    a = !1
                };
                this.on("touchleave", o),
                    this.on("touchcancel", o),
                    this.on("touchend", function (u) {
                        s = null,
                            a === !0 && O.default.performance.now() - e < n && (u.preventDefault(),
                                this.trigger("tap"))
                    })
            }
            enableTouchActivity() {
                if (!this.player() || !this.player().reportUserActivity)
                    return;
                const e = Ge(this.player(), this.player().reportUserActivity);
                let s;
                this.on("touchstart", function () {
                    e(),
                        this.clearInterval(s),
                        s = this.setInterval(e, 250)
                });
                const r = function (n) {
                    e(),
                        this.clearInterval(s)
                };
                this.on("touchmove", e),
                    this.on("touchend", r),
                    this.on("touchcancel", r)
            }
            setTimeout(e, s) {
                var r;
                return e = Ge(this, e),
                    this.clearTimersOnDispose_(),
                    r = O.default.setTimeout(() => {
                        this.setTimeoutIds_.has(r) && this.setTimeoutIds_.delete(r),
                            e()
                    }
                        , s),
                    this.setTimeoutIds_.add(r),
                    r
            }
            clearTimeout(e) {
                return this.setTimeoutIds_.has(e) && (this.setTimeoutIds_.delete(e),
                    O.default.clearTimeout(e)),
                    e
            }
            setInterval(e, s) {
                e = Ge(this, e),
                    this.clearTimersOnDispose_();
                const r = O.default.setInterval(e, s);
                return this.setIntervalIds_.add(r),
                    r
            }
            clearInterval(e) {
                return this.setIntervalIds_.has(e) && (this.setIntervalIds_.delete(e),
                    O.default.clearInterval(e)),
                    e
            }
            requestAnimationFrame(e) {
                this.clearTimersOnDispose_();
                var s;
                return e = Ge(this, e),
                    s = O.default.requestAnimationFrame(() => {
                        this.rafIds_.has(s) && this.rafIds_.delete(s),
                            e()
                    }
                    ),
                    this.rafIds_.add(s),
                    s
            }
            requestNamedAnimationFrame(e, s) {
                if (this.namedRafs_.has(e))
                    return;
                this.clearTimersOnDispose_(),
                    s = Ge(this, s);
                const r = this.requestAnimationFrame(() => {
                    s(),
                        this.namedRafs_.has(e) && this.namedRafs_.delete(e)
                }
                );
                return this.namedRafs_.set(e, r),
                    e
            }
            cancelNamedAnimationFrame(e) {
                this.namedRafs_.has(e) && (this.cancelAnimationFrame(this.namedRafs_.get(e)),
                    this.namedRafs_.delete(e))
            }
            cancelAnimationFrame(e) {
                return this.rafIds_.has(e) && (this.rafIds_.delete(e),
                    O.default.cancelAnimationFrame(e)),
                    e
            }
            clearTimersOnDispose_() {
                this.clearingTimersOnDispose_ || (this.clearingTimersOnDispose_ = !0,
                    this.one("dispose", () => {
                        [["namedRafs_", "cancelNamedAnimationFrame"], ["rafIds_", "cancelAnimationFrame"], ["setTimeoutIds_", "clearTimeout"], ["setIntervalIds_", "clearInterval"]].forEach(([e, s]) => {
                            this[e].forEach((r, n) => this[s](n))
                        }
                        ),
                            this.clearingTimersOnDispose_ = !1
                    }
                    ))
            }
            static registerComponent(e, s) {
                if (typeof e != "string" || !e)
                    throw new Error(`Illegal component name, "${e}"; must be a non-empty string.`);
                const r = oi.getComponent("Tech")
                    , n = r && r.isTech(s)
                    , a = oi === s || oi.prototype.isPrototypeOf(s.prototype);
                if (n || !a) {
                    let u;
                    throw n ? u = "techs must be registered using Tech.registerTech()" : u = "must be a Component subclass",
                    new Error(`Illegal component, "${e}"; ${u}.`)
                }
                e = tt(e),
                    oi.components_ || (oi.components_ = {});
                const o = oi.getComponent("Player");
                if (e === "Player" && o && o.players) {
                    const u = o.players
                        , c = Object.keys(u);
                    if (u && c.length > 0 && c.map(f => u[f]).every(Boolean))
                        throw new Error("Can not register Player component after player has been created.")
                }
                return oi.components_[e] = s,
                    oi.components_[Aa(e)] = s,
                    s
            }
            static getComponent(e) {
                if (!(!e || !oi.components_))
                    return oi.components_[e]
            }
        }
        ;
    J.registerComponent("Component", J);
    function $0(t, e, s) {
        if (typeof e != "number" || e < 0 || e > s)
            throw new Error(`Failed to execute '${t}' on 'TimeRanges': The index provided (${e}) is non-numeric or out of bounds (0-${s}).`)
    }
    function Uf(t, e, s, r) {
        return $0(t, r, s.length - 1),
            s[r][e]
    }
    function Rh(t) {
        let e;
        return t === void 0 || t.length === 0 ? e = {
            length: 0,
            start() {
                throw new Error("This TimeRanges object is empty")
            },
            end() {
                throw new Error("This TimeRanges object is empty")
            }
        } : e = {
            length: t.length,
            start: Uf.bind(null, "start", 0, t),
            end: Uf.bind(null, "end", 1, t)
        },
            O.default.Symbol && O.default.Symbol.iterator && (e[O.default.Symbol.iterator] = () => (t || []).values()),
            e
    }
    function Li(t, e) {
        return Array.isArray(t) ? Rh(t) : t === void 0 || e === void 0 ? Rh() : Rh([[t, e]])
    }
    var jf = function (t, e) {
        t = t < 0 ? 0 : t;
        let s = Math.floor(t % 60)
            , r = Math.floor(t / 60 % 60)
            , n = Math.floor(t / 3600);
        const a = Math.floor(e / 60 % 60)
            , o = Math.floor(e / 3600);
        return (isNaN(t) || t === 1 / 0) && (n = r = s = "-"),
            n = n > 0 || o > 0 ? n + ":" : "",
            r = ((n || a >= 10) && r < 10 ? "0" + r : r) + ":",
            s = s < 10 ? "0" + s : s,
            n + r + s
    }
        , Nh = jf;
    function Hf(t) {
        Nh = t
    }
    function qf() {
        Nh = jf
    }
    function _r(t, e = t) {
        return Nh(t, e)
    }
    var V0 = Object.freeze({
        __proto__: null,
        createTimeRanges: Li,
        createTimeRange: Li,
        setFormatTime: Hf,
        resetFormatTime: qf,
        formatTime: _r
    });
    function $f(t, e) {
        let s = 0, r, n;
        if (!e)
            return 0;
        (!t || !t.length) && (t = Li(0, 0));
        for (let a = 0; a < t.length; a++)
            r = t.start(a),
                n = t.end(a),
                n > e && (n = e),
                s += n - r;
        return s / e
    }
    function qt(t) {
        if (t instanceof qt)
            return t;
        typeof t == "number" ? this.code = t : typeof t == "string" ? this.message = t : Yi(t) && (typeof t.code == "number" && (this.code = t.code),
            Object.assign(this, t)),
            this.message || (this.message = qt.defaultMessages[this.code] || "")
    }
    qt.prototype.code = 0,
        qt.prototype.message = "",
        qt.prototype.status = null,
        qt.errorTypes = ["MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED"],
        qt.defaultMessages = {
            1: "You aborted the media playback",
            2: "A network error caused the media download to fail part-way.",
            3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
            4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
            5: "The media is encrypted and we do not have the keys to decrypt it."
        };
    for (let t = 0; t < qt.errorTypes.length; t++)
        qt[qt.errorTypes[t]] = t,
            qt.prototype[qt.errorTypes[t]] = t;
    function wa(t) {
        return t != null && typeof t.then == "function"
    }
    function ts(t) {
        wa(t) && t.then(null, e => { }
        )
    }
    var Bh = function (t) {
        return ["kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src"].reduce((s, r, n) => (t[r] && (s[r] = t[r]),
            s), {
            cues: t.cues && Array.prototype.map.call(t.cues, function (s) {
                return {
                    startTime: s.startTime,
                    endTime: s.endTime,
                    text: s.text,
                    id: s.id
                }
            })
        })
    }
        , z0 = function (t) {
            const e = t.$$("track")
                , s = Array.prototype.map.call(e, n => n.track);
            return Array.prototype.map.call(e, function (n) {
                const a = Bh(n.track);
                return n.src && (a.src = n.src),
                    a
            }).concat(Array.prototype.filter.call(t.textTracks(), function (n) {
                return s.indexOf(n) === -1
            }).map(Bh))
        }
        , G0 = function (t, e) {
            return t.forEach(function (s) {
                const r = e.addRemoteTextTrack(s).track;
                !s.src && s.cues && s.cues.forEach(n => r.addCue(n))
            }),
                e.textTracks()
        }
        , Vf = {
            textTracksToJson: z0,
            jsonToTextTracks: G0,
            trackToJson_: Bh
        }
        , Fh = "vjs-modal-dialog"
        , pn = class extends J {
            constructor(t, e) {
                super(t, e),
                    this.handleKeyDown_ = s => this.handleKeyDown(s),
                    this.close_ = s => this.close(s),
                    this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = !1,
                    this.closeable(!this.options_.uncloseable),
                    this.content(this.options_.content),
                    this.contentEl_ = De("div", {
                        className: `${Fh}-content`
                    }, {
                        role: "document"
                    }),
                    this.descEl_ = De("p", {
                        className: `${Fh}-description vjs-control-text`,
                        id: this.el().getAttribute("aria-describedby")
                    }),
                    zs(this.descEl_, this.description()),
                    this.el_.appendChild(this.descEl_),
                    this.el_.appendChild(this.contentEl_)
            }
            createEl() {
                return super.createEl("div", {
                    className: this.buildCSSClass(),
                    tabIndex: -1
                }, {
                    "aria-describedby": `${this.id()}_description`,
                    "aria-hidden": "true",
                    "aria-label": this.label(),
                    role: "dialog"
                })
            }
            dispose() {
                this.contentEl_ = null,
                    this.descEl_ = null,
                    this.previouslyActiveEl_ = null,
                    super.dispose()
            }
            buildCSSClass() {
                return `${Fh} vjs-hidden ${super.buildCSSClass()}`
            }
            label() {
                return this.localize(this.options_.label || "Modal Window")
            }
            description() {
                let t = this.options_.description || this.localize("This is a modal window.");
                return this.closeable() && (t += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.")),
                    t
            }
            open() {
                if (!this.opened_) {
                    const t = this.player();
                    this.trigger("beforemodalopen"),
                        this.opened_ = !0,
                        (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) && this.fill(),
                        this.wasPlaying_ = !t.paused(),
                        this.options_.pauseOnOpen && this.wasPlaying_ && t.pause(),
                        this.on("keydown", this.handleKeyDown_),
                        this.hadControls_ = t.controls(),
                        t.controls(!1),
                        this.show(),
                        this.conditionalFocus_(),
                        this.el().setAttribute("aria-hidden", "false"),
                        this.trigger("modalopen"),
                        this.hasBeenOpened_ = !0
                }
            }
            opened(t) {
                return typeof t == "boolean" && this[t ? "open" : "close"](),
                    this.opened_
            }
            close() {
                if (!this.opened_)
                    return;
                const t = this.player();
                this.trigger("beforemodalclose"),
                    this.opened_ = !1,
                    this.wasPlaying_ && this.options_.pauseOnOpen && t.play(),
                    this.off("keydown", this.handleKeyDown_),
                    this.hadControls_ && t.controls(!0),
                    this.hide(),
                    this.el().setAttribute("aria-hidden", "true"),
                    this.trigger("modalclose"),
                    this.conditionalBlur_(),
                    this.options_.temporary && this.dispose()
            }
            closeable(t) {
                if (typeof t == "boolean") {
                    const e = this.closeable_ = !!t;
                    let s = this.getChild("closeButton");
                    if (e && !s) {
                        const r = this.contentEl_;
                        this.contentEl_ = this.el_,
                            s = this.addChild("closeButton", {
                                controlText: "Close Modal Dialog"
                            }),
                            this.contentEl_ = r,
                            this.on(s, "close", this.close_)
                    }
                    !e && s && (this.off(s, "close", this.close_),
                        this.removeChild(s),
                        s.dispose())
                }
                return this.closeable_
            }
            fill() {
                this.fillWith(this.content())
            }
            fillWith(t) {
                const e = this.contentEl()
                    , s = e.parentNode
                    , r = e.nextSibling;
                this.trigger("beforemodalfill"),
                    this.hasBeenFilled_ = !0,
                    s.removeChild(e),
                    this.empty(),
                    wf(e, t),
                    this.trigger("modalfill"),
                    r ? s.insertBefore(e, r) : s.appendChild(e);
                const n = this.getChild("closeButton");
                n && s.appendChild(n.el_)
            }
            empty() {
                this.trigger("beforemodalempty"),
                    nl(this.contentEl()),
                    this.trigger("modalempty")
            }
            content(t) {
                return typeof t < "u" && (this.content_ = t),
                    this.content_
            }
            conditionalFocus_() {
                const t = le.default.activeElement
                    , e = this.player_.el_;
                this.previouslyActiveEl_ = null,
                    (e.contains(t) || e === t) && (this.previouslyActiveEl_ = t,
                        this.focus())
            }
            conditionalBlur_() {
                this.previouslyActiveEl_ && (this.previouslyActiveEl_.focus(),
                    this.previouslyActiveEl_ = null)
            }
            handleKeyDown(t) {
                if (t.stopPropagation(),
                    we.default.isEventKey(t, "Escape") && this.closeable()) {
                    t.preventDefault(),
                        this.close();
                    return
                }
                if (!we.default.isEventKey(t, "Tab"))
                    return;
                const e = this.focusableEls_()
                    , s = this.el_.querySelector(":focus");
                let r;
                for (let n = 0; n < e.length; n++)
                    if (s === e[n]) {
                        r = n;
                        break
                    }
                le.default.activeElement === this.el_ && (r = 0),
                    t.shiftKey && r === 0 ? (e[e.length - 1].focus(),
                        t.preventDefault()) : !t.shiftKey && r === e.length - 1 && (e[0].focus(),
                            t.preventDefault())
            }
            focusableEls_() {
                const t = this.el_.querySelectorAll("*");
                return Array.prototype.filter.call(t, e => (e instanceof O.default.HTMLAnchorElement || e instanceof O.default.HTMLAreaElement) && e.hasAttribute("href") || (e instanceof O.default.HTMLInputElement || e instanceof O.default.HTMLSelectElement || e instanceof O.default.HTMLTextAreaElement || e instanceof O.default.HTMLButtonElement) && !e.hasAttribute("disabled") || e instanceof O.default.HTMLIFrameElement || e instanceof O.default.HTMLObjectElement || e instanceof O.default.HTMLEmbedElement || e.hasAttribute("tabindex") && e.getAttribute("tabindex") !== -1 || e.hasAttribute("contenteditable"))
            }
        }
        ;
    pn.prototype.options_ = {
        pauseOnOpen: !0,
        temporary: !0
    },
        J.registerComponent("ModalDialog", pn);
    var mn = class extends bi {
        constructor(t = []) {
            super(),
                this.tracks_ = [],
                Object.defineProperty(this, "length", {
                    get() {
                        return this.tracks_.length
                    }
                });
            for (let e = 0; e < t.length; e++)
                this.addTrack(t[e])
        }
        addTrack(t) {
            const e = this.tracks_.length;
            "" + e in this || Object.defineProperty(this, e, {
                get() {
                    return this.tracks_[e]
                }
            }),
                this.tracks_.indexOf(t) === -1 && (this.tracks_.push(t),
                    this.trigger({
                        track: t,
                        type: "addtrack",
                        target: this
                    })),
                t.labelchange_ = () => {
                    this.trigger({
                        track: t,
                        type: "labelchange",
                        target: this
                    })
                }
                ,
                Ts(t) && t.addEventListener("labelchange", t.labelchange_)
        }
        removeTrack(t) {
            let e;
            for (let s = 0, r = this.length; s < r; s++)
                if (this[s] === t) {
                    e = this[s],
                        e.off && e.off(),
                        this.tracks_.splice(s, 1);
                    break
                }
            e && this.trigger({
                track: e,
                type: "removetrack",
                target: this
            })
        }
        getTrackById(t) {
            let e = null;
            for (let s = 0, r = this.length; s < r; s++) {
                const n = this[s];
                if (n.id === t) {
                    e = n;
                    break
                }
            }
            return e
        }
    }
        ;
    mn.prototype.allowedEvents_ = {
        change: "change",
        addtrack: "addtrack",
        removetrack: "removetrack",
        labelchange: "labelchange"
    };
    for (const t in mn.prototype.allowedEvents_)
        mn.prototype["on" + t] = null;
    var Uh = function (t, e) {
        for (let s = 0; s < t.length; s++)
            !Object.keys(t[s]).length || e.id === t[s].id || (t[s].enabled = !1)
    }
        , W0 = class extends mn {
            constructor(t = []) {
                for (let e = t.length - 1; e >= 0; e--)
                    if (t[e].enabled) {
                        Uh(t, t[e]);
                        break
                    }
                super(t),
                    this.changing_ = !1
            }
            addTrack(t) {
                t.enabled && Uh(this, t),
                    super.addTrack(t),
                    t.addEventListener && (t.enabledChange_ = () => {
                        this.changing_ || (this.changing_ = !0,
                            Uh(this, t),
                            this.changing_ = !1,
                            this.trigger("change"))
                    }
                        ,
                        t.addEventListener("enabledchange", t.enabledChange_))
            }
            removeTrack(t) {
                super.removeTrack(t),
                    t.removeEventListener && t.enabledChange_ && (t.removeEventListener("enabledchange", t.enabledChange_),
                        t.enabledChange_ = null)
            }
        }
        , jh = function (t, e) {
            for (let s = 0; s < t.length; s++)
                !Object.keys(t[s]).length || e.id === t[s].id || (t[s].selected = !1)
        }
        , K0 = class extends mn {
            constructor(t = []) {
                for (let e = t.length - 1; e >= 0; e--)
                    if (t[e].selected) {
                        jh(t, t[e]);
                        break
                    }
                super(t),
                    this.changing_ = !1,
                    Object.defineProperty(this, "selectedIndex", {
                        get() {
                            for (let e = 0; e < this.length; e++)
                                if (this[e].selected)
                                    return e;
                            return -1
                        },
                        set() { }
                    })
            }
            addTrack(t) {
                t.selected && jh(this, t),
                    super.addTrack(t),
                    t.addEventListener && (t.selectedChange_ = () => {
                        this.changing_ || (this.changing_ = !0,
                            jh(this, t),
                            this.changing_ = !1,
                            this.trigger("change"))
                    }
                        ,
                        t.addEventListener("selectedchange", t.selectedChange_))
            }
            removeTrack(t) {
                super.removeTrack(t),
                    t.removeEventListener && t.selectedChange_ && (t.removeEventListener("selectedchange", t.selectedChange_),
                        t.selectedChange_ = null)
            }
        }
        , zf = class extends mn {
            addTrack(t) {
                super.addTrack(t),
                    this.queueChange_ || (this.queueChange_ = () => this.queueTrigger("change")),
                    this.triggerSelectedlanguagechange || (this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange")),
                    t.addEventListener("modechange", this.queueChange_),
                    ["metadata", "chapters"].indexOf(t.kind) === -1 && t.addEventListener("modechange", this.triggerSelectedlanguagechange_)
            }
            removeTrack(t) {
                super.removeTrack(t),
                    t.removeEventListener && (this.queueChange_ && t.removeEventListener("modechange", this.queueChange_),
                        this.selectedlanguagechange_ && t.removeEventListener("modechange", this.triggerSelectedlanguagechange_))
            }
        }
        , X0 = class {
            constructor(t = []) {
                this.trackElements_ = [],
                    Object.defineProperty(this, "length", {
                        get() {
                            return this.trackElements_.length
                        }
                    });
                for (let e = 0, s = t.length; e < s; e++)
                    this.addTrackElement_(t[e])
            }
            addTrackElement_(t) {
                const e = this.trackElements_.length;
                "" + e in this || Object.defineProperty(this, e, {
                    get() {
                        return this.trackElements_[e]
                    }
                }),
                    this.trackElements_.indexOf(t) === -1 && this.trackElements_.push(t)
            }
            getTrackElementByTrack_(t) {
                let e;
                for (let s = 0, r = this.trackElements_.length; s < r; s++)
                    if (t === this.trackElements_[s].track) {
                        e = this.trackElements_[s];
                        break
                    }
                return e
            }
            removeTrackElement_(t) {
                for (let e = 0, s = this.trackElements_.length; e < s; e++)
                    if (t === this.trackElements_[e]) {
                        this.trackElements_[e].track && typeof this.trackElements_[e].track.off == "function" && this.trackElements_[e].track.off(),
                            typeof this.trackElements_[e].off == "function" && this.trackElements_[e].off(),
                            this.trackElements_.splice(e, 1);
                        break
                    }
            }
        }
        , Gf = class Dv {
            constructor(e) {
                Dv.prototype.setCues_.call(this, e),
                    Object.defineProperty(this, "length", {
                        get() {
                            return this.length_
                        }
                    })
            }
            setCues_(e) {
                const s = this.length || 0;
                let r = 0;
                const n = e.length;
                this.cues_ = e,
                    this.length_ = e.length;
                const a = function (o) {
                    "" + o in this || Object.defineProperty(this, "" + o, {
                        get() {
                            return this.cues_[o]
                        }
                    })
                };
                if (s < n)
                    for (r = s; r < n; r++)
                        a.call(this, r)
            }
            getCueById(e) {
                let s = null;
                for (let r = 0, n = this.length; r < n; r++) {
                    const a = this[r];
                    if (a.id === e) {
                        s = a;
                        break
                    }
                }
                return s
            }
        }
        , Y0 = {
            alternative: "alternative",
            captions: "captions",
            main: "main",
            sign: "sign",
            subtitles: "subtitles",
            commentary: "commentary"
        }
        , Q0 = {
            alternative: "alternative",
            descriptions: "descriptions",
            main: "main",
            "main-desc": "main-desc",
            translation: "translation",
            commentary: "commentary"
        }
        , J0 = {
            subtitles: "subtitles",
            captions: "captions",
            descriptions: "descriptions",
            chapters: "chapters",
            metadata: "metadata"
        }
        , Wf = {
            disabled: "disabled",
            hidden: "hidden",
            showing: "showing"
        }
        , Hh = class extends bi {
            constructor(t = {}) {
                super();
                const e = {
                    id: t.id || "vjs_track_" + Zi(),
                    kind: t.kind || "",
                    language: t.language || ""
                };
                let s = t.label || "";
                for (const r in e)
                    Object.defineProperty(this, r, {
                        get() {
                            return e[r]
                        },
                        set() { }
                    });
                Object.defineProperty(this, "label", {
                    get() {
                        return s
                    },
                    set(r) {
                        r !== s && (s = r,
                            this.trigger("labelchange"))
                    }
                })
            }
        }
        , qh = function (t) {
            const e = ["protocol", "hostname", "port", "pathname", "search", "hash", "host"]
                , s = le.default.createElement("a");
            s.href = t;
            const r = {};
            for (let n = 0; n < e.length; n++)
                r[e[n]] = s[e[n]];
            return r.protocol === "http:" && (r.host = r.host.replace(/:80$/, "")),
                r.protocol === "https:" && (r.host = r.host.replace(/:443$/, "")),
                r.protocol || (r.protocol = O.default.location.protocol),
                r.host || (r.host = O.default.location.host),
                r
        }
        , Kf = function (t) {
            if (!t.match(/^https?:\/\//)) {
                const e = le.default.createElement("a");
                e.href = t,
                    t = e.href
            }
            return t
        }
        , $h = function (t) {
            if (typeof t == "string") {
                const s = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/.exec(t);
                if (s)
                    return s.pop().toLowerCase()
            }
            return ""
        }
        , dl = function (t, e = O.default.location) {
            const s = qh(t);
            return (s.protocol === ":" ? e.protocol : s.protocol) + s.host !== e.protocol + e.host
        }
        , Z0 = Object.freeze({
            __proto__: null,
            parseUrl: qh,
            getAbsoluteURL: Kf,
            getFileExtension: $h,
            isCrossOrigin: dl
        })
        , Xf = function (t, e) {
            const s = new O.default.WebVTT.Parser(O.default, O.default.vttjs, O.default.WebVTT.StringDecoder())
                , r = [];
            s.oncue = function (n) {
                e.addCue(n)
            }
                ,
                s.onparsingerror = function (n) {
                    r.push(n)
                }
                ,
                s.onflush = function () {
                    e.trigger({
                        type: "loadeddata",
                        target: e
                    })
                }
                ,
                s.parse(t),
                r.length > 0 && (O.default.console && O.default.console.groupCollapsed && O.default.console.groupCollapsed(`Text Track parsing errors for ${e.src}`),
                    r.forEach(n => Ie.error(n)),
                    O.default.console && O.default.console.groupEnd && O.default.console.groupEnd()),
                s.flush()
        }
        , Yf = function (t, e) {
            const s = {
                uri: t
            }
                , r = dl(t);
            r && (s.cors = r);
            const n = e.tech_.crossOrigin() === "use-credentials";
            n && (s.withCredentials = n),
                (0,
                    Dc.default)(s, Ge(this, function (a, o, u) {
                        if (a)
                            return Ie.error(a, o);
                        e.loaded_ = !0,
                            typeof O.default.WebVTT != "function" ? e.tech_ && e.tech_.any(["vttjsloaded", "vttjserror"], c => {
                                if (c.type === "vttjserror") {
                                    Ie.error(`vttjs failed to load, stopping trying to process ${e.src}`);
                                    return
                                }
                                return Xf(u, e)
                            }
                            ) : Xf(u, e)
                    }))
        }
        , Da = class extends Hh {
            constructor(t = {}) {
                if (!t.tech)
                    throw new Error("A tech was not provided.");
                const e = ze(t, {
                    kind: J0[t.kind] || "subtitles",
                    language: t.language || t.srclang || ""
                });
                let s = Wf[e.mode] || "disabled";
                const r = e.default;
                (e.kind === "metadata" || e.kind === "chapters") && (s = "hidden"),
                    super(e),
                    this.tech_ = e.tech,
                    this.cues_ = [],
                    this.activeCues_ = [],
                    this.preload_ = this.tech_.preloadTextTracks !== !1;
                const n = new Gf(this.cues_)
                    , a = new Gf(this.activeCues_);
                let o = !1;
                this.timeupdateHandler = Ge(this, function (c = {}) {
                    if (!this.tech_.isDisposed()) {
                        if (!this.tech_.isReady_) {
                            c.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler));
                            return
                        }
                        this.activeCues = this.activeCues,
                            o && (this.trigger("cuechange"),
                                o = !1),
                            c.type !== "timeupdate" && (this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler))
                    }
                });
                const u = () => {
                    this.stopTracking()
                }
                    ;
                this.tech_.one("dispose", u),
                    s !== "disabled" && this.startTracking(),
                    Object.defineProperties(this, {
                        default: {
                            get() {
                                return r
                            },
                            set() { }
                        },
                        mode: {
                            get() {
                                return s
                            },
                            set(c) {
                                Wf[c] && s !== c && (s = c,
                                    !this.preload_ && s !== "disabled" && this.cues.length === 0 && Yf(this.src, this),
                                    this.stopTracking(),
                                    s !== "disabled" && this.startTracking(),
                                    this.trigger("modechange"))
                            }
                        },
                        cues: {
                            get() {
                                return this.loaded_ ? n : null
                            },
                            set() { }
                        },
                        activeCues: {
                            get() {
                                if (!this.loaded_)
                                    return null;
                                if (this.cues.length === 0)
                                    return a;
                                const c = this.tech_.currentTime()
                                    , f = [];
                                for (let v = 0, T = this.cues.length; v < T; v++) {
                                    const D = this.cues[v];
                                    D.startTime <= c && D.endTime >= c && f.push(D)
                                }
                                if (o = !1,
                                    f.length !== this.activeCues_.length)
                                    o = !0;
                                else
                                    for (let v = 0; v < f.length; v++)
                                        this.activeCues_.indexOf(f[v]) === -1 && (o = !0);
                                return this.activeCues_ = f,
                                    a.setCues_(this.activeCues_),
                                    a
                            },
                            set() { }
                        }
                    }),
                    e.src ? (this.src = e.src,
                        this.preload_ || (this.loaded_ = !0),
                        (this.preload_ || e.kind !== "subtitles" && e.kind !== "captions") && Yf(this.src, this)) : this.loaded_ = !0
            }
            startTracking() {
                this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler),
                    this.tech_.on("timeupdate", this.timeupdateHandler)
            }
            stopTracking() {
                this.rvf_ && (this.tech_.cancelVideoFrameCallback(this.rvf_),
                    this.rvf_ = void 0),
                    this.tech_.off("timeupdate", this.timeupdateHandler)
            }
            addCue(t) {
                let e = t;
                if (!("getCueAsHTML" in e)) {
                    e = new O.default.vttjs.VTTCue(t.startTime, t.endTime, t.text);
                    for (const r in t)
                        r in e || (e[r] = t[r]);
                    e.id = t.id,
                        e.originalCue_ = t
                }
                const s = this.tech_.textTracks();
                for (let r = 0; r < s.length; r++)
                    s[r] !== this && s[r].removeCue(e);
                this.cues_.push(e),
                    this.cues.setCues_(this.cues_)
            }
            removeCue(t) {
                let e = this.cues_.length;
                for (; e--;) {
                    const s = this.cues_[e];
                    if (s === t || s.originalCue_ && s.originalCue_ === t) {
                        this.cues_.splice(e, 1),
                            this.cues.setCues_(this.cues_);
                        break
                    }
                }
            }
        }
        ;
    Da.prototype.allowedEvents_ = {
        cuechange: "cuechange"
    };
    var Qf = class extends Hh {
        constructor(t = {}) {
            const e = ze(t, {
                kind: Q0[t.kind] || ""
            });
            super(e);
            let s = !1;
            Object.defineProperty(this, "enabled", {
                get() {
                    return s
                },
                set(r) {
                    typeof r != "boolean" || r === s || (s = r,
                        this.trigger("enabledchange"))
                }
            }),
                e.enabled && (this.enabled = e.enabled),
                this.loaded_ = !0
        }
    }
        , Jf = class extends Hh {
            constructor(t = {}) {
                const e = ze(t, {
                    kind: Y0[t.kind] || ""
                });
                super(e);
                let s = !1;
                Object.defineProperty(this, "selected", {
                    get() {
                        return s
                    },
                    set(r) {
                        typeof r != "boolean" || r === s || (s = r,
                            this.trigger("selectedchange"))
                    }
                }),
                    e.selected && (this.selected = e.selected)
            }
        }
        , gn = class pc extends bi {
            constructor(e = {}) {
                super();
                let s;
                const r = new Da(e);
                this.kind = r.kind,
                    this.src = r.src,
                    this.srclang = r.language,
                    this.label = r.label,
                    this.default = r.default,
                    Object.defineProperties(this, {
                        readyState: {
                            get() {
                                return s
                            }
                        },
                        track: {
                            get() {
                                return r
                            }
                        }
                    }),
                    s = pc.NONE,
                    r.addEventListener("loadeddata", () => {
                        s = pc.LOADED,
                            this.trigger({
                                type: "load",
                                target: this
                            })
                    }
                    )
            }
        }
        ;
    gn.prototype.allowedEvents_ = {
        load: "load"
    },
        gn.NONE = 0,
        gn.LOADING = 1,
        gn.LOADED = 2,
        gn.ERROR = 3;
    var Ei = {
        audio: {
            ListClass: W0,
            TrackClass: Qf,
            capitalName: "Audio"
        },
        video: {
            ListClass: K0,
            TrackClass: Jf,
            capitalName: "Video"
        },
        text: {
            ListClass: zf,
            TrackClass: Da,
            capitalName: "Text"
        }
    };
    Object.keys(Ei).forEach(function (t) {
        Ei[t].getterName = `${t}Tracks`,
            Ei[t].privateName = `${t}Tracks_`
    });
    var vn = {
        remoteText: {
            ListClass: zf,
            TrackClass: Da,
            capitalName: "RemoteText",
            getterName: "remoteTextTracks",
            privateName: "remoteTextTracks_"
        },
        remoteTextEl: {
            ListClass: X0,
            TrackClass: gn,
            capitalName: "RemoteTextTrackEls",
            getterName: "remoteTextTrackEls",
            privateName: "remoteTextTrackEls_"
        }
    }
        , $t = Object.assign({}, Ei, vn);
    vn.names = Object.keys(vn),
        Ei.names = Object.keys(Ei),
        $t.names = [].concat(vn.names).concat(Ei.names);
    function eT(t, e, s, r, n = {}) {
        const a = t.textTracks();
        n.kind = e,
            s && (n.label = s),
            r && (n.language = r),
            n.tech = t;
        const o = new $t.text.TrackClass(n);
        return a.addTrack(o),
            o
    }
    var He = class Ft extends J {
        constructor(e = {}, s = function () { }
        ) {
            e.reportTouchActivity = !1,
                super(null, e, s),
                this.onDurationChange_ = r => this.onDurationChange(r),
                this.trackProgress_ = r => this.trackProgress(r),
                this.trackCurrentTime_ = r => this.trackCurrentTime(r),
                this.stopTrackingCurrentTime_ = r => this.stopTrackingCurrentTime(r),
                this.disposeSourceHandler_ = r => this.disposeSourceHandler(r),
                this.queuedHanders_ = new Set,
                this.hasStarted_ = !1,
                this.on("playing", function () {
                    this.hasStarted_ = !0
                }),
                this.on("loadstart", function () {
                    this.hasStarted_ = !1
                }),
                $t.names.forEach(r => {
                    const n = $t[r];
                    e && e[n.getterName] && (this[n.privateName] = e[n.getterName])
                }
                ),
                this.featuresProgressEvents || this.manualProgressOn(),
                this.featuresTimeupdateEvents || this.manualTimeUpdatesOn(),
                ["Text", "Audio", "Video"].forEach(r => {
                    e[`native${r}Tracks`] === !1 && (this[`featuresNative${r}Tracks`] = !1)
                }
                ),
                e.nativeCaptions === !1 || e.nativeTextTracks === !1 ? this.featuresNativeTextTracks = !1 : (e.nativeCaptions === !0 || e.nativeTextTracks === !0) && (this.featuresNativeTextTracks = !0),
                this.featuresNativeTextTracks || this.emulateTextTracks(),
                this.preloadTextTracks = e.preloadTextTracks !== !1,
                this.autoRemoteTextTracks_ = new $t.text.ListClass,
                this.initTrackListeners(),
                e.nativeControlsForTouch || this.emitTapEvents(),
                this.constructor && (this.name_ = this.constructor.name || "Unknown Tech")
        }
        triggerSourceset(e) {
            this.isReady_ || this.one("ready", () => this.setTimeout(() => this.triggerSourceset(e), 1)),
                this.trigger({
                    src: e,
                    type: "sourceset"
                })
        }
        manualProgressOn() {
            this.on("durationchange", this.onDurationChange_),
                this.manualProgress = !0,
                this.one("ready", this.trackProgress_)
        }
        manualProgressOff() {
            this.manualProgress = !1,
                this.stopTrackingProgress(),
                this.off("durationchange", this.onDurationChange_)
        }
        trackProgress(e) {
            this.stopTrackingProgress(),
                this.progressInterval = this.setInterval(Ge(this, function () {
                    const s = this.bufferedPercent();
                    this.bufferedPercent_ !== s && this.trigger("progress"),
                        this.bufferedPercent_ = s,
                        s === 1 && this.stopTrackingProgress()
                }), 500)
        }
        onDurationChange(e) {
            this.duration_ = this.duration()
        }
        buffered() {
            return Li(0, 0)
        }
        bufferedPercent() {
            return $f(this.buffered(), this.duration_)
        }
        stopTrackingProgress() {
            this.clearInterval(this.progressInterval)
        }
        manualTimeUpdatesOn() {
            this.manualTimeUpdates = !0,
                this.on("play", this.trackCurrentTime_),
                this.on("pause", this.stopTrackingCurrentTime_)
        }
        manualTimeUpdatesOff() {
            this.manualTimeUpdates = !1,
                this.stopTrackingCurrentTime(),
                this.off("play", this.trackCurrentTime_),
                this.off("pause", this.stopTrackingCurrentTime_)
        }
        trackCurrentTime() {
            this.currentTimeInterval && this.stopTrackingCurrentTime(),
                this.currentTimeInterval = this.setInterval(function () {
                    this.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: !0
                    })
                }, 250)
        }
        stopTrackingCurrentTime() {
            this.clearInterval(this.currentTimeInterval),
                this.trigger({
                    type: "timeupdate",
                    target: this,
                    manuallyTriggered: !0
                })
        }
        dispose() {
            this.clearTracks(Ei.names),
                this.manualProgress && this.manualProgressOff(),
                this.manualTimeUpdates && this.manualTimeUpdatesOff(),
                super.dispose()
        }
        clearTracks(e) {
            e = [].concat(e),
                e.forEach(s => {
                    const r = this[`${s}Tracks`]() || [];
                    let n = r.length;
                    for (; n--;) {
                        const a = r[n];
                        s === "text" && this.removeRemoteTextTrack(a),
                            r.removeTrack(a)
                    }
                }
                )
        }
        cleanupAutoTextTracks() {
            const e = this.autoRemoteTextTracks_ || [];
            let s = e.length;
            for (; s--;) {
                const r = e[s];
                this.removeRemoteTextTrack(r)
            }
        }
        reset() { }
        crossOrigin() { }
        setCrossOrigin() { }
        error(e) {
            return e !== void 0 && (this.error_ = new qt(e),
                this.trigger("error")),
                this.error_
        }
        played() {
            return this.hasStarted_ ? Li(0, 0) : Li()
        }
        play() { }
        setScrubbing(e) { }
        scrubbing() { }
        setCurrentTime(e) {
            this.manualTimeUpdates && this.trigger({
                type: "timeupdate",
                target: this,
                manuallyTriggered: !0
            })
        }
        initTrackListeners() {
            Ei.names.forEach(e => {
                const s = Ei[e]
                    , r = () => {
                        this.trigger(`${e}trackchange`)
                    }
                    , n = this[s.getterName]();
                n.addEventListener("removetrack", r),
                    n.addEventListener("addtrack", r),
                    this.on("dispose", () => {
                        n.removeEventListener("removetrack", r),
                            n.removeEventListener("addtrack", r)
                    }
                    )
            }
            )
        }
        addWebVttScript_() {
            if (!O.default.WebVTT)
                if (le.default.body.contains(this.el())) {
                    if (!this.options_["vtt.js"] && nn(kc.default) && Object.keys(kc.default).length > 0) {
                        this.trigger("vttjsloaded");
                        return
                    }
                    const e = le.default.createElement("script");
                    e.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js",
                        e.onload = () => {
                            this.trigger("vttjsloaded")
                        }
                        ,
                        e.onerror = () => {
                            this.trigger("vttjserror")
                        }
                        ,
                        this.on("dispose", () => {
                            e.onload = null,
                                e.onerror = null
                        }
                        ),
                        O.default.WebVTT = !0,
                        this.el().parentNode.appendChild(e)
                } else
                    this.ready(this.addWebVttScript_)
        }
        emulateTextTracks() {
            const e = this.textTracks()
                , s = this.remoteTextTracks()
                , r = u => e.addTrack(u.track)
                , n = u => e.removeTrack(u.track);
            s.on("addtrack", r),
                s.on("removetrack", n),
                this.addWebVttScript_();
            const a = () => this.trigger("texttrackchange")
                , o = () => {
                    a();
                    for (let u = 0; u < e.length; u++) {
                        const c = e[u];
                        c.removeEventListener("cuechange", a),
                            c.mode === "showing" && c.addEventListener("cuechange", a)
                    }
                }
                ;
            o(),
                e.addEventListener("change", o),
                e.addEventListener("addtrack", o),
                e.addEventListener("removetrack", o),
                this.on("dispose", function () {
                    s.off("addtrack", r),
                        s.off("removetrack", n),
                        e.removeEventListener("change", o),
                        e.removeEventListener("addtrack", o),
                        e.removeEventListener("removetrack", o);
                    for (let u = 0; u < e.length; u++)
                        e[u].removeEventListener("cuechange", a)
                })
        }
        addTextTrack(e, s, r) {
            if (!e)
                throw new Error("TextTrack kind is required but was not provided");
            return eT(this, e, s, r)
        }
        createRemoteTextTrack(e) {
            const s = ze(e, {
                tech: this
            });
            return new vn.remoteTextEl.TrackClass(s)
        }
        addRemoteTextTrack(e = {}, s) {
            const r = this.createRemoteTextTrack(e);
            return typeof s != "boolean" && (s = !1),
                this.remoteTextTrackEls().addTrackElement_(r),
                this.remoteTextTracks().addTrack(r.track),
                s === !1 && this.ready(() => this.autoRemoteTextTracks_.addTrack(r.track)),
                r
        }
        removeRemoteTextTrack(e) {
            const s = this.remoteTextTrackEls().getTrackElementByTrack_(e);
            this.remoteTextTrackEls().removeTrackElement_(s),
                this.remoteTextTracks().removeTrack(e),
                this.autoRemoteTextTracks_.removeTrack(e)
        }
        getVideoPlaybackQuality() {
            return {}
        }
        requestPictureInPicture() {
            return Promise.reject()
        }
        disablePictureInPicture() {
            return !0
        }
        setDisablePictureInPicture() { }
        requestVideoFrameCallback(e) {
            const s = Zi();
            return !this.isReady_ || this.paused() ? (this.queuedHanders_.add(s),
                this.one("playing", () => {
                    this.queuedHanders_.has(s) && (this.queuedHanders_.delete(s),
                        e())
                }
                )) : this.requestNamedAnimationFrame(s, e),
                s
        }
        cancelVideoFrameCallback(e) {
            this.queuedHanders_.has(e) ? this.queuedHanders_.delete(e) : this.cancelNamedAnimationFrame(e)
        }
        setPoster() { }
        playsinline() { }
        setPlaysinline() { }
        overrideNativeAudioTracks(e) { }
        overrideNativeVideoTracks(e) { }
        canPlayType(e) {
            return ""
        }
        static canPlayType(e) {
            return ""
        }
        static canPlaySource(e, s) {
            return Ft.canPlayType(e.type)
        }
        static isTech(e) {
            return e.prototype instanceof Ft || e instanceof Ft || e === Ft
        }
        static registerTech(e, s) {
            if (Ft.techs_ || (Ft.techs_ = {}),
                !Ft.isTech(s))
                throw new Error(`Tech ${e} must be a Tech`);
            if (!Ft.canPlayType)
                throw new Error("Techs must have a static canPlayType method on them");
            if (!Ft.canPlaySource)
                throw new Error("Techs must have a static canPlaySource method on them");
            return e = tt(e),
                Ft.techs_[e] = s,
                Ft.techs_[Aa(e)] = s,
                e !== "Tech" && Ft.defaultTechOrder_.push(e),
                s
        }
        static getTech(e) {
            if (e) {
                if (Ft.techs_ && Ft.techs_[e])
                    return Ft.techs_[e];
                if (e = tt(e),
                    O.default && O.default.videojs && O.default.videojs[e])
                    return Ie.warn(`The ${e} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`),
                        O.default.videojs[e]
            }
        }
    }
        ;
    $t.names.forEach(function (t) {
        const e = $t[t];
        He.prototype[e.getterName] = function () {
            return this[e.privateName] = this[e.privateName] || new e.ListClass,
                this[e.privateName]
        }
    }),
        He.prototype.featuresVolumeControl = !0,
        He.prototype.featuresMuteControl = !0,
        He.prototype.featuresFullscreenResize = !1,
        He.prototype.featuresPlaybackRate = !1,
        He.prototype.featuresProgressEvents = !1,
        He.prototype.featuresSourceset = !1,
        He.prototype.featuresTimeupdateEvents = !1,
        He.prototype.featuresNativeTextTracks = !1,
        He.prototype.featuresVideoFrameCallback = !1,
        He.withSourceHandlers = function (t) {
            t.registerSourceHandler = function (s, r) {
                let n = t.sourceHandlers;
                n || (n = t.sourceHandlers = []),
                    r === void 0 && (r = n.length),
                    n.splice(r, 0, s)
            }
                ,
                t.canPlayType = function (s) {
                    const r = t.sourceHandlers || [];
                    let n;
                    for (let a = 0; a < r.length; a++)
                        if (n = r[a].canPlayType(s),
                            n)
                            return n;
                    return ""
                }
                ,
                t.selectSourceHandler = function (s, r) {
                    const n = t.sourceHandlers || [];
                    let a;
                    for (let o = 0; o < n.length; o++)
                        if (a = n[o].canHandleSource(s, r),
                            a)
                            return n[o];
                    return null
                }
                ,
                t.canPlaySource = function (s, r) {
                    const n = t.selectSourceHandler(s, r);
                    return n ? n.canHandleSource(s, r) : ""
                }
                ,
                ["seekable", "seeking", "duration"].forEach(function (s) {
                    const r = this[s];
                    typeof r == "function" && (this[s] = function () {
                        return this.sourceHandler_ && this.sourceHandler_[s] ? this.sourceHandler_[s].apply(this.sourceHandler_, arguments) : r.apply(this, arguments)
                    }
                    )
                }, t.prototype),
                t.prototype.setSource = function (s) {
                    let r = t.selectSourceHandler(s, this.options_);
                    r || (t.nativeSourceHandler ? r = t.nativeSourceHandler : Ie.error("No source handler found for the current source.")),
                        this.disposeSourceHandler(),
                        this.off("dispose", this.disposeSourceHandler_),
                        r !== t.nativeSourceHandler && (this.currentSource_ = s),
                        this.sourceHandler_ = r.handleSource(s, this, this.options_),
                        this.one("dispose", this.disposeSourceHandler_)
                }
                ,
                t.prototype.disposeSourceHandler = function () {
                    this.currentSource_ && (this.clearTracks(["audio", "video"]),
                        this.currentSource_ = null),
                        this.cleanupAutoTextTracks(),
                        this.sourceHandler_ && (this.sourceHandler_.dispose && this.sourceHandler_.dispose(),
                            this.sourceHandler_ = null)
                }
        }
        ,
        J.registerComponent("Tech", He),
        He.registerTech("Tech", He),
        He.defaultTechOrder_ = [];
    var Tr = {}
        , Vh = {}
        , cl = {};
    function tT(t, e) {
        Tr[t] = Tr[t] || [],
            Tr[t].push(e)
    }
    function iT(t, e, s) {
        t.setTimeout(() => br(e, Tr[e.type], s, t), 1)
    }
    function sT(t, e) {
        t.forEach(s => s.setTech && s.setTech(e))
    }
    function rT(t, e, s) {
        return t.reduceRight(zh(s), e[s]())
    }
    function nT(t, e, s, r) {
        return e[s](t.reduce(zh(s), r))
    }
    function Zf(t, e, s, r = null) {
        const n = "call" + tt(s)
            , a = t.reduce(zh(n), r)
            , o = a === cl
            , u = o ? null : e[s](a);
        return lT(t, s, u, o),
            u
    }
    var aT = {
        buffered: 1,
        currentTime: 1,
        duration: 1,
        muted: 1,
        played: 1,
        paused: 1,
        seekable: 1,
        volume: 1,
        ended: 1
    }
        , oT = {
            setCurrentTime: 1,
            setMuted: 1,
            setVolume: 1
        }
        , ep = {
            play: 1,
            pause: 1
        };
    function zh(t) {
        return (e, s) => e === cl ? cl : s[t] ? s[t](e) : e
    }
    function lT(t, e, s, r) {
        for (let n = t.length - 1; n >= 0; n--) {
            const a = t[n];
            a[e] && a[e](r, s)
        }
    }
    function uT(t) {
        Vh[t.id()] = null
    }
    function hT(t, e) {
        const s = Vh[t.id()];
        let r = null;
        if (s == null)
            return r = e(t),
                Vh[t.id()] = [[e, r]],
                r;
        for (let n = 0; n < s.length; n++) {
            const [a, o] = s[n];
            a === e && (r = o)
        }
        return r === null && (r = e(t),
            s.push([e, r])),
            r
    }
    function br(t = {}, e = [], s, r, n = [], a = !1) {
        const [o, ...u] = e;
        if (typeof o == "string")
            br(t, Tr[o], s, r, n, a);
        else if (o) {
            const c = hT(r, o);
            if (!c.setSource)
                return n.push(c),
                    br(t, u, s, r, n, a);
            c.setSource(Object.assign({}, t), function (f, v) {
                if (f)
                    return br(t, u, s, r, n, a);
                n.push(c),
                    br(v, t.type === v.type ? u : Tr[v.type], s, r, n, a)
            })
        } else
            u.length ? br(t, u, s, r, n, a) : a ? s(t, n) : br(t, Tr["*"], s, r, n, !0)
    }
    var dT = {
        opus: "video/ogg",
        ogv: "video/ogg",
        mp4: "video/mp4",
        mov: "video/mp4",
        m4v: "video/mp4",
        mkv: "video/x-matroska",
        m4a: "audio/mp4",
        mp3: "audio/mpeg",
        aac: "audio/aac",
        caf: "audio/x-caf",
        flac: "audio/flac",
        oga: "audio/ogg",
        wav: "audio/wav",
        m3u8: "application/x-mpegURL",
        mpd: "application/dash+xml",
        jpg: "image/jpeg",
        jpeg: "image/jpeg",
        gif: "image/gif",
        png: "image/png",
        svg: "image/svg+xml",
        webp: "image/webp"
    }
        , fl = function (t = "") {
            const e = $h(t);
            return dT[e.toLowerCase()] || ""
        }
        , cT = (t, e) => {
            if (!e)
                return "";
            if (t.cache_.source.src === e && t.cache_.source.type)
                return t.cache_.source.type;
            const s = t.cache_.sources.filter(n => n.src === e);
            if (s.length)
                return s[0].type;
            const r = t.$$("source");
            for (let n = 0; n < r.length; n++) {
                const a = r[n];
                if (a.type && a.src && a.src === e)
                    return a.type
            }
            return fl(e)
        }
        , tp = function (t) {
            if (Array.isArray(t)) {
                let e = [];
                t.forEach(function (s) {
                    s = tp(s),
                        Array.isArray(s) ? e = e.concat(s) : Yi(s) && e.push(s)
                }),
                    t = e
            } else
                typeof t == "string" && t.trim() ? t = [ip({
                    src: t
                })] : Yi(t) && typeof t.src == "string" && t.src && t.src.trim() ? t = [ip(t)] : t = [];
            return t
        };
    function ip(t) {
        if (!t.type) {
            const e = fl(t.src);
            e && (t.type = e)
        }
        return t
    }
    var fT = `<svg xmlns="http://www.w3.org/2000/svg">
  <defs>
    <symbol viewBox="0 0 48 48" id="vjs-icon-play">
      <path d="M16 10v28l22-14z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-pause">
      <path d="M12 38h8V10h-8v28zm16-28v28h8V10h-8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-audio">
      <path d="M24 2C14.06 2 6 10.06 6 20v14c0 3.31 2.69 6 6 6h6V24h-8v-4c0-7.73 6.27-14 14-14s14 6.27 14 14v4h-8v16h6c3.31 0 6-2.69 6-6V20c0-9.94-8.06-18-18-18z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-captions">
      <path d="M38 8H10c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM22 22h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2zm14 0h-3v-1h-4v6h4v-1h3v2a2 2 0 0 1-2 2h-6a2 2 0 0 1-2-2v-8a2 2 0 0 1 2-2h6a2 2 0 0 1 2 2v2z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-subtitles">
      <path d="M40 8H8c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h32c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zM8 24h8v4H8v-4zm20 12H8v-4h20v4zm12 0h-8v-4h8v4zm0-8H20v-4h20v4z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-enter">
      <path d="M14 28h-4v10h10v-4h-6v-6zm-4-8h4v-6h6v-4H10v10zm24 14h-6v4h10V28h-4v6zm-6-24v4h6v6h4V10H28z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-fullscreen-exit">
      <path d="M10 32h6v6h4V28H10v4zm6-16h-6v4h10V10h-4v6zm12 22h4v-6h6v-4H28v10zm4-22v-6h-4v10h10v-4h-6z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-play-circle">
      <path d="M20 33l12-9-12-9v18zm4-29C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-mute">
      <path d="M33 24c0-3.53-2.04-6.58-5-8.05v4.42l4.91 4.91c.06-.42.09-.85.09-1.28zm5 0c0 1.88-.41 3.65-1.08 5.28l3.03 3.03C41.25 29.82 42 27 42 24c0-8.56-5.99-15.72-14-17.54v4.13c5.78 1.72 10 7.07 10 13.41zM8.55 6L6 8.55 15.45 18H6v12h8l10 10V26.55l8.51 8.51c-1.34 1.03-2.85 1.86-4.51 2.36v4.13a17.94 17.94 0 0 0 7.37-3.62L39.45 42 42 39.45l-18-18L8.55 6zM24 8l-4.18 4.18L24 16.36V8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-low">
      <path d="M14 18v12h8l10 10V8L22 18h-8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-medium">
      <path d="M37 24c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zm-27-6v12h8l10 10V8L18 18h-8z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-volume-high">
      <path d="M6 18v12h8l10 10V8L14 18H6zm27 6c0-3.53-2.04-6.58-5-8.05v16.11c2.96-1.48 5-4.53 5-8.06zM28 6.46v4.13c5.78 1.72 10 7.07 10 13.41s-4.22 11.69-10 13.41v4.13c8.01-1.82 14-8.97 14-17.54S36.01 8.28 28 6.46z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-spinner">
      <path d="M18.8 21l9.53-16.51C26.94 4.18 25.49 4 24 4c-4.8 0-9.19 1.69-12.64 4.51l7.33 12.69.11-.2zm24.28-3c-1.84-5.85-6.3-10.52-11.99-12.68L23.77 18h19.31zm.52 2H28.62l.58 1 9.53 16.5C41.99 33.94 44 29.21 44 24c0-1.37-.14-2.71-.4-4zm-26.53 4l-7.8-13.5C6.01 14.06 4 18.79 4 24c0 1.37.14 2.71.4 4h14.98l-2.31-4zM4.92 30c1.84 5.85 6.3 10.52 11.99 12.68L24.23 30H4.92zm22.54 0l-7.8 13.51c1.4.31 2.85.49 4.34.49 4.8 0 9.19-1.69 12.64-4.51L29.31 26.8 27.46 30z"></path>
    </symbol>
    <symbol viewBox="0 0 24 24" id="vjs-icon-hd">
      <path d="M19 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-8 12H9.5v-2h-2v2H6V9h1.5v2.5h2V9H11v6zm2-6h4c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1h-4V9zm1.5 4.5h2v-3h-2v3z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-chapters">
      <path d="M6 26h4v-4H6v4zm0 8h4v-4H6v4zm0-16h4v-4H6v4zm8 8h28v-4H14v4zm0 8h28v-4H14v4zm0-20v4h28v-4H14z"></path>
    </symbol>
    <symbol viewBox="0 0 40 40" id="vjs-icon-downloading">
      <path d="M18.208 36.875q-3.208-.292-5.979-1.729-2.771-1.438-4.812-3.729-2.042-2.292-3.188-5.229-1.146-2.938-1.146-6.23 0-6.583 4.334-11.416 4.333-4.834 10.833-5.5v3.166q-5.167.75-8.583 4.646Q6.25 14.75 6.25 19.958q0 5.209 3.396 9.104 3.396 3.896 8.562 4.646zM20 28.417L11.542 20l2.083-2.083 4.917 4.916v-11.25h2.916v11.25l4.875-4.916L28.417 20zm1.792 8.458v-3.167q1.833-.25 3.541-.958 1.709-.708 3.167-1.875l2.333 2.292q-1.958 1.583-4.25 2.541-2.291.959-4.791 1.167zm6.791-27.792q-1.541-1.125-3.25-1.854-1.708-.729-3.541-1.021V3.042q2.5.25 4.77 1.208 2.271.958 4.271 2.5zm4.584 21.584l-2.25-2.25q1.166-1.5 1.854-3.209.687-1.708.937-3.541h3.209q-.292 2.5-1.229 4.791-.938 2.292-2.521 4.209zm.541-12.417q-.291-1.833-.958-3.562-.667-1.73-1.833-3.188l2.375-2.208q1.541 1.916 2.458 4.208.917 2.292 1.167 4.75z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download">
      <path d="M10.8 40.55q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h26.35v-7.7h3.4v7.7q0 1.4-1 2.4t-2.4 1zM24 32.1L13.9 22.05l2.45-2.45 5.95 5.95V7.15h3.4v18.4l5.95-5.95 2.45 2.45z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-done">
      <path d="M9.8 40.5v-3.45h28.4v3.45zm9.2-9.05L7.4 19.85l2.45-2.35L19 26.65l19.2-19.2 2.4 2.4z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-file-download-off">
      <path d="M4.9 4.75L43.25 43.1 41 45.3l-4.75-4.75q-.05.05-.075.025-.025-.025-.075-.025H10.8q-1.35 0-2.375-1T7.4 37.15v-7.7h3.4v7.7h22.05l-7-7-1.85 1.8L13.9 21.9l1.85-1.85L2.7 7zm26.75 14.7l2.45 2.45-3.75 3.8-2.45-2.5zM25.7 7.15V21.1l-3.4-3.45V7.15z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-share">
      <path d="M36 32.17c-1.52 0-2.89.59-3.93 1.54L17.82 25.4c.11-.45.18-.92.18-1.4s-.07-.95-.18-1.4l14.1-8.23c1.07 1 2.5 1.62 4.08 1.62 3.31 0 6-2.69 6-6s-2.69-6-6-6-6 2.69-6 6c0 .48.07.95.18 1.4l-14.1 8.23c-1.07-1-2.5-1.62-4.08-1.62-3.31 0-6 2.69-6 6s2.69 6 6 6c1.58 0 3.01-.62 4.08-1.62l14.25 8.31c-.1.42-.16.86-.16 1.31A5.83 5.83 0 1 0 36 32.17z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-cog">
      <path d="M38.86 25.95c.08-.64.14-1.29.14-1.95s-.06-1.31-.14-1.95l4.23-3.31c.38-.3.49-.84.24-1.28l-4-6.93c-.25-.43-.77-.61-1.22-.43l-4.98 2.01c-1.03-.79-2.16-1.46-3.38-1.97L29 4.84c-.09-.47-.5-.84-1-.84h-8c-.5 0-.91.37-.99.84l-.75 5.3a14.8 14.8 0 0 0-3.38 1.97L9.9 10.1a1 1 0 0 0-1.22.43l-4 6.93c-.25.43-.14.97.24 1.28l4.22 3.31C9.06 22.69 9 23.34 9 24s.06 1.31.14 1.95l-4.22 3.31c-.38.3-.49.84-.24 1.28l4 6.93c.25.43.77.61 1.22.43l4.98-2.01c1.03.79 2.16 1.46 3.38 1.97l.75 5.3c.08.47.49.84.99.84h8c.5 0 .91-.37.99-.84l.75-5.3a14.8 14.8 0 0 0 3.38-1.97l4.98 2.01a1 1 0 0 0 1.22-.43l4-6.93c.25-.43.14-.97-.24-1.28l-4.22-3.31zM24 31c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-square">
      <path d="M36 8H12c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h24c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4zm0 28H12V12h24v24z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-circle">
      <circle cx="24" cy="24" r="20"></circle>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-outline">
      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-circle-inner-circle">
      <path d="M24 4C12.97 4 4 12.97 4 24s8.97 20 20 20 20-8.97 20-20S35.03 4 24 4zm0 36c-8.82 0-16-7.18-16-16S15.18 8 24 8s16 7.18 16 16-7.18 16-16 16zm6-16c0 3.31-2.69 6-6 6s-6-2.69-6-6 2.69-6 6-6 6 2.69 6 6z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-cancel">
      <path d="M24 4C12.95 4 4 12.95 4 24s8.95 20 20 20 20-8.95 20-20S35.05 4 24 4zm10 27.17L31.17 34 24 26.83 16.83 34 14 31.17 21.17 24 14 16.83 16.83 14 24 21.17 31.17 14 34 16.83 26.83 24 34 31.17z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-replay">
      <path d="M24 10V2L14 12l10 10v-8c6.63 0 12 5.37 12 12s-5.37 12-12 12-12-5.37-12-12H8c0 8.84 7.16 16 16 16s16-7.16 16-16-7.16-16-16-16z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-repeat">
      <path d="M14 14h20v6l8-8-8-8v6H10v12h4v-8zm20 20H14v-6l-8 8 8 8v-6h24V26h-4v8z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-5">
      <path d="M17.689 98l-8.697 8.696 8.697 8.697 2.486-2.485-4.32-4.319h1.302c4.93 0 9.071 1.722 12.424 5.165 3.352 3.443 5.029 7.638 5.029 12.584h3.55c0-2.958-.553-5.73-1.658-8.313-1.104-2.583-2.622-4.841-4.555-6.774-1.932-1.932-4.19-3.45-6.773-4.555-2.584-1.104-5.355-1.657-8.313-1.657H15.5l4.615-4.615zm-8.08 21.659v13.861h11.357v5.008H9.609V143h12.7c.834 0 1.55-.298 2.146-.894.596-.597.895-1.31.895-2.145v-7.781c0-.835-.299-1.55-.895-2.147a2.929 2.929 0 0 0-2.147-.894h-8.227v-5.096H25.35v-4.384z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-10">
      <path d="M42.315 125.63c0-4.997-1.694-9.235-5.08-12.713-3.388-3.479-7.571-5.218-12.552-5.218h-1.315l4.363 4.363-2.51 2.51-8.787-8.786L25.221 97l2.45 2.45-4.662 4.663h1.375c2.988 0 5.788.557 8.397 1.673 2.61 1.116 4.892 2.65 6.844 4.602 1.953 1.953 3.487 4.234 4.602 6.844 1.116 2.61 1.674 5.41 1.674 8.398zM8.183 142v-19.657H3.176V117.8h9.643V142zm13.63 0c-1.156 0-2.127-.393-2.912-1.178-.778-.778-1.168-1.746-1.168-2.902v-16.04c0-1.156.393-2.127 1.178-2.912.779-.779 1.746-1.168 2.902-1.168h7.696c1.156 0 2.126.392 2.911 1.177.779.78 1.168 1.747 1.168 2.903v16.04c0 1.156-.392 2.127-1.177 2.912-.779.779-1.746 1.168-2.902 1.168zm.556-4.636h6.583v-15.02H22.37z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-replay-30">
      <path d="M26.047 97l-8.733 8.732 8.733 8.733 2.496-2.494-4.336-4.338h1.307c4.95 0 9.108 1.73 12.474 5.187 3.367 3.458 5.051 7.668 5.051 12.635h3.565c0-2.97-.556-5.751-1.665-8.346-1.109-2.594-2.633-4.862-4.574-6.802-1.94-1.941-4.208-3.466-6.803-4.575-2.594-1.109-5.375-1.664-8.345-1.664H23.85l4.634-4.634zM2.555 117.531v4.688h10.297v5.25H5.873v4.687h6.979v5.156H2.555V142H13.36c1.061 0 1.95-.395 2.668-1.186.718-.79 1.076-1.772 1.076-2.94v-16.218c0-1.168-.358-2.149-1.076-2.94-.717-.79-1.607-1.185-2.668-1.185zm22.482.14c-1.149 0-2.11.39-2.885 1.165-.78.78-1.172 1.744-1.172 2.893v15.943c0 1.149.388 2.11 1.163 2.885.78.78 1.745 1.172 2.894 1.172h7.649c1.148 0 2.11-.388 2.884-1.163.78-.78 1.17-1.745 1.17-2.894v-15.943c0-1.15-.386-2.111-1.16-2.885-.78-.78-1.746-1.172-2.894-1.172zm.553 4.518h6.545v14.93H25.59z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-5">
      <path d="M29.508 97l-2.431 2.43 4.625 4.625h-1.364c-2.965 0-5.742.554-8.332 1.66-2.589 1.107-4.851 2.629-6.788 4.566-1.937 1.937-3.458 4.2-4.565 6.788-1.107 2.59-1.66 5.367-1.66 8.331h3.557c0-4.957 1.68-9.16 5.04-12.611 3.36-3.45 7.51-5.177 12.451-5.177h1.304l-4.326 4.33 2.49 2.49 8.715-8.716zm-9.783 21.61v13.89h11.382v5.018H19.725V142h12.727a2.93 2.93 0 0 0 2.15-.896 2.93 2.93 0 0 0 .896-2.15v-7.798c0-.837-.299-1.554-.896-2.152a2.93 2.93 0 0 0-2.15-.896h-8.245V123h11.29v-4.392z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-10">
      <path d="M23.119 97l-2.386 2.383 4.538 4.538h-1.339c-2.908 0-5.633.543-8.173 1.63-2.54 1.085-4.76 2.577-6.66 4.478-1.9 1.9-3.392 4.12-4.478 6.66-1.085 2.54-1.629 5.264-1.629 8.172h3.49c0-4.863 1.648-8.986 4.944-12.372 3.297-3.385 7.368-5.078 12.216-5.078h1.279l-4.245 4.247 2.443 2.442 8.55-8.55zm-9.52 21.45v4.42h4.871V142h4.513v-23.55zm18.136 0c-1.125 0-2.066.377-2.824 1.135-.764.764-1.148 1.709-1.148 2.834v15.612c0 1.124.38 2.066 1.139 2.824.764.764 1.708 1.145 2.833 1.145h7.489c1.125 0 2.066-.378 2.824-1.136.764-.764 1.145-1.709 1.145-2.833v-15.612c0-1.125-.378-2.067-1.136-2.825-.764-.764-1.708-1.145-2.833-1.145zm.54 4.42h6.408v14.617h-6.407z"></path>
    </symbol>
    <symbol viewBox="0 96 48 48" id="vjs-icon-forward-30">
      <path d="M25.549 97l-2.437 2.434 4.634 4.635H26.38c-2.97 0-5.753.555-8.347 1.664-2.594 1.109-4.861 2.633-6.802 4.574-1.94 1.94-3.465 4.207-4.574 6.802-1.109 2.594-1.664 5.377-1.664 8.347h3.565c0-4.967 1.683-9.178 5.05-12.636 3.366-3.458 7.525-5.187 12.475-5.187h1.307l-4.335 4.338 2.495 2.494 8.732-8.732zm-11.553 20.53v4.689h10.297v5.249h-6.978v4.688h6.978v5.156H13.996V142h10.808c1.06 0 1.948-.395 2.666-1.186.718-.79 1.077-1.771 1.077-2.94v-16.217c0-1.169-.36-2.15-1.077-2.94-.718-.79-1.605-1.186-2.666-1.186zm21.174.168c-1.149 0-2.11.389-2.884 1.163-.78.78-1.172 1.745-1.172 2.894v15.942c0 1.15.388 2.11 1.162 2.885.78.78 1.745 1.17 2.894 1.17h7.649c1.149 0 2.11-.386 2.885-1.16.78-.78 1.17-1.746 1.17-2.895v-15.942c0-1.15-.387-2.11-1.161-2.885-.78-.78-1.745-1.172-2.894-1.172zm.552 4.516h6.542v14.931h-6.542z"></path>
    </symbol>
    <symbol viewBox="0 0 512 512" id="vjs-icon-audio-description">
      <g fill-rule="evenodd"><path d="M227.29 381.351V162.993c50.38-1.017 89.108-3.028 117.631 17.126 27.374 19.342 48.734 56.965 44.89 105.325-4.067 51.155-41.335 94.139-89.776 98.475-24.085 2.155-71.972 0-71.972 0s-.84-1.352-.773-2.568m48.755-54.804c31.43 1.26 53.208-16.633 56.495-45.386 4.403-38.51-21.188-63.552-58.041-60.796v103.612c-.036 1.466.575 2.22 1.546 2.57"></path><path d="M383.78 381.328c13.336 3.71 17.387-11.06 23.215-21.408 12.722-22.571 22.294-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.226 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M425.154 381.328c13.336 3.71 17.384-11.061 23.215-21.408 12.721-22.571 22.291-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.511c-.586 3.874 2.226 7.315 3.866 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894"></path><path d="M466.26 381.328c13.337 3.71 17.385-11.061 23.216-21.408 12.722-22.571 22.292-51.594 22.445-84.774.221-47.594-18.343-82.517-35.6-106.182h-8.51c-.587 3.874 2.225 7.315 3.865 10.276 13.166 23.762 25.367 56.553 25.54 94.194.2 43.176-14.162 79.278-30.955 107.894M4.477 383.005H72.58l18.573-28.484 64.169-.135s.065 19.413.065 28.62h48.756V160.307h-58.816c-5.653 9.537-140.85 222.697-140.85 222.697zm152.667-145.282v71.158l-40.453-.27 40.453-70.888z"></path></g>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-next-item">
      <path d="M12 36l17-12-17-12v24zm20-24v24h4V12h-4z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-previous-item">
      <path d="M12 12h4v24h-4zm7 12l17 12V12z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-shuffle">
      <path d="M21.17 18.34L10.83 8 8 10.83l10.34 10.34 2.83-2.83zM29 8l4.09 4.09L8 37.17 10.83 40l25.09-25.09L40 19V8H29zm.66 18.83l-2.83 2.83 6.26 6.26L29 40h11V29l-4.09 4.09-6.25-6.26z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-cast">
      <path d="M42 6H6c-2.21 0-4 1.79-4 4v6h4v-6h36v28H28v4h14c2.21 0 4-1.79 4-4V10c0-2.21-1.79-4-4-4zM2 36v6h6c0-3.31-2.69-6-6-6zm0-8v4c5.52 0 10 4.48 10 10h4c0-7.73-6.27-14-14-14zm0-8v4c9.94 0 18 8.06 18 18h4c0-12.15-9.85-22-22-22z"></path>
    </symbol>
    <symbol viewBox="0 0 48 48" id="vjs-icon-picture-in-picture-enter">
      <path d="M38 22H22v11.99h16V22zm8 16V9.96C46 7.76 44.2 6 42 6H6C3.8 6 2 7.76 2 9.96V38c0 2.2 1.8 4 4 4h36c2.2 0 4-1.8 4-4zm-4 .04H6V9.94h36v28.1z"></path>
    </symbol>
    <symbol viewBox="0 0 22 18" id="vjs-icon-picture-in-picture-exit">
      <path d="M18 4H4v10h14V4zm4 12V1.98C22 .88 21.1 0 20 0H2C.9 0 0 .88 0 1.98V16c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H2V1.97h18v14.05z"></path>
      <path fill="none" d="M-1-3h24v24H-1z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-facebook">
      <path d="M1343 12v264h-157q-86 0-116 36t-30 108v189h293l-39 296h-254v759H734V905H479V609h255V391q0-186 104-288.5T1115 0q147 0 228 12z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-linkedin">
      <path d="M477 625v991H147V625h330zm21-306q1 73-50.5 122T312 490h-2q-82 0-132-49t-50-122q0-74 51.5-122.5T314 148t133 48.5T498 319zm1166 729v568h-329v-530q0-105-40.5-164.5T1168 862q-63 0-105.5 34.5T999 982q-11 30-11 81v553H659q2-399 2-647t-1-296l-1-48h329v144h-2q20-32 41-56t56.5-52 87-43.5T1285 602q171 0 275 113.5t104 332.5z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-twitter">
      <path d="M1684 408q-67 98-162 167 1 14 1 42 0 130-38 259.5T1369.5 1125 1185 1335.5t-258 146-323 54.5q-271 0-496-145 35 4 78 4 225 0 401-138-105-2-188-64.5T285 1033q33 5 61 5 43 0 85-11-112-23-185.5-111.5T172 710v-4q68 38 146 41-66-44-105-115t-39-154q0-88 44-163 121 149 294.5 238.5T884 653q-8-38-8-74 0-134 94.5-228.5T1199 256q140 0 236 102 109-21 205-78-37 115-142 178 93-10 186-50z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-tumblr">
      <path d="M1328 1329l80 237q-23 35-111 66t-177 32q-104 2-190.5-26T787 1564t-95-106-55.5-120-16.5-118V676H452V461q72-26 129-69.5t91-90 58-102 34-99T779 12q1-5 4.5-8.5T791 0h244v424h333v252h-334v518q0 30 6.5 56t22.5 52.5 49.5 41.5 81.5 14q78-2 134-29z"></path>
    </symbol>
    <symbol viewBox="0 0 1792 1792" id="vjs-icon-pinterest">
      <path d="M1664 896q0 209-103 385.5T1281.5 1561 896 1664q-111 0-218-32 59-93 78-164 9-34 54-211 20 39 73 67.5t114 28.5q121 0 216-68.5t147-188.5 52-270q0-114-59.5-214T1180 449t-255-63q-105 0-196 29t-154.5 77-109 110.5-67 129.5T377 866q0 104 40 183t117 111q30 12 38-20 2-7 8-31t8-30q6-23-11-43-51-61-51-151 0-151 104.5-259.5T904 517q151 0 235.5 82t84.5 213q0 170-68.5 289T980 1220q-61 0-98-43.5T859 1072q8-35 26.5-93.5t30-103T927 800q0-50-27-83t-77-33q-62 0-105 57t-43 142q0 73 25 122l-99 418q-17 70-13 177-206-91-333-281T128 896q0-209 103-385.5T510.5 231 896 128t385.5 103T1561 510.5 1664 896z"></path>
    </symbol>
  </defs>
</svg>`
        , pT = class extends J {
            constructor(t, e, s) {
                const r = ze({
                    createEl: !1
                }, e);
                if (super(t, r, s),
                    !e.playerOptions.sources || e.playerOptions.sources.length === 0)
                    for (let n = 0, a = e.playerOptions.techOrder; n < a.length; n++) {
                        const o = tt(a[n]);
                        let u = He.getTech(o);
                        if (o || (u = J.getComponent(o)),
                            u && u.isSupported()) {
                            t.loadTech_(o);
                            break
                        }
                    }
                else
                    t.src(e.playerOptions.sources)
            }
        }
        ;
    J.registerComponent("MediaLoader", pT);
    var pl = class extends J {
        constructor(t, e) {
            super(t, e),
                this.options_.controlText && this.controlText(this.options_.controlText),
                this.handleMouseOver_ = s => this.handleMouseOver(s),
                this.handleMouseOut_ = s => this.handleMouseOut(s),
                this.handleClick_ = s => this.handleClick(s),
                this.handleKeyDown_ = s => this.handleKeyDown(s),
                this.emitTapEvents(),
                this.enable()
        }
        createEl(t = "div", e = {}, s = {}) {
            e = Object.assign({
                className: this.buildCSSClass(),
                tabIndex: 0
            }, e),
                t === "button" && Ie.error(`Creating a ClickableComponent with an HTML element of ${t} is not supported; use a Button instead.`),
                s = Object.assign({
                    role: "button"
                }, s),
                this.tabIndex_ = e.tabIndex;
            const r = De(t, e, s);
            return this.player_.options_.experimentalSvgIcons || r.appendChild(De("span", {
                className: "vjs-icon-placeholder"
            }, {
                "aria-hidden": !0
            })),
                this.createControlTextEl(r),
                r
        }
        dispose() {
            this.controlTextEl_ = null,
                super.dispose()
        }
        createControlTextEl(t) {
            return this.controlTextEl_ = De("span", {
                className: "vjs-control-text"
            }, {
                "aria-live": "polite"
            }),
                t && t.appendChild(this.controlTextEl_),
                this.controlText(this.controlText_, t),
                this.controlTextEl_
        }
        controlText(t, e = this.el()) {
            if (t === void 0)
                return this.controlText_ || "Need Text";
            const s = this.localize(t);
            this.controlText_ = t,
                zs(this.controlTextEl_, s),
                !this.nonIconControl && !this.player_.options_.noUITitleAttributes && e.setAttribute("title", s)
        }
        buildCSSClass() {
            return `vjs-control vjs-button ${super.buildCSSClass()}`
        }
        enable() {
            this.enabled_ || (this.enabled_ = !0,
                this.removeClass("vjs-disabled"),
                this.el_.setAttribute("aria-disabled", "false"),
                typeof this.tabIndex_ < "u" && this.el_.setAttribute("tabIndex", this.tabIndex_),
                this.on(["tap", "click"], this.handleClick_),
                this.on("keydown", this.handleKeyDown_))
        }
        disable() {
            this.enabled_ = !1,
                this.addClass("vjs-disabled"),
                this.el_.setAttribute("aria-disabled", "true"),
                typeof this.tabIndex_ < "u" && this.el_.removeAttribute("tabIndex"),
                this.off("mouseover", this.handleMouseOver_),
                this.off("mouseout", this.handleMouseOut_),
                this.off(["tap", "click"], this.handleClick_),
                this.off("keydown", this.handleKeyDown_)
        }
        handleLanguagechange() {
            this.controlText(this.controlText_)
        }
        handleClick(t) {
            this.options_.clickHandler && this.options_.clickHandler.call(this, arguments)
        }
        handleKeyDown(t) {
            we.default.isEventKey(t, "Space") || we.default.isEventKey(t, "Enter") ? (t.preventDefault(),
                t.stopPropagation(),
                this.trigger("click")) : super.handleKeyDown(t)
        }
    }
        ;
    J.registerComponent("ClickableComponent", pl);
    var Gh = class extends pl {
        constructor(t, e) {
            super(t, e),
                this.update(),
                this.update_ = s => this.update(s),
                t.on("posterchange", this.update_)
        }
        dispose() {
            this.player().off("posterchange", this.update_),
                super.dispose()
        }
        createEl() {
            return De("div", {
                className: "vjs-poster"
            })
        }
        crossOrigin(t) {
            if (typeof t > "u")
                return this.$("img") ? this.$("img").crossOrigin : this.player_.tech_ && this.player_.tech_.isReady_ ? this.player_.crossOrigin() : this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;
            if (t !== null && t !== "anonymous" && t !== "use-credentials") {
                this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${t}"`);
                return
            }
            this.$("img") && (this.$("img").crossOrigin = t)
        }
        update(t) {
            const e = this.player().poster();
            this.setSrc(e),
                e ? this.show() : this.hide()
        }
        setSrc(t) {
            if (!t) {
                this.el_.textContent = "";
                return
            }
            this.$("img") || this.el_.appendChild(De("picture", {
                className: "vjs-poster",
                tabIndex: -1
            }, {}, De("img", {
                loading: "lazy",
                crossOrigin: this.crossOrigin()
            }, {
                alt: ""
            }))),
                this.$("img").src = t
        }
        handleClick(t) {
            this.player_.controls() && (this.player_.tech(!0) && this.player_.tech(!0).focus(),
                this.player_.paused() ? ts(this.player_.play()) : this.player_.pause())
        }
    }
        ;
    Gh.prototype.crossorigin = Gh.prototype.crossOrigin,
        J.registerComponent("PosterImage", Gh);
    var Si = "#222"
        , sp = "#ccc"
        , mT = {
            monospace: "monospace",
            sansSerif: "sans-serif",
            serif: "serif",
            monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
            monospaceSerif: '"Courier New", monospace',
            proportionalSansSerif: "sans-serif",
            proportionalSerif: "serif",
            casual: '"Comic Sans MS", Impact, fantasy',
            script: '"Monotype Corsiva", cursive',
            smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
        };
    function Wh(t, e) {
        let s;
        if (t.length === 4)
            s = t[1] + t[1] + t[2] + t[2] + t[3] + t[3];
        else if (t.length === 7)
            s = t.slice(1);
        else
            throw new Error("Invalid color code provided, " + t + "; must be formatted as e.g. #f0e or #f604e2.");
        return "rgba(" + parseInt(s.slice(0, 2), 16) + "," + parseInt(s.slice(2, 4), 16) + "," + parseInt(s.slice(4, 6), 16) + "," + e + ")"
    }
    function ka(t, e, s) {
        try {
            t.style[e] = s
        } catch (r) {
            return
        }
    }
    function rp(t) {
        return t ? `${t}px` : ""
    }
    var gT = class extends J {
        constructor(t, e, s) {
            super(t, e, s);
            const r = a => this.updateDisplay(a)
                , n = a => {
                    this.updateDisplayOverlay(),
                        this.updateDisplay(a)
                }
                ;
            t.on("loadstart", a => this.toggleDisplay(a)),
                t.on("texttrackchange", r),
                t.on("loadedmetadata", a => {
                    this.updateDisplayOverlay(),
                        this.preselectTrack(a)
                }
                ),
                t.ready(Ge(this, function () {
                    if (t.tech_ && t.tech_.featuresNativeTextTracks) {
                        this.hide();
                        return
                    }
                    t.on("fullscreenchange", n),
                        t.on("playerresize", n);
                    const a = O.default.screen.orientation || O.default
                        , o = O.default.screen.orientation ? "change" : "orientationchange";
                    a.addEventListener(o, n),
                        t.on("dispose", () => a.removeEventListener(o, n));
                    const u = this.options_.playerOptions.tracks || [];
                    for (let c = 0; c < u.length; c++)
                        this.player_.addRemoteTextTrack(u[c], !0);
                    this.preselectTrack()
                }))
        }
        preselectTrack() {
            const t = {
                captions: 1,
                subtitles: 1
            }
                , e = this.player_.textTracks()
                , s = this.player_.cache_.selectedLanguage;
            let r, n, a;
            for (let o = 0; o < e.length; o++) {
                const u = e[o];
                s && s.enabled && s.language && s.language === u.language && u.kind in t ? u.kind === s.kind ? a = u : a || (a = u) : s && !s.enabled ? (a = null,
                    r = null,
                    n = null) : u.default && (u.kind === "descriptions" && !r ? r = u : u.kind in t && !n && (n = u))
            }
            a ? a.mode = "showing" : n ? n.mode = "showing" : r && (r.mode = "showing")
        }
        toggleDisplay() {
            this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks ? this.hide() : this.show()
        }
        createEl() {
            return super.createEl("div", {
                className: "vjs-text-track-display"
            }, {
                translate: "yes",
                "aria-live": "off",
                "aria-atomic": "true"
            })
        }
        clearDisplay() {
            typeof O.default.WebVTT == "function" && O.default.WebVTT.processCues(O.default, [], this.el_)
        }
        updateDisplay() {
            const t = this.player_.textTracks()
                , e = this.options_.allowMultipleShowingTracks;
            if (this.clearDisplay(),
                e) {
                const a = [];
                for (let o = 0; o < t.length; ++o) {
                    const u = t[o];
                    u.mode === "showing" && a.push(u)
                }
                this.updateForTrack(a);
                return
            }
            let s = null
                , r = null
                , n = t.length;
            for (; n--;) {
                const a = t[n];
                a.mode === "showing" && (a.kind === "descriptions" ? s = a : r = a)
            }
            r ? (this.getAttribute("aria-live") !== "off" && this.setAttribute("aria-live", "off"),
                this.updateForTrack(r)) : s && (this.getAttribute("aria-live") !== "assertive" && this.setAttribute("aria-live", "assertive"),
                    this.updateForTrack(s))
        }
        updateDisplayOverlay() {
            if (!this.player_.videoHeight() || !O.default.CSS.supports("inset-inline: 10px"))
                return;
            const t = this.player_.currentWidth()
                , e = this.player_.currentHeight()
                , s = t / e
                , r = this.player_.videoWidth() / this.player_.videoHeight();
            let n = 0
                , a = 0;
            Math.abs(s - r) > .1 && (s > r ? n = Math.round((t - e * r) / 2) : a = Math.round((e - t / r) / 2)),
                ka(this.el_, "insetInline", rp(n)),
                ka(this.el_, "insetBlock", rp(a))
        }
        updateDisplayState(t) {
            const e = this.player_.textTrackSettings.getValues()
                , s = t.activeCues;
            let r = s.length;
            for (; r--;) {
                const n = s[r];
                if (!n)
                    continue;
                const a = n.displayState;
                if (e.color && (a.firstChild.style.color = e.color),
                    e.textOpacity && ka(a.firstChild, "color", Wh(e.color || "#fff", e.textOpacity)),
                    e.backgroundColor && (a.firstChild.style.backgroundColor = e.backgroundColor),
                    e.backgroundOpacity && ka(a.firstChild, "backgroundColor", Wh(e.backgroundColor || "#000", e.backgroundOpacity)),
                    e.windowColor && (e.windowOpacity ? ka(a, "backgroundColor", Wh(e.windowColor, e.windowOpacity)) : a.style.backgroundColor = e.windowColor),
                    e.edgeStyle && (e.edgeStyle === "dropshadow" ? a.firstChild.style.textShadow = `2px 2px 3px ${Si}, 2px 2px 4px ${Si}, 2px 2px 5px ${Si}` : e.edgeStyle === "raised" ? a.firstChild.style.textShadow = `1px 1px ${Si}, 2px 2px ${Si}, 3px 3px ${Si}` : e.edgeStyle === "depressed" ? a.firstChild.style.textShadow = `1px 1px ${sp}, 0 1px ${sp}, -1px -1px ${Si}, 0 -1px ${Si}` : e.edgeStyle === "uniform" && (a.firstChild.style.textShadow = `0 0 4px ${Si}, 0 0 4px ${Si}, 0 0 4px ${Si}, 0 0 4px ${Si}`)),
                    e.fontPercent && e.fontPercent !== 1) {
                    const o = O.default.parseFloat(a.style.fontSize);
                    a.style.fontSize = o * e.fontPercent + "px",
                        a.style.height = "auto",
                        a.style.top = "auto"
                }
                e.fontFamily && e.fontFamily !== "default" && (e.fontFamily === "small-caps" ? a.firstChild.style.fontVariant = "small-caps" : a.firstChild.style.fontFamily = mT[e.fontFamily])
            }
        }
        updateForTrack(t) {
            if (Array.isArray(t) || (t = [t]),
                typeof O.default.WebVTT != "function" || t.every(s => !s.activeCues))
                return;
            const e = [];
            for (let s = 0; s < t.length; ++s) {
                const r = t[s];
                for (let n = 0; n < r.activeCues.length; ++n)
                    e.push(r.activeCues[n])
            }
            O.default.WebVTT.processCues(O.default, e, this.el_);
            for (let s = 0; s < t.length; ++s) {
                const r = t[s];
                for (let n = 0; n < r.activeCues.length; ++n) {
                    const a = r.activeCues[n].displayState;
                    vr(a, "vjs-text-track-cue", "vjs-text-track-cue-" + (r.language ? r.language : s)),
                        r.language && hn(a, "lang", r.language)
                }
                this.player_.textTrackSettings && this.updateDisplayState(r)
            }
        }
    }
        ;
    J.registerComponent("TextTrackDisplay", gT);
    var vT = class extends J {
        createEl() {
            const t = this.player_.isAudio()
                , e = this.localize(t ? "Audio Player" : "Video Player")
                , s = De("span", {
                    className: "vjs-control-text",
                    textContent: this.localize("{1} is loading.", [e])
                })
                , r = super.createEl("div", {
                    className: "vjs-loading-spinner",
                    dir: "ltr"
                });
            return r.appendChild(s),
                r
        }
        handleLanguagechange() {
            this.$(".vjs-control-text").textContent = this.localize("{1} is loading.", [this.player_.isAudio() ? "Audio Player" : "Video Player"])
        }
    }
        ;
    J.registerComponent("LoadingSpinner", vT);
    var hi = class extends pl {
        createEl(t, e = {}, s = {}) {
            t = "button",
                e = Object.assign({
                    className: this.buildCSSClass()
                }, e),
                s = Object.assign({
                    type: "button"
                }, s);
            const r = De(t, e, s);
            return this.player_.options_.experimentalSvgIcons || r.appendChild(De("span", {
                className: "vjs-icon-placeholder"
            }, {
                "aria-hidden": !0
            })),
                this.createControlTextEl(r),
                r
        }
        addChild(t, e = {}) {
            const s = this.constructor.name;
            return Ie.warn(`Adding an actionable (user controllable) child to a Button (${s}) is not supported; use a ClickableComponent instead.`),
                J.prototype.addChild.call(this, t, e)
        }
        enable() {
            super.enable(),
                this.el_.removeAttribute("disabled")
        }
        disable() {
            super.disable(),
                this.el_.setAttribute("disabled", "disabled")
        }
        handleKeyDown(t) {
            if (we.default.isEventKey(t, "Space") || we.default.isEventKey(t, "Enter")) {
                t.stopPropagation();
                return
            }
            super.handleKeyDown(t)
        }
    }
        ;
    J.registerComponent("Button", hi);
    var np = class extends hi {
        constructor(t, e) {
            super(t, e),
                this.mouseused_ = !1,
                this.setIcon("play"),
                this.on("mousedown", s => this.handleMouseDown(s))
        }
        buildCSSClass() {
            return "vjs-big-play-button"
        }
        handleClick(t) {
            const e = this.player_.play();
            if (this.mouseused_ && "clientX" in t && "clientY" in t) {
                ts(e),
                    this.player_.tech(!0) && this.player_.tech(!0).focus();
                return
            }
            const s = this.player_.getChild("controlBar")
                , r = s && s.getChild("playToggle");
            if (!r) {
                this.player_.tech(!0).focus();
                return
            }
            const n = () => r.focus();
            wa(e) ? e.then(n, () => { }
            ) : this.setTimeout(n, 1)
        }
        handleKeyDown(t) {
            this.mouseused_ = !1,
                super.handleKeyDown(t)
        }
        handleMouseDown(t) {
            this.mouseused_ = !0
        }
    }
        ;
    np.prototype.controlText_ = "Play Video",
        J.registerComponent("BigPlayButton", np);
    var yT = class extends hi {
        constructor(t, e) {
            super(t, e),
                this.setIcon("cancel"),
                this.controlText(e && e.controlText || this.localize("Close"))
        }
        buildCSSClass() {
            return `vjs-close-button ${super.buildCSSClass()}`
        }
        handleClick(t) {
            this.trigger({
                type: "close",
                bubbles: !1
            })
        }
        handleKeyDown(t) {
            we.default.isEventKey(t, "Esc") ? (t.preventDefault(),
                t.stopPropagation(),
                this.trigger("click")) : super.handleKeyDown(t)
        }
    }
        ;
    J.registerComponent("CloseButton", yT);
    var ap = class extends hi {
        constructor(t, e = {}) {
            super(t, e),
                e.replay = e.replay === void 0 || e.replay,
                this.setIcon("play"),
                this.on(t, "play", s => this.handlePlay(s)),
                this.on(t, "pause", s => this.handlePause(s)),
                e.replay && this.on(t, "ended", s => this.handleEnded(s))
        }
        buildCSSClass() {
            return `vjs-play-control ${super.buildCSSClass()}`
        }
        handleClick(t) {
            this.player_.paused() ? ts(this.player_.play()) : this.player_.pause()
        }
        handleSeeked(t) {
            this.removeClass("vjs-ended"),
                this.player_.paused() ? this.handlePause(t) : this.handlePlay(t)
        }
        handlePlay(t) {
            this.removeClass("vjs-ended", "vjs-paused"),
                this.addClass("vjs-playing"),
                this.setIcon("pause"),
                this.controlText("Pause")
        }
        handlePause(t) {
            this.removeClass("vjs-playing"),
                this.addClass("vjs-paused"),
                this.setIcon("play"),
                this.controlText("Play")
        }
        handleEnded(t) {
            this.removeClass("vjs-playing"),
                this.addClass("vjs-ended"),
                this.setIcon("replay"),
                this.controlText("Replay"),
                this.one(this.player_, "seeked", e => this.handleSeeked(e))
        }
    }
        ;
    ap.prototype.controlText_ = "Play",
        J.registerComponent("PlayToggle", ap);
    var yn = class extends J {
        constructor(t, e) {
            super(t, e),
                this.on(t, ["timeupdate", "ended"], s => this.updateContent(s)),
                this.updateTextNode_()
        }
        createEl() {
            const t = this.buildCSSClass()
                , e = super.createEl("div", {
                    className: `${t} vjs-time-control vjs-control`
                })
                , s = De("span", {
                    className: "vjs-control-text",
                    textContent: `${this.localize(this.labelText_)}\xA0`
                }, {
                    role: "presentation"
                });
            return e.appendChild(s),
                this.contentEl_ = De("span", {
                    className: `${t}-display`
                }, {
                    role: "presentation"
                }),
                e.appendChild(this.contentEl_),
                e
        }
        dispose() {
            this.contentEl_ = null,
                this.textNode_ = null,
                super.dispose()
        }
        updateTextNode_(t = 0) {
            t = _r(t),
                this.formattedTime_ !== t && (this.formattedTime_ = t,
                    this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", () => {
                        if (!this.contentEl_)
                            return;
                        let e = this.textNode_;
                        e && this.contentEl_.firstChild !== e && (e = null,
                            Ie.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.")),
                            this.textNode_ = le.default.createTextNode(this.formattedTime_),
                            this.textNode_ && (e ? this.contentEl_.replaceChild(this.textNode_, e) : this.contentEl_.appendChild(this.textNode_))
                    }
                    ))
        }
        updateContent(t) { }
    }
        ;
    yn.prototype.labelText_ = "Time",
        yn.prototype.controlText_ = "Time",
        J.registerComponent("TimeDisplay", yn);
    var Kh = class extends yn {
        buildCSSClass() {
            return "vjs-current-time"
        }
        updateContent(t) {
            let e;
            this.player_.ended() ? e = this.player_.duration() : e = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime(),
                this.updateTextNode_(e)
        }
    }
        ;
    Kh.prototype.labelText_ = "Current Time",
        Kh.prototype.controlText_ = "Current Time",
        J.registerComponent("CurrentTimeDisplay", Kh);
    var Xh = class extends yn {
        constructor(t, e) {
            super(t, e);
            const s = r => this.updateContent(r);
            this.on(t, "durationchange", s),
                this.on(t, "loadstart", s),
                this.on(t, "loadedmetadata", s)
        }
        buildCSSClass() {
            return "vjs-duration"
        }
        updateContent(t) {
            const e = this.player_.duration();
            this.updateTextNode_(e)
        }
    }
        ;
    Xh.prototype.labelText_ = "Duration",
        Xh.prototype.controlText_ = "Duration",
        J.registerComponent("DurationDisplay", Xh);
    var _T = class extends J {
        createEl() {
            const t = super.createEl("div", {
                className: "vjs-time-control vjs-time-divider"
            }, {
                "aria-hidden": !0
            })
                , e = super.createEl("div")
                , s = super.createEl("span", {
                    textContent: "/"
                });
            return e.appendChild(s),
                t.appendChild(e),
                t
        }
    }
        ;
    J.registerComponent("TimeDivider", _T);
    var Yh = class extends yn {
        constructor(t, e) {
            super(t, e),
                this.on(t, "durationchange", s => this.updateContent(s))
        }
        buildCSSClass() {
            return "vjs-remaining-time"
        }
        createEl() {
            const t = super.createEl();
            return this.options_.displayNegative !== !1 && t.insertBefore(De("span", {}, {
                "aria-hidden": !0
            }, "-"), this.contentEl_),
                t
        }
        updateContent(t) {
            if (typeof this.player_.duration() != "number")
                return;
            let e;
            this.player_.ended() ? e = 0 : this.player_.remainingTimeDisplay ? e = this.player_.remainingTimeDisplay() : e = this.player_.remainingTime(),
                this.updateTextNode_(e)
        }
    }
        ;
    Yh.prototype.labelText_ = "Remaining Time",
        Yh.prototype.controlText_ = "Remaining Time",
        J.registerComponent("RemainingTimeDisplay", Yh);
    var TT = class extends J {
        constructor(t, e) {
            super(t, e),
                this.updateShowing(),
                this.on(this.player(), "durationchange", s => this.updateShowing(s))
        }
        createEl() {
            const t = super.createEl("div", {
                className: "vjs-live-control vjs-control"
            });
            return this.contentEl_ = De("div", {
                className: "vjs-live-display"
            }, {
                "aria-live": "off"
            }),
                this.contentEl_.appendChild(De("span", {
                    className: "vjs-control-text",
                    textContent: `${this.localize("Stream Type")}\xA0`
                })),
                this.contentEl_.appendChild(le.default.createTextNode(this.localize("LIVE"))),
                t.appendChild(this.contentEl_),
                t
        }
        dispose() {
            this.contentEl_ = null,
                super.dispose()
        }
        updateShowing(t) {
            this.player().duration() === 1 / 0 ? this.show() : this.hide()
        }
    }
        ;
    J.registerComponent("LiveDisplay", TT);
    var op = class extends hi {
        constructor(t, e) {
            super(t, e),
                this.updateLiveEdgeStatus(),
                this.player_.liveTracker && (this.updateLiveEdgeStatusHandler_ = s => this.updateLiveEdgeStatus(s),
                    this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_))
        }
        createEl() {
            const t = super.createEl("button", {
                className: "vjs-seek-to-live-control vjs-control"
            });
            return this.setIcon("circle", t),
                this.textEl_ = De("span", {
                    className: "vjs-seek-to-live-text",
                    textContent: this.localize("LIVE")
                }, {
                    "aria-hidden": "true"
                }),
                t.appendChild(this.textEl_),
                t
        }
        updateLiveEdgeStatus() {
            !this.player_.liveTracker || this.player_.liveTracker.atLiveEdge() ? (this.setAttribute("aria-disabled", !0),
                this.addClass("vjs-at-live-edge"),
                this.controlText("Seek to live, currently playing live")) : (this.setAttribute("aria-disabled", !1),
                    this.removeClass("vjs-at-live-edge"),
                    this.controlText("Seek to live, currently behind live"))
        }
        handleClick() {
            this.player_.liveTracker.seekToLiveEdge()
        }
        dispose() {
            this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_),
                this.textEl_ = null,
                super.dispose()
        }
    }
        ;
    op.prototype.controlText_ = "Seek to live, currently playing live",
        J.registerComponent("SeekToLive", op);
    function xa(t, e, s) {
        return t = Number(t),
            Math.min(s, Math.max(e, isNaN(t) ? e : t))
    }
    var bT = Object.freeze({
        __proto__: null,
        clamp: xa
    })
        , Qh = class extends J {
            constructor(t, e) {
                super(t, e),
                    this.handleMouseDown_ = s => this.handleMouseDown(s),
                    this.handleMouseUp_ = s => this.handleMouseUp(s),
                    this.handleKeyDown_ = s => this.handleKeyDown(s),
                    this.handleClick_ = s => this.handleClick(s),
                    this.handleMouseMove_ = s => this.handleMouseMove(s),
                    this.update_ = s => this.update(s),
                    this.bar = this.getChild(this.options_.barName),
                    this.vertical(!!this.options_.vertical),
                    this.enable()
            }
            enabled() {
                return this.enabled_
            }
            enable() {
                this.enabled() || (this.on("mousedown", this.handleMouseDown_),
                    this.on("touchstart", this.handleMouseDown_),
                    this.on("keydown", this.handleKeyDown_),
                    this.on("click", this.handleClick_),
                    this.on(this.player_, "controlsvisible", this.update),
                    this.playerEvent && this.on(this.player_, this.playerEvent, this.update),
                    this.removeClass("disabled"),
                    this.setAttribute("tabindex", 0),
                    this.enabled_ = !0)
            }
            disable() {
                if (!this.enabled())
                    return;
                const t = this.bar.el_.ownerDocument;
                this.off("mousedown", this.handleMouseDown_),
                    this.off("touchstart", this.handleMouseDown_),
                    this.off("keydown", this.handleKeyDown_),
                    this.off("click", this.handleClick_),
                    this.off(this.player_, "controlsvisible", this.update_),
                    this.off(t, "mousemove", this.handleMouseMove_),
                    this.off(t, "mouseup", this.handleMouseUp_),
                    this.off(t, "touchmove", this.handleMouseMove_),
                    this.off(t, "touchend", this.handleMouseUp_),
                    this.removeAttribute("tabindex"),
                    this.addClass("disabled"),
                    this.playerEvent && this.off(this.player_, this.playerEvent, this.update),
                    this.enabled_ = !1
            }
            createEl(t, e = {}, s = {}) {
                return e.className = e.className + " vjs-slider",
                    e = Object.assign({
                        tabIndex: 0
                    }, e),
                    s = Object.assign({
                        role: "slider",
                        "aria-valuenow": 0,
                        "aria-valuemin": 0,
                        "aria-valuemax": 100
                    }, s),
                    super.createEl(t, e, s)
            }
            handleMouseDown(t) {
                const e = this.bar.el_.ownerDocument;
                t.type === "mousedown" && t.preventDefault(),
                    t.type === "touchstart" && !Ji && t.preventDefault(),
                    Ef(),
                    this.addClass("vjs-sliding"),
                    this.trigger("slideractive"),
                    this.on(e, "mousemove", this.handleMouseMove_),
                    this.on(e, "mouseup", this.handleMouseUp_),
                    this.on(e, "touchmove", this.handleMouseMove_),
                    this.on(e, "touchend", this.handleMouseUp_),
                    this.handleMouseMove(t, !0)
            }
            handleMouseMove(t) { }
            handleMouseUp(t) {
                const e = this.bar.el_.ownerDocument;
                Sf(),
                    this.removeClass("vjs-sliding"),
                    this.trigger("sliderinactive"),
                    this.off(e, "mousemove", this.handleMouseMove_),
                    this.off(e, "mouseup", this.handleMouseUp_),
                    this.off(e, "touchmove", this.handleMouseMove_),
                    this.off(e, "touchend", this.handleMouseUp_),
                    this.update()
            }
            update() {
                if (!this.el_ || !this.bar)
                    return;
                const t = this.getProgress();
                return t === this.progress_ || (this.progress_ = t,
                    this.requestNamedAnimationFrame("Slider#update", () => {
                        const e = this.vertical() ? "height" : "width";
                        this.bar.el().style[e] = (t * 100).toFixed(2) + "%"
                    }
                    )),
                    t
            }
            getProgress() {
                return Number(xa(this.getPercent(), 0, 1).toFixed(4))
            }
            calculateDistance(t) {
                const e = rl(this.el_, t);
                return this.vertical() ? e.y : e.x
            }
            handleKeyDown(t) {
                we.default.isEventKey(t, "Left") || we.default.isEventKey(t, "Down") ? (t.preventDefault(),
                    t.stopPropagation(),
                    this.stepBack()) : we.default.isEventKey(t, "Right") || we.default.isEventKey(t, "Up") ? (t.preventDefault(),
                        t.stopPropagation(),
                        this.stepForward()) : super.handleKeyDown(t)
            }
            handleClick(t) {
                t.stopPropagation(),
                    t.preventDefault()
            }
            vertical(t) {
                if (t === void 0)
                    return this.vertical_ || !1;
                this.vertical_ = !!t,
                    this.vertical_ ? this.addClass("vjs-slider-vertical") : this.addClass("vjs-slider-horizontal")
            }
        }
        ;
    J.registerComponent("Slider", Qh);
    var Jh = (t, e) => xa(t / e * 100, 0, 100).toFixed(2) + "%"
        , ET = class extends J {
            constructor(t, e) {
                super(t, e),
                    this.partEls_ = [],
                    this.on(t, "progress", s => this.update(s))
            }
            createEl() {
                const t = super.createEl("div", {
                    className: "vjs-load-progress"
                })
                    , e = De("span", {
                        className: "vjs-control-text"
                    })
                    , s = De("span", {
                        textContent: this.localize("Loaded")
                    })
                    , r = le.default.createTextNode(": ");
                return this.percentageEl_ = De("span", {
                    className: "vjs-control-text-loaded-percentage",
                    textContent: "0%"
                }),
                    t.appendChild(e),
                    e.appendChild(s),
                    e.appendChild(r),
                    e.appendChild(this.percentageEl_),
                    t
            }
            dispose() {
                this.partEls_ = null,
                    this.percentageEl_ = null,
                    super.dispose()
            }
            update(t) {
                this.requestNamedAnimationFrame("LoadProgressBar#update", () => {
                    const e = this.player_.liveTracker
                        , s = this.player_.buffered()
                        , r = e && e.isLive() ? e.seekableEnd() : this.player_.duration()
                        , n = this.player_.bufferedEnd()
                        , a = this.partEls_
                        , o = Jh(n, r);
                    this.percent_ !== o && (this.el_.style.width = o,
                        zs(this.percentageEl_, o),
                        this.percent_ = o);
                    for (let u = 0; u < s.length; u++) {
                        const c = s.start(u)
                            , f = s.end(u);
                        let v = a[u];
                        v || (v = this.el_.appendChild(De()),
                            a[u] = v),
                            !(v.dataset.start === c && v.dataset.end === f) && (v.dataset.start = c,
                                v.dataset.end = f,
                                v.style.left = Jh(c, n),
                                v.style.width = Jh(f - c, n))
                    }
                    for (let u = a.length; u > s.length; u--)
                        this.el_.removeChild(a[u - 1]);
                    a.length = s.length
                }
                )
            }
        }
        ;
    J.registerComponent("LoadProgressBar", ET);
    var ST = class extends J {
        constructor(t, e) {
            super(t, e),
                this.update = es(Ge(this, this.update), Ti)
        }
        createEl() {
            return super.createEl("div", {
                className: "vjs-time-tooltip"
            }, {
                "aria-hidden": "true"
            })
        }
        update(t, e, s) {
            const r = Ea(this.el_)
                , n = dn(this.player_.el())
                , a = t.width * e;
            if (!n || !r)
                return;
            const o = t.left - n.left + a
                , u = t.width - a + (n.right - t.right);
            let c = r.width / 2;
            o < c ? c += c - o : u < c && (c = u),
                c < 0 ? c = 0 : c > r.width && (c = r.width),
                c = Math.round(c),
                this.el_.style.right = `-${c}px`,
                this.write(s)
        }
        write(t) {
            zs(this.el_, t)
        }
        updateTime(t, e, s, r) {
            this.requestNamedAnimationFrame("TimeTooltip#updateTime", () => {
                let n;
                const a = this.player_.duration();
                if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
                    const o = this.player_.liveTracker.liveWindow()
                        , u = o - e * o;
                    n = (u < 1 ? "" : "-") + _r(u, o)
                } else
                    n = _r(s, a);
                this.update(t, e, n),
                    r && r()
            }
            )
        }
    }
        ;
    J.registerComponent("TimeTooltip", ST);
    var Zh = class extends J {
        constructor(t, e) {
            super(t, e),
                this.setIcon("circle"),
                this.update = es(Ge(this, this.update), Ti)
        }
        createEl() {
            return super.createEl("div", {
                className: "vjs-play-progress vjs-slider-bar"
            }, {
                "aria-hidden": "true"
            })
        }
        update(t, e) {
            const s = this.getChild("timeTooltip");
            if (!s)
                return;
            const r = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
            s.updateTime(t, e, r)
        }
    }
        ;
    Zh.prototype.options_ = {
        children: []
    },
        !jt && !Qi && Zh.prototype.options_.children.push("timeTooltip"),
        J.registerComponent("PlayProgressBar", Zh);
    var lp = class extends J {
        constructor(t, e) {
            super(t, e),
                this.update = es(Ge(this, this.update), Ti)
        }
        createEl() {
            return super.createEl("div", {
                className: "vjs-mouse-display"
            })
        }
        update(t, e) {
            const s = e * this.player_.duration();
            this.getChild("timeTooltip").updateTime(t, e, s, () => {
                this.el_.style.left = `${t.width * e}px`
            }
            )
        }
    }
        ;
    lp.prototype.options_ = {
        children: ["timeTooltip"]
    },
        J.registerComponent("MouseTimeDisplay", lp);
    var ml = 5
        , up = 12
        , ed = class extends Qh {
            constructor(t, e) {
                super(t, e),
                    this.setEventHandlers_()
            }
            setEventHandlers_() {
                this.update_ = Ge(this, this.update),
                    this.update = es(this.update_, Ti),
                    this.on(this.player_, ["ended", "durationchange", "timeupdate"], this.update),
                    this.player_.liveTracker && this.on(this.player_.liveTracker, "liveedgechange", this.update),
                    this.updateInterval = null,
                    this.enableIntervalHandler_ = t => this.enableInterval_(t),
                    this.disableIntervalHandler_ = t => this.disableInterval_(t),
                    this.on(this.player_, ["playing"], this.enableIntervalHandler_),
                    this.on(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_),
                    "hidden" in le.default && "visibilityState" in le.default && this.on(le.default, "visibilitychange", this.toggleVisibility_)
            }
            toggleVisibility_(t) {
                le.default.visibilityState === "hidden" ? (this.cancelNamedAnimationFrame("SeekBar#update"),
                    this.cancelNamedAnimationFrame("Slider#update"),
                    this.disableInterval_(t)) : (!this.player_.ended() && !this.player_.paused() && this.enableInterval_(),
                        this.update())
            }
            enableInterval_() {
                this.updateInterval || (this.updateInterval = this.setInterval(this.update, Ti))
            }
            disableInterval_(t) {
                this.player_.liveTracker && this.player_.liveTracker.isLive() && t && t.type !== "ended" || this.updateInterval && (this.clearInterval(this.updateInterval),
                    this.updateInterval = null)
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-progress-holder"
                }, {
                    "aria-label": this.localize("Progress Bar")
                })
            }
            update(t) {
                if (le.default.visibilityState === "hidden")
                    return;
                const e = super.update();
                return this.requestNamedAnimationFrame("SeekBar#update", () => {
                    const s = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_()
                        , r = this.player_.liveTracker;
                    let n = this.player_.duration();
                    r && r.isLive() && (n = this.player_.liveTracker.liveCurrentTime()),
                        this.percent_ !== e && (this.el_.setAttribute("aria-valuenow", (e * 100).toFixed(2)),
                            this.percent_ = e),
                        (this.currentTime_ !== s || this.duration_ !== n) && (this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [_r(s, n), _r(n, n)], "{1} of {2}")),
                            this.currentTime_ = s,
                            this.duration_ = n),
                        this.bar && this.bar.update(dn(this.el()), this.getProgress())
                }
                ),
                    e
            }
            userSeek_(t) {
                this.player_.liveTracker && this.player_.liveTracker.isLive() && this.player_.liveTracker.nextSeekedFromUser(),
                    this.player_.currentTime(t)
            }
            getCurrentTime_() {
                return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime()
            }
            getPercent() {
                const t = this.getCurrentTime_();
                let e;
                const s = this.player_.liveTracker;
                return s && s.isLive() ? (e = (t - s.seekableStart()) / s.liveWindow(),
                    s.atLiveEdge() && (e = 1)) : e = t / this.player_.duration(),
                    e
            }
            handleMouseDown(t) {
                Sa(t) && (t.stopPropagation(),
                    this.videoWasPlaying = !this.player_.paused(),
                    this.player_.pause(),
                    super.handleMouseDown(t))
            }
            handleMouseMove(t, e = !1) {
                if (!Sa(t) || isNaN(this.player_.duration()))
                    return;
                !e && !this.player_.scrubbing() && this.player_.scrubbing(!0);
                let s;
                const r = this.calculateDistance(t)
                    , n = this.player_.liveTracker;
                if (!n || !n.isLive())
                    s = r * this.player_.duration(),
                        s === this.player_.duration() && (s = s - .1);
                else {
                    if (r >= .99) {
                        n.seekToLiveEdge();
                        return
                    }
                    const a = n.seekableStart()
                        , o = n.liveCurrentTime();
                    if (s = a + r * n.liveWindow(),
                        s >= o && (s = o),
                        s <= a && (s = a + .1),
                        s === 1 / 0)
                        return
                }
                this.userSeek_(s)
            }
            enable() {
                super.enable();
                const t = this.getChild("mouseTimeDisplay");
                t && t.show()
            }
            disable() {
                super.disable();
                const t = this.getChild("mouseTimeDisplay");
                t && t.hide()
            }
            handleMouseUp(t) {
                super.handleMouseUp(t),
                    t && t.stopPropagation(),
                    this.player_.scrubbing(!1),
                    this.player_.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: !0
                    }),
                    this.videoWasPlaying ? ts(this.player_.play()) : this.update_()
            }
            stepForward() {
                this.userSeek_(this.player_.currentTime() + ml)
            }
            stepBack() {
                this.userSeek_(this.player_.currentTime() - ml)
            }
            handleAction(t) {
                this.player_.paused() ? this.player_.play() : this.player_.pause()
            }
            handleKeyDown(t) {
                const e = this.player_.liveTracker;
                if (we.default.isEventKey(t, "Space") || we.default.isEventKey(t, "Enter"))
                    t.preventDefault(),
                        t.stopPropagation(),
                        this.handleAction(t);
                else if (we.default.isEventKey(t, "Home"))
                    t.preventDefault(),
                        t.stopPropagation(),
                        this.userSeek_(0);
                else if (we.default.isEventKey(t, "End"))
                    t.preventDefault(),
                        t.stopPropagation(),
                        e && e.isLive() ? this.userSeek_(e.liveCurrentTime()) : this.userSeek_(this.player_.duration());
                else if (/^[0-9]$/.test((0,
                    we.default)(t))) {
                    t.preventDefault(),
                        t.stopPropagation();
                    const s = (we.default.codes[(0,
                        we.default)(t)] - we.default.codes[0]) * 10 / 100;
                    e && e.isLive() ? this.userSeek_(e.seekableStart() + e.liveWindow() * s) : this.userSeek_(this.player_.duration() * s)
                } else
                    we.default.isEventKey(t, "PgDn") ? (t.preventDefault(),
                        t.stopPropagation(),
                        this.userSeek_(this.player_.currentTime() - ml * up)) : we.default.isEventKey(t, "PgUp") ? (t.preventDefault(),
                            t.stopPropagation(),
                            this.userSeek_(this.player_.currentTime() + ml * up)) : super.handleKeyDown(t)
            }
            dispose() {
                this.disableInterval_(),
                    this.off(this.player_, ["ended", "durationchange", "timeupdate"], this.update),
                    this.player_.liveTracker && this.off(this.player_.liveTracker, "liveedgechange", this.update),
                    this.off(this.player_, ["playing"], this.enableIntervalHandler_),
                    this.off(this.player_, ["ended", "pause", "waiting"], this.disableIntervalHandler_),
                    "hidden" in le.default && "visibilityState" in le.default && this.off(le.default, "visibilitychange", this.toggleVisibility_),
                    super.dispose()
            }
        }
        ;
    ed.prototype.options_ = {
        children: ["loadProgressBar", "playProgressBar"],
        barName: "playProgressBar"
    },
        !jt && !Qi && ed.prototype.options_.children.splice(1, 0, "mouseTimeDisplay"),
        J.registerComponent("SeekBar", ed);
    var hp = class extends J {
        constructor(t, e) {
            super(t, e),
                this.handleMouseMove = es(Ge(this, this.handleMouseMove), Ti),
                this.throttledHandleMouseSeek = es(Ge(this, this.handleMouseSeek), Ti),
                this.handleMouseUpHandler_ = s => this.handleMouseUp(s),
                this.handleMouseDownHandler_ = s => this.handleMouseDown(s),
                this.enable()
        }
        createEl() {
            return super.createEl("div", {
                className: "vjs-progress-control vjs-control"
            })
        }
        handleMouseMove(t) {
            const e = this.getChild("seekBar");
            if (!e)
                return;
            const s = e.getChild("playProgressBar")
                , r = e.getChild("mouseTimeDisplay");
            if (!s && !r)
                return;
            const n = e.el()
                , a = Ea(n);
            let o = rl(n, t).x;
            o = xa(o, 0, 1),
                r && r.update(a, o),
                s && s.update(a, e.getProgress())
        }
        handleMouseSeek(t) {
            const e = this.getChild("seekBar");
            e && e.handleMouseMove(t)
        }
        enabled() {
            return this.enabled_
        }
        disable() {
            if (this.children().forEach(t => t.disable && t.disable()),
                !!this.enabled() && (this.off(["mousedown", "touchstart"], this.handleMouseDownHandler_),
                    this.off(this.el_, "mousemove", this.handleMouseMove),
                    this.removeListenersAddedOnMousedownAndTouchstart(),
                    this.addClass("disabled"),
                    this.enabled_ = !1,
                    this.player_.scrubbing())) {
                const t = this.getChild("seekBar");
                this.player_.scrubbing(!1),
                    t.videoWasPlaying && ts(this.player_.play())
            }
        }
        enable() {
            this.children().forEach(t => t.enable && t.enable()),
                !this.enabled() && (this.on(["mousedown", "touchstart"], this.handleMouseDownHandler_),
                    this.on(this.el_, "mousemove", this.handleMouseMove),
                    this.removeClass("disabled"),
                    this.enabled_ = !0)
        }
        removeListenersAddedOnMousedownAndTouchstart() {
            const t = this.el_.ownerDocument;
            this.off(t, "mousemove", this.throttledHandleMouseSeek),
                this.off(t, "touchmove", this.throttledHandleMouseSeek),
                this.off(t, "mouseup", this.handleMouseUpHandler_),
                this.off(t, "touchend", this.handleMouseUpHandler_)
        }
        handleMouseDown(t) {
            const e = this.el_.ownerDocument
                , s = this.getChild("seekBar");
            s && s.handleMouseDown(t),
                this.on(e, "mousemove", this.throttledHandleMouseSeek),
                this.on(e, "touchmove", this.throttledHandleMouseSeek),
                this.on(e, "mouseup", this.handleMouseUpHandler_),
                this.on(e, "touchend", this.handleMouseUpHandler_)
        }
        handleMouseUp(t) {
            const e = this.getChild("seekBar");
            e && e.handleMouseUp(t),
                this.removeListenersAddedOnMousedownAndTouchstart()
        }
    }
        ;
    hp.prototype.options_ = {
        children: ["seekBar"]
    },
        J.registerComponent("ProgressControl", hp);
    var dp = class extends hi {
        constructor(t, e) {
            super(t, e),
                this.setIcon("picture-in-picture-enter"),
                this.on(t, ["enterpictureinpicture", "leavepictureinpicture"], s => this.handlePictureInPictureChange(s)),
                this.on(t, ["disablepictureinpicturechanged", "loadedmetadata"], s => this.handlePictureInPictureEnabledChange(s)),
                this.on(t, ["loadedmetadata", "audioonlymodechange", "audiopostermodechange"], () => this.handlePictureInPictureAudioModeChange()),
                this.disable()
        }
        buildCSSClass() {
            return `vjs-picture-in-picture-control vjs-hidden ${super.buildCSSClass()}`
        }
        handlePictureInPictureAudioModeChange() {
            if (!(this.player_.currentType().substring(0, 5) === "audio" || this.player_.audioPosterMode() || this.player_.audioOnlyMode())) {
                this.show();
                return
            }
            this.player_.isInPictureInPicture() && this.player_.exitPictureInPicture(),
                this.hide()
        }
        handlePictureInPictureEnabledChange() {
            le.default.pictureInPictureEnabled && this.player_.disablePictureInPicture() === !1 || this.player_.options_.enableDocumentPictureInPicture && "documentPictureInPicture" in O.default ? this.enable() : this.disable()
        }
        handlePictureInPictureChange(t) {
            this.player_.isInPictureInPicture() ? (this.setIcon("picture-in-picture-exit"),
                this.controlText("Exit Picture-in-Picture")) : (this.setIcon("picture-in-picture-enter"),
                    this.controlText("Picture-in-Picture")),
                this.handlePictureInPictureEnabledChange()
        }
        handleClick(t) {
            this.player_.isInPictureInPicture() ? this.player_.exitPictureInPicture() : this.player_.requestPictureInPicture()
        }
        show() {
            typeof le.default.exitPictureInPicture == "function" && super.show()
        }
    }
        ;
    dp.prototype.controlText_ = "Picture-in-Picture",
        J.registerComponent("PictureInPictureToggle", dp);
    var cp = class extends hi {
        constructor(t, e) {
            super(t, e),
                this.setIcon("fullscreen-enter"),
                this.on(t, "fullscreenchange", s => this.handleFullscreenChange(s)),
                le.default[t.fsApi_.fullscreenEnabled] === !1 && this.disable()
        }
        buildCSSClass() {
            return `vjs-fullscreen-control ${super.buildCSSClass()}`
        }
        handleFullscreenChange(t) {
            this.player_.isFullscreen() ? (this.controlText("Exit Fullscreen"),
                this.setIcon("fullscreen-exit")) : (this.controlText("Fullscreen"),
                    this.setIcon("fullscreen-enter"))
        }
        handleClick(t) {
            this.player_.isFullscreen() ? this.player_.exitFullscreen() : this.player_.requestFullscreen()
        }
    }
        ;
    cp.prototype.controlText_ = "Fullscreen",
        J.registerComponent("FullscreenToggle", cp);
    var CT = function (t, e) {
        e.tech_ && !e.tech_.featuresVolumeControl && t.addClass("vjs-hidden"),
            t.on(e, "loadstart", function () {
                e.tech_.featuresVolumeControl ? t.removeClass("vjs-hidden") : t.addClass("vjs-hidden")
            })
    }
        , AT = class extends J {
            createEl() {
                const t = super.createEl("div", {
                    className: "vjs-volume-level"
                });
                return this.setIcon("circle", t),
                    t.appendChild(super.createEl("span", {
                        className: "vjs-control-text"
                    })),
                    t
            }
        }
        ;
    J.registerComponent("VolumeLevel", AT);
    var wT = class extends J {
        constructor(t, e) {
            super(t, e),
                this.update = es(Ge(this, this.update), Ti)
        }
        createEl() {
            return super.createEl("div", {
                className: "vjs-volume-tooltip"
            }, {
                "aria-hidden": "true"
            })
        }
        update(t, e, s, r) {
            if (!s) {
                const n = dn(this.el_)
                    , a = dn(this.player_.el())
                    , o = t.width * e;
                if (!a || !n)
                    return;
                const u = t.left - a.left + o
                    , c = t.width - o + (a.right - t.right);
                let f = n.width / 2;
                u < f ? f += f - u : c < f && (f = c),
                    f < 0 ? f = 0 : f > n.width && (f = n.width),
                    this.el_.style.right = `-${f}px`
            }
            this.write(`${r}%`)
        }
        write(t) {
            zs(this.el_, t)
        }
        updateVolume(t, e, s, r, n) {
            this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", () => {
                this.update(t, e, s, r.toFixed(0)),
                    n && n()
            }
            )
        }
    }
        ;
    J.registerComponent("VolumeLevelTooltip", wT);
    var fp = class extends J {
        constructor(t, e) {
            super(t, e),
                this.update = es(Ge(this, this.update), Ti)
        }
        createEl() {
            return super.createEl("div", {
                className: "vjs-mouse-display"
            })
        }
        update(t, e, s) {
            const r = 100 * e;
            this.getChild("volumeLevelTooltip").updateVolume(t, e, s, r, () => {
                s ? this.el_.style.bottom = `${t.height * e}px` : this.el_.style.left = `${t.width * e}px`
            }
            )
        }
    }
        ;
    fp.prototype.options_ = {
        children: ["volumeLevelTooltip"]
    },
        J.registerComponent("MouseVolumeLevelDisplay", fp);
    var gl = class extends Qh {
        constructor(t, e) {
            super(t, e),
                this.on("slideractive", s => this.updateLastVolume_(s)),
                this.on(t, "volumechange", s => this.updateARIAAttributes(s)),
                t.ready(() => this.updateARIAAttributes())
        }
        createEl() {
            return super.createEl("div", {
                className: "vjs-volume-bar vjs-slider-bar"
            }, {
                "aria-label": this.localize("Volume Level"),
                "aria-live": "polite"
            })
        }
        handleMouseDown(t) {
            Sa(t) && super.handleMouseDown(t)
        }
        handleMouseMove(t) {
            const e = this.getChild("mouseVolumeLevelDisplay");
            if (e) {
                const s = this.el()
                    , r = dn(s)
                    , n = this.vertical();
                let a = rl(s, t);
                a = n ? a.y : a.x,
                    a = xa(a, 0, 1),
                    e.update(r, a, n)
            }
            Sa(t) && (this.checkMuted(),
                this.player_.volume(this.calculateDistance(t)))
        }
        checkMuted() {
            this.player_.muted() && this.player_.muted(!1)
        }
        getPercent() {
            return this.player_.muted() ? 0 : this.player_.volume()
        }
        stepForward() {
            this.checkMuted(),
                this.player_.volume(this.player_.volume() + .1)
        }
        stepBack() {
            this.checkMuted(),
                this.player_.volume(this.player_.volume() - .1)
        }
        updateARIAAttributes(t) {
            const e = this.player_.muted() ? 0 : this.volumeAsPercentage_();
            this.el_.setAttribute("aria-valuenow", e),
                this.el_.setAttribute("aria-valuetext", e + "%")
        }
        volumeAsPercentage_() {
            return Math.round(this.player_.volume() * 100)
        }
        updateLastVolume_() {
            const t = this.player_.volume();
            this.one("sliderinactive", () => {
                this.player_.volume() === 0 && this.player_.lastVolume_(t)
            }
            )
        }
    }
        ;
    gl.prototype.options_ = {
        children: ["volumeLevel"],
        barName: "volumeLevel"
    },
        !jt && !Qi && gl.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay"),
        gl.prototype.playerEvent = "volumechange",
        J.registerComponent("VolumeBar", gl);
    var pp = class extends J {
        constructor(t, e = {}) {
            e.vertical = e.vertical || !1,
                (typeof e.volumeBar > "u" || nn(e.volumeBar)) && (e.volumeBar = e.volumeBar || {},
                    e.volumeBar.vertical = e.vertical),
                super(t, e),
                CT(this, t),
                this.throttledHandleMouseMove = es(Ge(this, this.handleMouseMove), Ti),
                this.handleMouseUpHandler_ = s => this.handleMouseUp(s),
                this.on("mousedown", s => this.handleMouseDown(s)),
                this.on("touchstart", s => this.handleMouseDown(s)),
                this.on("mousemove", s => this.handleMouseMove(s)),
                this.on(this.volumeBar, ["focus", "slideractive"], () => {
                    this.volumeBar.addClass("vjs-slider-active"),
                        this.addClass("vjs-slider-active"),
                        this.trigger("slideractive")
                }
                ),
                this.on(this.volumeBar, ["blur", "sliderinactive"], () => {
                    this.volumeBar.removeClass("vjs-slider-active"),
                        this.removeClass("vjs-slider-active"),
                        this.trigger("sliderinactive")
                }
                )
        }
        createEl() {
            let t = "vjs-volume-horizontal";
            return this.options_.vertical && (t = "vjs-volume-vertical"),
                super.createEl("div", {
                    className: `vjs-volume-control vjs-control ${t}`
                })
        }
        handleMouseDown(t) {
            const e = this.el_.ownerDocument;
            this.on(e, "mousemove", this.throttledHandleMouseMove),
                this.on(e, "touchmove", this.throttledHandleMouseMove),
                this.on(e, "mouseup", this.handleMouseUpHandler_),
                this.on(e, "touchend", this.handleMouseUpHandler_)
        }
        handleMouseUp(t) {
            const e = this.el_.ownerDocument;
            this.off(e, "mousemove", this.throttledHandleMouseMove),
                this.off(e, "touchmove", this.throttledHandleMouseMove),
                this.off(e, "mouseup", this.handleMouseUpHandler_),
                this.off(e, "touchend", this.handleMouseUpHandler_)
        }
        handleMouseMove(t) {
            this.volumeBar.handleMouseMove(t)
        }
    }
        ;
    pp.prototype.options_ = {
        children: ["volumeBar"]
    },
        J.registerComponent("VolumeControl", pp);
    var DT = function (t, e) {
        e.tech_ && !e.tech_.featuresMuteControl && t.addClass("vjs-hidden"),
            t.on(e, "loadstart", function () {
                e.tech_.featuresMuteControl ? t.removeClass("vjs-hidden") : t.addClass("vjs-hidden")
            })
    }
        , mp = class extends hi {
            constructor(t, e) {
                super(t, e),
                    DT(this, t),
                    this.on(t, ["loadstart", "volumechange"], s => this.update(s))
            }
            buildCSSClass() {
                return `vjs-mute-control ${super.buildCSSClass()}`
            }
            handleClick(t) {
                const e = this.player_.volume()
                    , s = this.player_.lastVolume_();
                if (e === 0) {
                    const r = s < .1 ? .1 : s;
                    this.player_.volume(r),
                        this.player_.muted(!1)
                } else
                    this.player_.muted(!this.player_.muted())
            }
            update(t) {
                this.updateIcon_(),
                    this.updateControlText_()
            }
            updateIcon_() {
                const t = this.player_.volume();
                let e = 3;
                this.setIcon("volume-high"),
                    jt && this.player_.tech_ && this.player_.tech_.el_ && this.player_.muted(this.player_.tech_.el_.muted),
                    t === 0 || this.player_.muted() ? (this.setIcon("volume-mute"),
                        e = 0) : t < .33 ? (this.setIcon("volume-low"),
                            e = 1) : t < .67 && (this.setIcon("volume-medium"),
                                e = 2),
                    il(this.el_, [0, 1, 2, 3].reduce((s, r) => s + `${r ? " " : ""}vjs-vol-${r}`, "")),
                    vr(this.el_, `vjs-vol-${e}`)
            }
            updateControlText_() {
                const e = this.player_.muted() || this.player_.volume() === 0 ? "Unmute" : "Mute";
                this.controlText() !== e && this.controlText(e)
            }
        }
        ;
    mp.prototype.controlText_ = "Mute",
        J.registerComponent("MuteToggle", mp);
    var gp = class extends J {
        constructor(t, e = {}) {
            typeof e.inline < "u" ? e.inline = e.inline : e.inline = !0,
                (typeof e.volumeControl > "u" || nn(e.volumeControl)) && (e.volumeControl = e.volumeControl || {},
                    e.volumeControl.vertical = !e.inline),
                super(t, e),
                this.handleKeyPressHandler_ = s => this.handleKeyPress(s),
                this.on(t, ["loadstart"], s => this.volumePanelState_(s)),
                this.on(this.muteToggle, "keyup", s => this.handleKeyPress(s)),
                this.on(this.volumeControl, "keyup", s => this.handleVolumeControlKeyUp(s)),
                this.on("keydown", s => this.handleKeyPress(s)),
                this.on("mouseover", s => this.handleMouseOver(s)),
                this.on("mouseout", s => this.handleMouseOut(s)),
                this.on(this.volumeControl, ["slideractive"], this.sliderActive_),
                this.on(this.volumeControl, ["sliderinactive"], this.sliderInactive_)
        }
        sliderActive_() {
            this.addClass("vjs-slider-active")
        }
        sliderInactive_() {
            this.removeClass("vjs-slider-active")
        }
        volumePanelState_() {
            this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-hidden"),
                this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden") && this.addClass("vjs-mute-toggle-only")
        }
        createEl() {
            let t = "vjs-volume-panel-horizontal";
            return this.options_.inline || (t = "vjs-volume-panel-vertical"),
                super.createEl("div", {
                    className: `vjs-volume-panel vjs-control ${t}`
                })
        }
        dispose() {
            this.handleMouseOut(),
                super.dispose()
        }
        handleVolumeControlKeyUp(t) {
            we.default.isEventKey(t, "Esc") && this.muteToggle.focus()
        }
        handleMouseOver(t) {
            this.addClass("vjs-hover"),
                ui(le.default, "keyup", this.handleKeyPressHandler_)
        }
        handleMouseOut(t) {
            this.removeClass("vjs-hover"),
                kt(le.default, "keyup", this.handleKeyPressHandler_)
        }
        handleKeyPress(t) {
            we.default.isEventKey(t, "Esc") && this.handleMouseOut()
        }
    }
        ;
    gp.prototype.options_ = {
        children: ["muteToggle", "volumeControl"]
    },
        J.registerComponent("VolumePanel", gp);
    var kT = class extends hi {
        constructor(t, e) {
            super(t, e),
                this.validOptions = [5, 10, 30],
                this.skipTime = this.getSkipForwardTime(),
                this.skipTime && this.validOptions.includes(this.skipTime) ? (this.setIcon(`forward-${this.skipTime}`),
                    this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime])),
                    this.show()) : this.hide()
        }
        getSkipForwardTime() {
            const t = this.options_.playerOptions;
            return t.controlBar && t.controlBar.skipButtons && t.controlBar.skipButtons.forward
        }
        buildCSSClass() {
            return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`
        }
        handleClick(t) {
            if (isNaN(this.player_.duration()))
                return;
            const e = this.player_.currentTime()
                , s = this.player_.liveTracker
                , r = s && s.isLive() ? s.seekableEnd() : this.player_.duration();
            let n;
            e + this.skipTime <= r ? n = e + this.skipTime : n = r,
                this.player_.currentTime(n)
        }
        handleLanguagechange() {
            this.controlText(this.localize("Skip forward {1} seconds", [this.skipTime]))
        }
    }
        ;
    J.registerComponent("SkipForward", kT);
    var vp = class extends hi {
        constructor(t, e) {
            super(t, e),
                this.validOptions = [5, 10, 30],
                this.skipTime = this.getSkipBackwardTime(),
                this.skipTime && this.validOptions.includes(this.skipTime) ? (this.setIcon(`replay-${this.skipTime}`),
                    this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime])),
                    this.show()) : this.hide()
        }
        getSkipBackwardTime() {
            const t = this.options_.playerOptions;
            return t.controlBar && t.controlBar.skipButtons && t.controlBar.skipButtons.backward
        }
        buildCSSClass() {
            return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`
        }
        handleClick(t) {
            const e = this.player_.currentTime()
                , s = this.player_.liveTracker
                , r = s && s.isLive() && s.seekableStart();
            let n;
            r && e - this.skipTime <= r ? n = r : e >= this.skipTime ? n = e - this.skipTime : n = 0,
                this.player_.currentTime(n)
        }
        handleLanguagechange() {
            this.controlText(this.localize("Skip backward {1} seconds", [this.skipTime]))
        }
    }
        ;
    vp.prototype.controlText_ = "Skip Backward",
        J.registerComponent("SkipBackward", vp);
    var yp = class extends J {
        constructor(t, e) {
            super(t, e),
                e && (this.menuButton_ = e.menuButton),
                this.focusedChild_ = -1,
                this.on("keydown", s => this.handleKeyDown(s)),
                this.boundHandleBlur_ = s => this.handleBlur(s),
                this.boundHandleTapClick_ = s => this.handleTapClick(s)
        }
        addEventListenerForItem(t) {
            t instanceof J && (this.on(t, "blur", this.boundHandleBlur_),
                this.on(t, ["tap", "click"], this.boundHandleTapClick_))
        }
        removeEventListenerForItem(t) {
            t instanceof J && (this.off(t, "blur", this.boundHandleBlur_),
                this.off(t, ["tap", "click"], this.boundHandleTapClick_))
        }
        removeChild(t) {
            typeof t == "string" && (t = this.getChild(t)),
                this.removeEventListenerForItem(t),
                super.removeChild(t)
        }
        addItem(t) {
            const e = this.addChild(t);
            e && this.addEventListenerForItem(e)
        }
        createEl() {
            const t = this.options_.contentElType || "ul";
            this.contentEl_ = De(t, {
                className: "vjs-menu-content"
            }),
                this.contentEl_.setAttribute("role", "menu");
            const e = super.createEl("div", {
                append: this.contentEl_,
                className: "vjs-menu"
            });
            return e.appendChild(this.contentEl_),
                ui(e, "click", function (s) {
                    s.preventDefault(),
                        s.stopImmediatePropagation()
                }),
                e
        }
        dispose() {
            this.contentEl_ = null,
                this.boundHandleBlur_ = null,
                this.boundHandleTapClick_ = null,
                super.dispose()
        }
        handleBlur(t) {
            const e = t.relatedTarget || le.default.activeElement;
            if (!this.children().some(s => s.el() === e)) {
                const s = this.menuButton_;
                s && s.buttonPressed_ && e !== s.el().firstChild && s.unpressButton()
            }
        }
        handleTapClick(t) {
            if (this.menuButton_) {
                this.menuButton_.unpressButton();
                const e = this.children();
                if (!Array.isArray(e))
                    return;
                const s = e.filter(r => r.el() === t.target)[0];
                if (!s)
                    return;
                s.name() !== "CaptionSettingsMenuItem" && this.menuButton_.focus()
            }
        }
        handleKeyDown(t) {
            we.default.isEventKey(t, "Left") || we.default.isEventKey(t, "Down") ? (t.preventDefault(),
                t.stopPropagation(),
                this.stepForward()) : (we.default.isEventKey(t, "Right") || we.default.isEventKey(t, "Up")) && (t.preventDefault(),
                    t.stopPropagation(),
                    this.stepBack())
        }
        stepForward() {
            let t = 0;
            this.focusedChild_ !== void 0 && (t = this.focusedChild_ + 1),
                this.focus(t)
        }
        stepBack() {
            let t = 0;
            this.focusedChild_ !== void 0 && (t = this.focusedChild_ - 1),
                this.focus(t)
        }
        focus(t = 0) {
            const e = this.children().slice();
            e.length && e[0].hasClass("vjs-menu-title") && e.shift(),
                e.length > 0 && (t < 0 ? t = 0 : t >= e.length && (t = e.length - 1),
                    this.focusedChild_ = t,
                    e[t].el_.focus())
        }
    }
        ;
    J.registerComponent("Menu", yp);
    var td = class extends J {
        constructor(t, e = {}) {
            super(t, e),
                this.menuButton_ = new hi(t, e),
                this.menuButton_.controlText(this.controlText_),
                this.menuButton_.el_.setAttribute("aria-haspopup", "true");
            const s = hi.prototype.buildCSSClass();
            this.menuButton_.el_.className = this.buildCSSClass() + " " + s,
                this.menuButton_.removeClass("vjs-control"),
                this.addChild(this.menuButton_),
                this.update(),
                this.enabled_ = !0;
            const r = n => this.handleClick(n);
            this.handleMenuKeyUp_ = n => this.handleMenuKeyUp(n),
                this.on(this.menuButton_, "tap", r),
                this.on(this.menuButton_, "click", r),
                this.on(this.menuButton_, "keydown", n => this.handleKeyDown(n)),
                this.on(this.menuButton_, "mouseenter", () => {
                    this.addClass("vjs-hover"),
                        this.menu.show(),
                        ui(le.default, "keyup", this.handleMenuKeyUp_)
                }
                ),
                this.on("mouseleave", n => this.handleMouseLeave(n)),
                this.on("keydown", n => this.handleSubmenuKeyDown(n))
        }
        update() {
            const t = this.createMenu();
            this.menu && (this.menu.dispose(),
                this.removeChild(this.menu)),
                this.menu = t,
                this.addChild(t),
                this.buttonPressed_ = !1,
                this.menuButton_.el_.setAttribute("aria-expanded", "false"),
                this.items && this.items.length <= this.hideThreshold_ ? (this.hide(),
                    this.menu.contentEl_.removeAttribute("role")) : (this.show(),
                        this.menu.contentEl_.setAttribute("role", "menu"))
        }
        createMenu() {
            const t = new yp(this.player_, {
                menuButton: this
            });
            if (this.hideThreshold_ = 0,
                this.options_.title) {
                const e = De("li", {
                    className: "vjs-menu-title",
                    textContent: tt(this.options_.title),
                    tabIndex: -1
                })
                    , s = new J(this.player_, {
                        el: e
                    });
                t.addItem(s)
            }
            if (this.items = this.createItems(),
                this.items)
                for (let e = 0; e < this.items.length; e++)
                    t.addItem(this.items[e]);
            return t
        }
        createItems() { }
        createEl() {
            return super.createEl("div", {
                className: this.buildWrapperCSSClass()
            }, {})
        }
        setIcon(t) {
            super.setIcon(t, this.menuButton_.el_)
        }
        buildWrapperCSSClass() {
            let t = "vjs-menu-button";
            this.options_.inline === !0 ? t += "-inline" : t += "-popup";
            const e = hi.prototype.buildCSSClass();
            return `vjs-menu-button ${t} ${e} ${super.buildCSSClass()}`
        }
        buildCSSClass() {
            let t = "vjs-menu-button";
            return this.options_.inline === !0 ? t += "-inline" : t += "-popup",
                `vjs-menu-button ${t} ${super.buildCSSClass()}`
        }
        controlText(t, e = this.menuButton_.el()) {
            return this.menuButton_.controlText(t, e)
        }
        dispose() {
            this.handleMouseLeave(),
                super.dispose()
        }
        handleClick(t) {
            this.buttonPressed_ ? this.unpressButton() : this.pressButton()
        }
        handleMouseLeave(t) {
            this.removeClass("vjs-hover"),
                kt(le.default, "keyup", this.handleMenuKeyUp_)
        }
        focus() {
            this.menuButton_.focus()
        }
        blur() {
            this.menuButton_.blur()
        }
        handleKeyDown(t) {
            we.default.isEventKey(t, "Esc") || we.default.isEventKey(t, "Tab") ? (this.buttonPressed_ && this.unpressButton(),
                we.default.isEventKey(t, "Tab") || (t.preventDefault(),
                    this.menuButton_.focus())) : (we.default.isEventKey(t, "Up") || we.default.isEventKey(t, "Down")) && (this.buttonPressed_ || (t.preventDefault(),
                        this.pressButton()))
        }
        handleMenuKeyUp(t) {
            (we.default.isEventKey(t, "Esc") || we.default.isEventKey(t, "Tab")) && this.removeClass("vjs-hover")
        }
        handleSubmenuKeyPress(t) {
            this.handleSubmenuKeyDown(t)
        }
        handleSubmenuKeyDown(t) {
            (we.default.isEventKey(t, "Esc") || we.default.isEventKey(t, "Tab")) && (this.buttonPressed_ && this.unpressButton(),
                we.default.isEventKey(t, "Tab") || (t.preventDefault(),
                    this.menuButton_.focus()))
        }
        pressButton() {
            if (this.enabled_) {
                if (this.buttonPressed_ = !0,
                    this.menu.show(),
                    this.menu.lockShowing(),
                    this.menuButton_.el_.setAttribute("aria-expanded", "true"),
                    jt && vf())
                    return;
                this.menu.focus()
            }
        }
        unpressButton() {
            this.enabled_ && (this.buttonPressed_ = !1,
                this.menu.unlockShowing(),
                this.menu.hide(),
                this.menuButton_.el_.setAttribute("aria-expanded", "false"))
        }
        disable() {
            this.unpressButton(),
                this.enabled_ = !1,
                this.addClass("vjs-disabled"),
                this.menuButton_.disable()
        }
        enable() {
            this.enabled_ = !0,
                this.removeClass("vjs-disabled"),
                this.menuButton_.enable()
        }
    }
        ;
    J.registerComponent("MenuButton", td);
    var id = class extends td {
        constructor(t, e) {
            const s = e.tracks;
            if (super(t, e),
                this.items.length <= 1 && this.hide(),
                !s)
                return;
            const r = Ge(this, this.update);
            s.addEventListener("removetrack", r),
                s.addEventListener("addtrack", r),
                s.addEventListener("labelchange", r),
                this.player_.on("ready", r),
                this.player_.on("dispose", function () {
                    s.removeEventListener("removetrack", r),
                        s.removeEventListener("addtrack", r),
                        s.removeEventListener("labelchange", r)
                })
        }
    }
        ;
    J.registerComponent("TrackButton", id);
    var xT = ["Tab", "Esc", "Up", "Down", "Right", "Left"]
        , Ia = class extends pl {
            constructor(t, e) {
                super(t, e),
                    this.selectable = e.selectable,
                    this.isSelected_ = e.selected || !1,
                    this.multiSelectable = e.multiSelectable,
                    this.selected(this.isSelected_),
                    this.selectable ? this.multiSelectable ? this.el_.setAttribute("role", "menuitemcheckbox") : this.el_.setAttribute("role", "menuitemradio") : this.el_.setAttribute("role", "menuitem")
            }
            createEl(t, e, s) {
                this.nonIconControl = !0;
                const r = super.createEl("li", Object.assign({
                    className: "vjs-menu-item",
                    tabIndex: -1
                }, e), s)
                    , n = De("span", {
                        className: "vjs-menu-item-text",
                        textContent: this.localize(this.options_.label)
                    });
                return this.player_.options_.experimentalSvgIcons ? r.appendChild(n) : r.replaceChild(n, r.querySelector(".vjs-icon-placeholder")),
                    r
            }
            handleKeyDown(t) {
                xT.some(e => we.default.isEventKey(t, e)) || super.handleKeyDown(t)
            }
            handleClick(t) {
                this.selected(!0)
            }
            selected(t) {
                this.selectable && (t ? (this.addClass("vjs-selected"),
                    this.el_.setAttribute("aria-checked", "true"),
                    this.controlText(", selected"),
                    this.isSelected_ = !0) : (this.removeClass("vjs-selected"),
                        this.el_.setAttribute("aria-checked", "false"),
                        this.controlText(""),
                        this.isSelected_ = !1))
            }
        }
        ;
    J.registerComponent("MenuItem", Ia);
    var Pa = class extends Ia {
        constructor(t, e) {
            const s = e.track
                , r = t.textTracks();
            e.label = s.label || s.language || "Unknown",
                e.selected = s.mode === "showing",
                super(t, e),
                this.track = s,
                this.kinds = (e.kinds || [e.kind || this.track.kind]).filter(Boolean);
            const n = (...o) => {
                this.handleTracksChange.apply(this, o)
            }
                , a = (...o) => {
                    this.handleSelectedLanguageChange.apply(this, o)
                }
                ;
            if (t.on(["loadstart", "texttrackchange"], n),
                r.addEventListener("change", n),
                r.addEventListener("selectedlanguagechange", a),
                this.on("dispose", function () {
                    t.off(["loadstart", "texttrackchange"], n),
                        r.removeEventListener("change", n),
                        r.removeEventListener("selectedlanguagechange", a)
                }),
                r.onchange === void 0) {
                let o;
                this.on(["tap", "click"], function () {
                    if (typeof O.default.Event != "object")
                        try {
                            o = new O.default.Event("change")
                        } catch (u) { }
                    o || (o = le.default.createEvent("Event"),
                        o.initEvent("change", !0, !0)),
                        r.dispatchEvent(o)
                })
            }
            this.handleTracksChange()
        }
        handleClick(t) {
            const e = this.track
                , s = this.player_.textTracks();
            if (super.handleClick(t),
                !!s)
                for (let r = 0; r < s.length; r++) {
                    const n = s[r];
                    this.kinds.indexOf(n.kind) !== -1 && (n === e ? n.mode !== "showing" && (n.mode = "showing") : n.mode !== "disabled" && (n.mode = "disabled"))
                }
        }
        handleTracksChange(t) {
            const e = this.track.mode === "showing";
            e !== this.isSelected_ && this.selected(e)
        }
        handleSelectedLanguageChange(t) {
            if (this.track.mode === "showing") {
                const e = this.player_.cache_.selectedLanguage;
                if (e && e.enabled && e.language === this.track.language && e.kind !== this.track.kind)
                    return;
                this.player_.cache_.selectedLanguage = {
                    enabled: !0,
                    language: this.track.language,
                    kind: this.track.kind
                }
            }
        }
        dispose() {
            this.track = null,
                super.dispose()
        }
    }
        ;
    J.registerComponent("TextTrackMenuItem", Pa);
    var _p = class extends Pa {
        constructor(t, e) {
            e.track = {
                player: t,
                kind: e.kind,
                kinds: e.kinds,
                default: !1,
                mode: "disabled"
            },
                e.kinds || (e.kinds = [e.kind]),
                e.label ? e.track.label = e.label : e.track.label = e.kinds.join(" and ") + " off",
                e.selectable = !0,
                e.multiSelectable = !1,
                super(t, e)
        }
        handleTracksChange(t) {
            const e = this.player().textTracks();
            let s = !0;
            for (let r = 0, n = e.length; r < n; r++) {
                const a = e[r];
                if (this.options_.kinds.indexOf(a.kind) > -1 && a.mode === "showing") {
                    s = !1;
                    break
                }
            }
            s !== this.isSelected_ && this.selected(s)
        }
        handleSelectedLanguageChange(t) {
            const e = this.player().textTracks();
            let s = !0;
            for (let r = 0, n = e.length; r < n; r++) {
                const a = e[r];
                if (["captions", "descriptions", "subtitles"].indexOf(a.kind) > -1 && a.mode === "showing") {
                    s = !1;
                    break
                }
            }
            s && (this.player_.cache_.selectedLanguage = {
                enabled: !1
            })
        }
        handleLanguagechange() {
            this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.label),
                super.handleLanguagechange()
        }
    }
        ;
    J.registerComponent("OffTextTrackMenuItem", _p);
    var _n = class extends id {
        constructor(t, e = {}) {
            e.tracks = t.textTracks(),
                super(t, e)
        }
        createItems(t = [], e = Pa) {
            let s;
            this.label_ && (s = `${this.label_} off`),
                t.push(new _p(this.player_, {
                    kinds: this.kinds_,
                    kind: this.kind_,
                    label: s
                })),
                this.hideThreshold_ += 1;
            const r = this.player_.textTracks();
            Array.isArray(this.kinds_) || (this.kinds_ = [this.kind_]);
            for (let n = 0; n < r.length; n++) {
                const a = r[n];
                if (this.kinds_.indexOf(a.kind) > -1) {
                    const o = new e(this.player_, {
                        track: a,
                        kinds: this.kinds_,
                        kind: this.kind_,
                        selectable: !0,
                        multiSelectable: !1
                    });
                    o.addClass(`vjs-${a.kind}-menu-item`),
                        t.push(o)
                }
            }
            return t
        }
    }
        ;
    J.registerComponent("TextTrackButton", _n);
    var Tp = class extends Ia {
        constructor(t, e) {
            const s = e.track
                , r = e.cue
                , n = t.currentTime();
            e.selectable = !0,
                e.multiSelectable = !1,
                e.label = r.text,
                e.selected = r.startTime <= n && n < r.endTime,
                super(t, e),
                this.track = s,
                this.cue = r
        }
        handleClick(t) {
            super.handleClick(),
                this.player_.currentTime(this.cue.startTime)
        }
    }
        ;
    J.registerComponent("ChaptersTrackMenuItem", Tp);
    var sd = class extends _n {
        constructor(t, e, s) {
            super(t, e, s),
                this.setIcon("chapters"),
                this.selectCurrentItem_ = () => {
                    this.items.forEach(r => {
                        r.selected(this.track_.activeCues[0] === r.cue)
                    }
                    )
                }
        }
        buildCSSClass() {
            return `vjs-chapters-button ${super.buildCSSClass()}`
        }
        buildWrapperCSSClass() {
            return `vjs-chapters-button ${super.buildWrapperCSSClass()}`
        }
        update(t) {
            if (t && t.track && t.track.kind !== "chapters")
                return;
            const e = this.findChaptersTrack();
            e !== this.track_ ? (this.setTrack(e),
                super.update()) : (!this.items || e && e.cues && e.cues.length !== this.items.length) && super.update()
        }
        setTrack(t) {
            if (this.track_ !== t) {
                if (this.updateHandler_ || (this.updateHandler_ = this.update.bind(this)),
                    this.track_) {
                    const e = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                    e && e.removeEventListener("load", this.updateHandler_),
                        this.track_.removeEventListener("cuechange", this.selectCurrentItem_),
                        this.track_ = null
                }
                if (this.track_ = t,
                    this.track_) {
                    this.track_.mode = "hidden";
                    const e = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                    e && e.addEventListener("load", this.updateHandler_),
                        this.track_.addEventListener("cuechange", this.selectCurrentItem_)
                }
            }
        }
        findChaptersTrack() {
            const t = this.player_.textTracks() || [];
            for (let e = t.length - 1; e >= 0; e--) {
                const s = t[e];
                if (s.kind === this.kind_)
                    return s
            }
        }
        getMenuCaption() {
            return this.track_ && this.track_.label ? this.track_.label : this.localize(tt(this.kind_))
        }
        createMenu() {
            return this.options_.title = this.getMenuCaption(),
                super.createMenu()
        }
        createItems() {
            const t = [];
            if (!this.track_)
                return t;
            const e = this.track_.cues;
            if (!e)
                return t;
            for (let s = 0, r = e.length; s < r; s++) {
                const n = e[s]
                    , a = new Tp(this.player_, {
                        track: this.track_,
                        cue: n
                    });
                t.push(a)
            }
            return t
        }
    }
        ;
    sd.prototype.kind_ = "chapters",
        sd.prototype.controlText_ = "Chapters",
        J.registerComponent("ChaptersButton", sd);
    var rd = class extends _n {
        constructor(t, e, s) {
            super(t, e, s),
                this.setIcon("audio-description");
            const r = t.textTracks()
                , n = Ge(this, this.handleTracksChange);
            r.addEventListener("change", n),
                this.on("dispose", function () {
                    r.removeEventListener("change", n)
                })
        }
        handleTracksChange(t) {
            const e = this.player().textTracks();
            let s = !1;
            for (let r = 0, n = e.length; r < n; r++) {
                const a = e[r];
                if (a.kind !== this.kind_ && a.mode === "showing") {
                    s = !0;
                    break
                }
            }
            s ? this.disable() : this.enable()
        }
        buildCSSClass() {
            return `vjs-descriptions-button ${super.buildCSSClass()}`
        }
        buildWrapperCSSClass() {
            return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`
        }
    }
        ;
    rd.prototype.kind_ = "descriptions",
        rd.prototype.controlText_ = "Descriptions",
        J.registerComponent("DescriptionsButton", rd);
    var nd = class extends _n {
        constructor(t, e, s) {
            super(t, e, s),
                this.setIcon("subtitles")
        }
        buildCSSClass() {
            return `vjs-subtitles-button ${super.buildCSSClass()}`
        }
        buildWrapperCSSClass() {
            return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`
        }
    }
        ;
    nd.prototype.kind_ = "subtitles",
        nd.prototype.controlText_ = "Subtitles",
        J.registerComponent("SubtitlesButton", nd);
    var ad = class extends Pa {
        constructor(t, e) {
            e.track = {
                player: t,
                kind: e.kind,
                label: e.kind + " settings",
                selectable: !1,
                default: !1,
                mode: "disabled"
            },
                e.selectable = !1,
                e.name = "CaptionSettingsMenuItem",
                super(t, e),
                this.addClass("vjs-texttrack-settings"),
                this.controlText(", opens " + e.kind + " settings dialog")
        }
        handleClick(t) {
            this.player().getChild("textTrackSettings").open()
        }
        handleLanguagechange() {
            this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.kind + " settings"),
                super.handleLanguagechange()
        }
    }
        ;
    J.registerComponent("CaptionSettingsMenuItem", ad);
    var od = class extends _n {
        constructor(t, e, s) {
            super(t, e, s),
                this.setIcon("captions")
        }
        buildCSSClass() {
            return `vjs-captions-button ${super.buildCSSClass()}`
        }
        buildWrapperCSSClass() {
            return `vjs-captions-button ${super.buildWrapperCSSClass()}`
        }
        createItems() {
            const t = [];
            return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (t.push(new ad(this.player_, {
                kind: this.kind_
            })),
                this.hideThreshold_ += 1),
                super.createItems(t)
        }
    }
        ;
    od.prototype.kind_ = "captions",
        od.prototype.controlText_ = "Captions",
        J.registerComponent("CaptionsButton", od);
    var bp = class extends Pa {
        createEl(t, e, s) {
            const r = super.createEl(t, e, s)
                , n = r.querySelector(".vjs-menu-item-text");
            return this.options_.track.kind === "captions" && (this.player_.options_.experimentalSvgIcons ? this.setIcon("captions", r) : n.appendChild(De("span", {
                className: "vjs-icon-placeholder"
            }, {
                "aria-hidden": !0
            })),
                n.appendChild(De("span", {
                    className: "vjs-control-text",
                    textContent: ` ${this.localize("Captions")}`
                }))),
                r
        }
    }
        ;
    J.registerComponent("SubsCapsMenuItem", bp);
    var ld = class extends _n {
        constructor(t, e = {}) {
            super(t, e),
                this.label_ = "subtitles",
                this.setIcon("subtitles"),
                ["en", "en-us", "en-ca", "fr-ca"].indexOf(this.player_.language_) > -1 && (this.label_ = "captions",
                    this.setIcon("captions")),
                this.menuButton_.controlText(tt(this.label_))
        }
        buildCSSClass() {
            return `vjs-subs-caps-button ${super.buildCSSClass()}`
        }
        buildWrapperCSSClass() {
            return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`
        }
        createItems() {
            let t = [];
            return !(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings") && (t.push(new ad(this.player_, {
                kind: this.label_
            })),
                this.hideThreshold_ += 1),
                t = super.createItems(t, bp),
                t
        }
    }
        ;
    ld.prototype.kinds_ = ["captions", "subtitles"],
        ld.prototype.controlText_ = "Subtitles",
        J.registerComponent("SubsCapsButton", ld);
    var Ep = class extends Ia {
        constructor(t, e) {
            const s = e.track
                , r = t.audioTracks();
            e.label = s.label || s.language || "Unknown",
                e.selected = s.enabled,
                super(t, e),
                this.track = s,
                this.addClass(`vjs-${s.kind}-menu-item`);
            const n = (...a) => {
                this.handleTracksChange.apply(this, a)
            }
                ;
            r.addEventListener("change", n),
                this.on("dispose", () => {
                    r.removeEventListener("change", n)
                }
                )
        }
        createEl(t, e, s) {
            const r = super.createEl(t, e, s)
                , n = r.querySelector(".vjs-menu-item-text");
            return ["main-desc", "description"].indexOf(this.options_.track.kind) >= 0 && (n.appendChild(De("span", {
                className: "vjs-icon-placeholder"
            }, {
                "aria-hidden": !0
            })),
                n.appendChild(De("span", {
                    className: "vjs-control-text",
                    textContent: " " + this.localize("Descriptions")
                }))),
                r
        }
        handleClick(t) {
            if (super.handleClick(t),
                this.track.enabled = !0,
                this.player_.tech_.featuresNativeAudioTracks) {
                const e = this.player_.audioTracks();
                for (let s = 0; s < e.length; s++) {
                    const r = e[s];
                    r !== this.track && (r.enabled = r === this.track)
                }
            }
        }
        handleTracksChange(t) {
            this.selected(this.track.enabled)
        }
    }
        ;
    J.registerComponent("AudioTrackMenuItem", Ep);
    var Sp = class extends id {
        constructor(t, e = {}) {
            e.tracks = t.audioTracks(),
                super(t, e),
                this.setIcon("audio")
        }
        buildCSSClass() {
            return `vjs-audio-button ${super.buildCSSClass()}`
        }
        buildWrapperCSSClass() {
            return `vjs-audio-button ${super.buildWrapperCSSClass()}`
        }
        createItems(t = []) {
            this.hideThreshold_ = 1;
            const e = this.player_.audioTracks();
            for (let s = 0; s < e.length; s++) {
                const r = e[s];
                t.push(new Ep(this.player_, {
                    track: r,
                    selectable: !0,
                    multiSelectable: !1
                }))
            }
            return t
        }
    }
        ;
    Sp.prototype.controlText_ = "Audio Track",
        J.registerComponent("AudioTrackButton", Sp);
    var ud = class extends Ia {
        constructor(t, e) {
            const s = e.rate
                , r = parseFloat(s, 10);
            e.label = s,
                e.selected = r === t.playbackRate(),
                e.selectable = !0,
                e.multiSelectable = !1,
                super(t, e),
                this.label = s,
                this.rate = r,
                this.on(t, "ratechange", n => this.update(n))
        }
        handleClick(t) {
            super.handleClick(),
                this.player().playbackRate(this.rate)
        }
        update(t) {
            this.selected(this.player().playbackRate() === this.rate)
        }
    }
        ;
    ud.prototype.contentElType = "button",
        J.registerComponent("PlaybackRateMenuItem", ud);
    var Cp = class extends td {
        constructor(t, e) {
            super(t, e),
                this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_),
                this.updateVisibility(),
                this.updateLabel(),
                this.on(t, "loadstart", s => this.updateVisibility(s)),
                this.on(t, "ratechange", s => this.updateLabel(s)),
                this.on(t, "playbackrateschange", s => this.handlePlaybackRateschange(s))
        }
        createEl() {
            const t = super.createEl();
            return this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_,
                this.labelEl_ = De("div", {
                    className: "vjs-playback-rate-value",
                    id: this.labelElId_,
                    textContent: "1x"
                }),
                t.appendChild(this.labelEl_),
                t
        }
        dispose() {
            this.labelEl_ = null,
                super.dispose()
        }
        buildCSSClass() {
            return `vjs-playback-rate ${super.buildCSSClass()}`
        }
        buildWrapperCSSClass() {
            return `vjs-playback-rate ${super.buildWrapperCSSClass()}`
        }
        createItems() {
            const t = this.playbackRates()
                , e = [];
            for (let s = t.length - 1; s >= 0; s--)
                e.push(new ud(this.player(), {
                    rate: t[s] + "x"
                }));
            return e
        }
        handlePlaybackRateschange(t) {
            this.update()
        }
        playbackRates() {
            const t = this.player();
            return t.playbackRates && t.playbackRates() || []
        }
        playbackRateSupported() {
            return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0
        }
        updateVisibility(t) {
            this.playbackRateSupported() ? this.removeClass("vjs-hidden") : this.addClass("vjs-hidden")
        }
        updateLabel(t) {
            this.playbackRateSupported() && (this.labelEl_.textContent = this.player().playbackRate() + "x")
        }
    }
        ;
    Cp.prototype.controlText_ = "Playback Rate",
        J.registerComponent("PlaybackRateMenuButton", Cp);
    var Ap = class extends J {
        buildCSSClass() {
            return `vjs-spacer ${super.buildCSSClass()}`
        }
        createEl(t = "div", e = {}, s = {}) {
            return e.className || (e.className = this.buildCSSClass()),
                super.createEl(t, e, s)
        }
    }
        ;
    J.registerComponent("Spacer", Ap);
    var IT = class extends Ap {
        buildCSSClass() {
            return `vjs-custom-control-spacer ${super.buildCSSClass()}`
        }
        createEl() {
            return super.createEl("div", {
                className: this.buildCSSClass(),
                textContent: "\xA0"
            })
        }
    }
        ;
    J.registerComponent("CustomControlSpacer", IT);
    var wp = class extends J {
        createEl() {
            return super.createEl("div", {
                className: "vjs-control-bar",
                dir: "ltr"
            })
        }
    }
        ;
    wp.prototype.options_ = {
        children: ["playToggle", "skipBackward", "skipForward", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "pictureInPictureToggle", "fullscreenToggle"]
    },
        J.registerComponent("ControlBar", wp);
    var Dp = class extends pn {
        constructor(t, e) {
            super(t, e),
                this.on(t, "error", s => {
                    this.close(),
                        this.open(s)
                }
                )
        }
        buildCSSClass() {
            return `vjs-error-display ${super.buildCSSClass()}`
        }
        content() {
            const t = this.player().error();
            return t ? this.localize(t.message) : ""
        }
    }
        ;
    Dp.prototype.options_ = Object.assign({}, pn.prototype.options_, {
        pauseOnOpen: !1,
        fillAlways: !0,
        temporary: !1,
        uncloseable: !0
    }),
        J.registerComponent("ErrorDisplay", Dp);
    var hd = "vjs-text-track-settings"
        , kp = ["#000", "Black"]
        , xp = ["#00F", "Blue"]
        , Ip = ["#0FF", "Cyan"]
        , Pp = ["#0F0", "Green"]
        , Lp = ["#F0F", "Magenta"]
        , Op = ["#F00", "Red"]
        , Mp = ["#FFF", "White"]
        , Rp = ["#FF0", "Yellow"]
        , dd = ["1", "Opaque"]
        , cd = ["0.5", "Semi-Transparent"]
        , Np = ["0", "Transparent"]
        , Er = {
            backgroundColor: {
                selector: ".vjs-bg-color > select",
                id: "captions-background-color-%s",
                label: "Color",
                options: [kp, Mp, Op, Pp, xp, Rp, Lp, Ip]
            },
            backgroundOpacity: {
                selector: ".vjs-bg-opacity > select",
                id: "captions-background-opacity-%s",
                label: "Opacity",
                options: [dd, cd, Np]
            },
            color: {
                selector: ".vjs-text-color > select",
                id: "captions-foreground-color-%s",
                label: "Color",
                options: [Mp, kp, Op, Pp, xp, Rp, Lp, Ip]
            },
            edgeStyle: {
                selector: ".vjs-edge-style > select",
                id: "%s",
                label: "Text Edge Style",
                options: [["none", "None"], ["raised", "Raised"], ["depressed", "Depressed"], ["uniform", "Uniform"], ["dropshadow", "Drop shadow"]]
            },
            fontFamily: {
                selector: ".vjs-font-family > select",
                id: "captions-font-family-%s",
                label: "Font Family",
                options: [["proportionalSansSerif", "Proportional Sans-Serif"], ["monospaceSansSerif", "Monospace Sans-Serif"], ["proportionalSerif", "Proportional Serif"], ["monospaceSerif", "Monospace Serif"], ["casual", "Casual"], ["script", "Script"], ["small-caps", "Small Caps"]]
            },
            fontPercent: {
                selector: ".vjs-font-percent > select",
                id: "captions-font-size-%s",
                label: "Font Size",
                options: [["0.50", "50%"], ["0.75", "75%"], ["1.00", "100%"], ["1.25", "125%"], ["1.50", "150%"], ["1.75", "175%"], ["2.00", "200%"], ["3.00", "300%"], ["4.00", "400%"]],
                default: 2,
                parser: t => t === "1.00" ? null : Number(t)
            },
            textOpacity: {
                selector: ".vjs-text-opacity > select",
                id: "captions-foreground-opacity-%s",
                label: "Opacity",
                options: [dd, cd]
            },
            windowColor: {
                selector: ".vjs-window-color > select",
                id: "captions-window-color-%s",
                label: "Color"
            },
            windowOpacity: {
                selector: ".vjs-window-opacity > select",
                id: "captions-window-opacity-%s",
                label: "Opacity",
                options: [Np, cd, dd]
            }
        };
    Er.windowColor.options = Er.backgroundColor.options;
    function Bp(t, e) {
        if (e && (t = e(t)),
            t && t !== "none")
            return t
    }
    function PT(t, e) {
        const s = t.options[t.options.selectedIndex].value;
        return Bp(s, e)
    }
    function LT(t, e, s) {
        if (e) {
            for (let r = 0; r < t.options.length; r++)
                if (Bp(t.options[r].value, s) === e) {
                    t.selectedIndex = r;
                    break
                }
        }
    }
    var OT = class extends pn {
        constructor(t, e) {
            e.temporary = !1,
                super(t, e),
                this.updateDisplay = this.updateDisplay.bind(this),
                this.fill(),
                this.hasBeenOpened_ = this.hasBeenFilled_ = !0,
                this.endDialog = De("p", {
                    className: "vjs-control-text",
                    textContent: this.localize("End of dialog window.")
                }),
                this.el().appendChild(this.endDialog),
                this.setDefaults(),
                e.persistTextTrackSettings === void 0 && (this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings),
                this.on(this.$(".vjs-done-button"), "click", () => {
                    this.saveSettings(),
                        this.close()
                }
                ),
                this.on(this.$(".vjs-default-button"), "click", () => {
                    this.setDefaults(),
                        this.updateDisplay()
                }
                ),
                rn(Er, s => {
                    this.on(this.$(s.selector), "change", this.updateDisplay)
                }
                ),
                this.options_.persistTextTrackSettings && this.restoreSettings()
        }
        dispose() {
            this.endDialog = null,
                super.dispose()
        }
        createElSelect_(t, e = "", s = "label") {
            const r = Er[t]
                , n = r.id.replace("%s", this.id_)
                , a = [e, n].join(" ").trim();
            return [`<${s} id="${n}" class="${s === "label" ? "vjs-label" : ""}">`, this.localize(r.label), `</${s}>`, `<select aria-labelledby="${a}">`].concat(r.options.map(o => {
                const u = n + "-" + o[1].replace(/\W+/g, "");
                return [`<option id="${u}" value="${o[0]}" `, `aria-labelledby="${a} ${u}">`, this.localize(o[1]), "</option>"].join("")
            }
            )).concat("</select>").join("")
        }
        createElFgColor_() {
            const t = `captions-text-legend-${this.id_}`;
            return ['<fieldset class="vjs-fg vjs-track-setting">', `<legend id="${t}">`, this.localize("Text"), "</legend>", '<span class="vjs-text-color">', this.createElSelect_("color", t), "</span>", '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", t), "</span>", "</fieldset>"].join("")
        }
        createElBgColor_() {
            const t = `captions-background-${this.id_}`;
            return ['<fieldset class="vjs-bg vjs-track-setting">', `<legend id="${t}">`, this.localize("Text Background"), "</legend>", '<span class="vjs-bg-color">', this.createElSelect_("backgroundColor", t), "</span>", '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", t), "</span>", "</fieldset>"].join("")
        }
        createElWinColor_() {
            const t = `captions-window-${this.id_}`;
            return ['<fieldset class="vjs-window vjs-track-setting">', `<legend id="${t}">`, this.localize("Caption Area Background"), "</legend>", '<span class="vjs-window-color">', this.createElSelect_("windowColor", t), "</span>", '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", t), "</span>", "</fieldset>"].join("")
        }
        createElColors_() {
            return De("div", {
                className: "vjs-track-settings-colors",
                innerHTML: [this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_()].join("")
            })
        }
        createElFont_() {
            return De("div", {
                className: "vjs-track-settings-font",
                innerHTML: ['<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>"].join("")
            })
        }
        createElControls_() {
            const t = this.localize("restore all settings to the default values");
            return De("div", {
                className: "vjs-track-settings-controls",
                innerHTML: [`<button type="button" class="vjs-default-button" title="${t}">`, this.localize("Reset"), `<span class="vjs-control-text"> ${t}</span>`, "</button>", `<button type="button" class="vjs-done-button">${this.localize("Done")}</button>`].join("")
            })
        }
        content() {
            return [this.createElColors_(), this.createElFont_(), this.createElControls_()]
        }
        label() {
            return this.localize("Caption Settings Dialog")
        }
        description() {
            return this.localize("Beginning of dialog window. Escape will cancel and close the window.")
        }
        buildCSSClass() {
            return super.buildCSSClass() + " vjs-text-track-settings"
        }
        getValues() {
            return hf(Er, (t, e, s) => {
                const r = PT(this.$(e.selector), e.parser);
                return r !== void 0 && (t[s] = r),
                    t
            }
                , {})
        }
        setValues(t) {
            rn(Er, (e, s) => {
                LT(this.$(e.selector), t[s], e.parser)
            }
            )
        }
        setDefaults() {
            rn(Er, t => {
                const e = t.hasOwnProperty("default") ? t.default : 0;
                this.$(t.selector).selectedIndex = e
            }
            )
        }
        restoreSettings() {
            let t;
            try {
                t = JSON.parse(O.default.localStorage.getItem(hd))
            } catch (e) {
                Ie.warn(e)
            }
            t && this.setValues(t)
        }
        saveSettings() {
            if (!this.options_.persistTextTrackSettings)
                return;
            const t = this.getValues();
            try {
                Object.keys(t).length ? O.default.localStorage.setItem(hd, JSON.stringify(t)) : O.default.localStorage.removeItem(hd)
            } catch (e) {
                Ie.warn(e)
            }
        }
        updateDisplay() {
            const t = this.player_.getChild("textTrackDisplay");
            t && t.updateDisplay()
        }
        conditionalBlur_() {
            this.previouslyActiveEl_ = null;
            const t = this.player_.controlBar
                , e = t && t.subsCapsButton
                , s = t && t.captionsButton;
            e ? e.focus() : s && s.focus()
        }
        handleLanguagechange() {
            this.fill()
        }
    }
        ;
    J.registerComponent("TextTrackSettings", OT);
    var MT = class extends J {
        constructor(t, e) {
            let s = e.ResizeObserver || O.default.ResizeObserver;
            e.ResizeObserver === null && (s = !1);
            const r = ze({
                createEl: !s,
                reportTouchActivity: !1
            }, e);
            super(t, r),
                this.ResizeObserver = e.ResizeObserver || O.default.ResizeObserver,
                this.loadListener_ = null,
                this.resizeObserver_ = null,
                this.debouncedHandler_ = Mf(() => {
                    this.resizeHandler()
                }
                    , 100, !1, this),
                s ? (this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_),
                    this.resizeObserver_.observe(t.el())) : (this.loadListener_ = () => {
                        if (!this.el_ || !this.el_.contentWindow)
                            return;
                        const n = this.debouncedHandler_;
                        let a = this.unloadListener_ = function () {
                            kt(this, "resize", n),
                                kt(this, "unload", a),
                                a = null
                        }
                            ;
                        ui(this.el_.contentWindow, "unload", a),
                            ui(this.el_.contentWindow, "resize", n)
                    }
                        ,
                        this.one("load", this.loadListener_))
        }
        createEl() {
            return super.createEl("iframe", {
                className: "vjs-resize-manager",
                tabIndex: -1,
                title: this.localize("No content")
            }, {
                "aria-hidden": "true"
            })
        }
        resizeHandler() {
            !this.player_ || !this.player_.trigger || this.player_.trigger("playerresize")
        }
        dispose() {
            this.debouncedHandler_ && this.debouncedHandler_.cancel(),
                this.resizeObserver_ && (this.player_.el() && this.resizeObserver_.unobserve(this.player_.el()),
                    this.resizeObserver_.disconnect()),
                this.loadListener_ && this.off("load", this.loadListener_),
                this.el_ && this.el_.contentWindow && this.unloadListener_ && this.unloadListener_.call(this.el_.contentWindow),
                this.ResizeObserver = null,
                this.resizeObserver = null,
                this.debouncedHandler_ = null,
                this.loadListener_ = null,
                super.dispose()
        }
    }
        ;
    J.registerComponent("ResizeManager", MT);
    var RT = {
        trackingThreshold: 20,
        liveTolerance: 15
    }
        , NT = class extends J {
            constructor(t, e) {
                const s = ze(RT, e, {
                    createEl: !1
                });
                super(t, s),
                    this.trackLiveHandler_ = () => this.trackLive_(),
                    this.handlePlay_ = r => this.handlePlay(r),
                    this.handleFirstTimeupdate_ = r => this.handleFirstTimeupdate(r),
                    this.handleSeeked_ = r => this.handleSeeked(r),
                    this.seekToLiveEdge_ = r => this.seekToLiveEdge(r),
                    this.reset_(),
                    this.on(this.player_, "durationchange", r => this.handleDurationchange(r)),
                    this.on(this.player_, "canplay", () => this.toggleTracking())
            }
            trackLive_() {
                const t = this.player_.seekable();
                if (!t || !t.length)
                    return;
                const e = Number(O.default.performance.now().toFixed(4))
                    , s = this.lastTime_ === -1 ? 0 : (e - this.lastTime_) / 1e3;
                this.lastTime_ = e,
                    this.pastSeekEnd_ = this.pastSeekEnd() + s;
                const r = this.liveCurrentTime()
                    , n = this.player_.currentTime();
                let a = this.player_.paused() || this.seekedBehindLive_ || Math.abs(r - n) > this.options_.liveTolerance;
                (!this.timeupdateSeen_ || r === 1 / 0) && (a = !1),
                    a !== this.behindLiveEdge_ && (this.behindLiveEdge_ = a,
                        this.trigger("liveedgechange"))
            }
            handleDurationchange() {
                this.toggleTracking()
            }
            toggleTracking() {
                this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold ? (this.player_.options_.liveui && this.player_.addClass("vjs-liveui"),
                    this.startTracking()) : (this.player_.removeClass("vjs-liveui"),
                        this.stopTracking())
            }
            startTracking() {
                this.isTracking() || (this.timeupdateSeen_ || (this.timeupdateSeen_ = this.player_.hasStarted()),
                    this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, Ti),
                    this.trackLive_(),
                    this.on(this.player_, ["play", "pause"], this.trackLiveHandler_),
                    this.timeupdateSeen_ ? this.on(this.player_, "seeked", this.handleSeeked_) : (this.one(this.player_, "play", this.handlePlay_),
                        this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_)))
            }
            handleFirstTimeupdate() {
                this.timeupdateSeen_ = !0,
                    this.on(this.player_, "seeked", this.handleSeeked_)
            }
            handleSeeked() {
                const t = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
                this.seekedBehindLive_ = this.nextSeekedFromUser_ && t > 2,
                    this.nextSeekedFromUser_ = !1,
                    this.trackLive_()
            }
            handlePlay() {
                this.one(this.player_, "timeupdate", this.seekToLiveEdge_)
            }
            reset_() {
                this.lastTime_ = -1,
                    this.pastSeekEnd_ = 0,
                    this.lastSeekEnd_ = -1,
                    this.behindLiveEdge_ = !0,
                    this.timeupdateSeen_ = !1,
                    this.seekedBehindLive_ = !1,
                    this.nextSeekedFromUser_ = !1,
                    this.clearInterval(this.trackingInterval_),
                    this.trackingInterval_ = null,
                    this.off(this.player_, ["play", "pause"], this.trackLiveHandler_),
                    this.off(this.player_, "seeked", this.handleSeeked_),
                    this.off(this.player_, "play", this.handlePlay_),
                    this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_),
                    this.off(this.player_, "timeupdate", this.seekToLiveEdge_)
            }
            nextSeekedFromUser() {
                this.nextSeekedFromUser_ = !0
            }
            stopTracking() {
                this.isTracking() && (this.reset_(),
                    this.trigger("liveedgechange"))
            }
            seekableEnd() {
                const t = this.player_.seekable()
                    , e = [];
                let s = t ? t.length : 0;
                for (; s--;)
                    e.push(t.end(s));
                return e.length ? e.sort()[e.length - 1] : 1 / 0
            }
            seekableStart() {
                const t = this.player_.seekable()
                    , e = [];
                let s = t ? t.length : 0;
                for (; s--;)
                    e.push(t.start(s));
                return e.length ? e.sort()[0] : 0
            }
            liveWindow() {
                const t = this.liveCurrentTime();
                return t === 1 / 0 ? 0 : t - this.seekableStart()
            }
            isLive() {
                return this.isTracking()
            }
            atLiveEdge() {
                return !this.behindLiveEdge()
            }
            liveCurrentTime() {
                return this.pastSeekEnd() + this.seekableEnd()
            }
            pastSeekEnd() {
                const t = this.seekableEnd();
                return this.lastSeekEnd_ !== -1 && t !== this.lastSeekEnd_ && (this.pastSeekEnd_ = 0),
                    this.lastSeekEnd_ = t,
                    this.pastSeekEnd_
            }
            behindLiveEdge() {
                return this.behindLiveEdge_
            }
            isTracking() {
                return typeof this.trackingInterval_ == "number"
            }
            seekToLiveEdge() {
                this.seekedBehindLive_ = !1,
                    !this.atLiveEdge() && (this.nextSeekedFromUser_ = !1,
                        this.player_.currentTime(this.liveCurrentTime()))
            }
            dispose() {
                this.stopTracking(),
                    super.dispose()
            }
        }
        ;
    J.registerComponent("LiveTracker", NT);
    var BT = class extends J {
        constructor(t, e) {
            super(t, e),
                this.on("statechanged", s => this.updateDom_()),
                this.updateDom_()
        }
        createEl() {
            return this.els = {
                title: De("div", {
                    className: "vjs-title-bar-title",
                    id: `vjs-title-bar-title-${Zi()}`
                }),
                description: De("div", {
                    className: "vjs-title-bar-description",
                    id: `vjs-title-bar-description-${Zi()}`
                })
            },
                De("div", {
                    className: "vjs-title-bar"
                }, {}, df(this.els))
        }
        updateDom_() {
            const t = this.player_.tech_
                , e = t && t.el_
                , s = {
                    title: "aria-labelledby",
                    description: "aria-describedby"
                };
            ["title", "description"].forEach(r => {
                const n = this.state[r]
                    , a = this.els[r]
                    , o = s[r];
                nl(a),
                    n && zs(a, n),
                    e && (e.removeAttribute(o),
                        n && e.setAttribute(o, a.id))
            }
            ),
                this.state.title || this.state.description ? this.show() : this.hide()
        }
        update(t) {
            this.setState(t)
        }
        dispose() {
            const t = this.player_.tech_
                , e = t && t.el_;
            e && (e.removeAttribute("aria-labelledby"),
                e.removeAttribute("aria-describedby")),
                super.dispose(),
                this.els = null
        }
    }
        ;
    J.registerComponent("TitleBar", BT);
    var fd = t => {
        const e = t.el();
        if (e.hasAttribute("src"))
            return t.triggerSourceset(e.src),
                !0;
        const s = t.$$("source")
            , r = [];
        let n = "";
        if (!s.length)
            return !1;
        for (let a = 0; a < s.length; a++) {
            const o = s[a].src;
            o && r.indexOf(o) === -1 && r.push(o)
        }
        return r.length ? (r.length === 1 && (n = r[0]),
            t.triggerSourceset(n),
            !0) : !1
    }
        , FT = Object.defineProperty({}, "innerHTML", {
            get() {
                return this.cloneNode(!0).innerHTML
            },
            set(t) {
                const e = le.default.createElement(this.nodeName.toLowerCase());
                e.innerHTML = t;
                const s = le.default.createDocumentFragment();
                for (; e.childNodes.length;)
                    s.appendChild(e.childNodes[0]);
                return this.innerText = "",
                    O.default.Element.prototype.appendChild.call(this, s),
                    this.innerHTML
            }
        })
        , Fp = (t, e) => {
            let s = {};
            for (let r = 0; r < t.length && (s = Object.getOwnPropertyDescriptor(t[r], e),
                !(s && s.set && s.get)); r++)
                ;
            return s.enumerable = !0,
                s.configurable = !0,
                s
        }
        , UT = t => Fp([t.el(), O.default.HTMLMediaElement.prototype, O.default.Element.prototype, FT], "innerHTML")
        , Up = function (t) {
            const e = t.el();
            if (e.resetSourceWatch_)
                return;
            const s = {}
                , r = UT(t)
                , n = a => (...o) => {
                    const u = a.apply(e, o);
                    return fd(t),
                        u
                }
                ;
            ["append", "appendChild", "insertAdjacentHTML"].forEach(a => {
                e[a] && (s[a] = e[a],
                    e[a] = n(s[a]))
            }
            ),
                Object.defineProperty(e, "innerHTML", ze(r, {
                    set: n(r.set)
                })),
                e.resetSourceWatch_ = () => {
                    e.resetSourceWatch_ = null,
                        Object.keys(s).forEach(a => {
                            e[a] = s[a]
                        }
                        ),
                        Object.defineProperty(e, "innerHTML", r)
                }
                ,
                t.one("sourceset", e.resetSourceWatch_)
        }
        , jT = Object.defineProperty({}, "src", {
            get() {
                return this.hasAttribute("src") ? Kf(O.default.Element.prototype.getAttribute.call(this, "src")) : ""
            },
            set(t) {
                return O.default.Element.prototype.setAttribute.call(this, "src", t),
                    t
            }
        })
        , HT = t => Fp([t.el(), O.default.HTMLMediaElement.prototype, jT], "src")
        , qT = function (t) {
            if (!t.featuresSourceset)
                return;
            const e = t.el();
            if (e.resetSourceset_)
                return;
            const s = HT(t)
                , r = e.setAttribute
                , n = e.load;
            Object.defineProperty(e, "src", ze(s, {
                set: a => {
                    const o = s.set.call(e, a);
                    return t.triggerSourceset(e.src),
                        o
                }
            })),
                e.setAttribute = (a, o) => {
                    const u = r.call(e, a, o);
                    return /src/i.test(a) && t.triggerSourceset(e.src),
                        u
                }
                ,
                e.load = () => {
                    const a = n.call(e);
                    return fd(t) || (t.triggerSourceset(""),
                        Up(t)),
                        a
                }
                ,
                e.currentSrc ? t.triggerSourceset(e.currentSrc) : fd(t) || Up(t),
                e.resetSourceset_ = () => {
                    e.resetSourceset_ = null,
                        e.load = n,
                        e.setAttribute = r,
                        Object.defineProperty(e, "src", s),
                        e.resetSourceWatch_ && e.resetSourceWatch_()
                }
        }
        , me = class eh extends He {
            constructor(e, s) {
                super(e, s);
                const r = e.source;
                let n = !1;
                if (this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === "VIDEO",
                    r && (this.el_.currentSrc !== r.src || e.tag && e.tag.initNetworkState_ === 3) ? this.setSource(r) : this.handleLateInit_(this.el_),
                    e.enableSourceset && this.setupSourcesetHandling_(),
                    this.isScrubbing_ = !1,
                    this.el_.hasChildNodes()) {
                    const a = this.el_.childNodes;
                    let o = a.length;
                    const u = [];
                    for (; o--;) {
                        const c = a[o];
                        c.nodeName.toLowerCase() === "track" && (this.featuresNativeTextTracks ? (this.remoteTextTrackEls().addTrackElement_(c),
                            this.remoteTextTracks().addTrack(c.track),
                            this.textTracks().addTrack(c.track),
                            !n && !this.el_.hasAttribute("crossorigin") && dl(c.src) && (n = !0)) : u.push(c))
                    }
                    for (let c = 0; c < u.length; c++)
                        this.el_.removeChild(u[c])
                }
                this.proxyNativeTracks_(),
                    this.featuresNativeTextTracks && n && Ie.warn(`Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.
This may prevent text tracks from loading.`),
                    this.restoreMetadataTracksInIOSNativePlayer_(),
                    (Ta || el) && e.nativeControlsForTouch === !0 && this.setControls(!0),
                    this.proxyWebkitFullscreen_(),
                    this.triggerReady()
            }
            dispose() {
                this.el_ && this.el_.resetSourceset_ && this.el_.resetSourceset_(),
                    eh.disposeMediaElement(this.el_),
                    this.options_ = null,
                    super.dispose()
            }
            setupSourcesetHandling_() {
                qT(this)
            }
            restoreMetadataTracksInIOSNativePlayer_() {
                const e = this.textTracks();
                let s;
                const r = () => {
                    s = [];
                    for (let a = 0; a < e.length; a++) {
                        const o = e[a];
                        o.kind === "metadata" && s.push({
                            track: o,
                            storedMode: o.mode
                        })
                    }
                }
                    ;
                r(),
                    e.addEventListener("change", r),
                    this.on("dispose", () => e.removeEventListener("change", r));
                const n = () => {
                    for (let a = 0; a < s.length; a++) {
                        const o = s[a];
                        o.track.mode === "disabled" && o.track.mode !== o.storedMode && (o.track.mode = o.storedMode)
                    }
                    e.removeEventListener("change", n)
                }
                    ;
                this.on("webkitbeginfullscreen", () => {
                    e.removeEventListener("change", r),
                        e.removeEventListener("change", n),
                        e.addEventListener("change", n)
                }
                ),
                    this.on("webkitendfullscreen", () => {
                        e.removeEventListener("change", r),
                            e.addEventListener("change", r),
                            e.removeEventListener("change", n)
                    }
                    )
            }
            overrideNative_(e, s) {
                if (s !== this[`featuresNative${e}Tracks`])
                    return;
                const r = e.toLowerCase();
                this[`${r}TracksListeners_`] && Object.keys(this[`${r}TracksListeners_`]).forEach(n => {
                    this.el()[`${r}Tracks`].removeEventListener(n, this[`${r}TracksListeners_`][n])
                }
                ),
                    this[`featuresNative${e}Tracks`] = !s,
                    this[`${r}TracksListeners_`] = null,
                    this.proxyNativeTracksForType_(r)
            }
            overrideNativeAudioTracks(e) {
                this.overrideNative_("Audio", e)
            }
            overrideNativeVideoTracks(e) {
                this.overrideNative_("Video", e)
            }
            proxyNativeTracksForType_(e) {
                const s = Ei[e]
                    , r = this.el()[s.getterName]
                    , n = this[s.getterName]();
                if (!this[`featuresNative${s.capitalName}Tracks`] || !r || !r.addEventListener)
                    return;
                const a = {
                    change: u => {
                        const c = {
                            type: "change",
                            target: n,
                            currentTarget: n,
                            srcElement: n
                        };
                        n.trigger(c),
                            e === "text" && this[vn.remoteText.getterName]().trigger(c)
                    }
                    ,
                    addtrack(u) {
                        n.addTrack(u.track)
                    },
                    removetrack(u) {
                        n.removeTrack(u.track)
                    }
                }
                    , o = function () {
                        const u = [];
                        for (let c = 0; c < n.length; c++) {
                            let f = !1;
                            for (let v = 0; v < r.length; v++)
                                if (r[v] === n[c]) {
                                    f = !0;
                                    break
                                }
                            f || u.push(n[c])
                        }
                        for (; u.length;)
                            n.removeTrack(u.shift())
                    };
                this[s.getterName + "Listeners_"] = a,
                    Object.keys(a).forEach(u => {
                        const c = a[u];
                        r.addEventListener(u, c),
                            this.on("dispose", f => r.removeEventListener(u, c))
                    }
                    ),
                    this.on("loadstart", o),
                    this.on("dispose", u => this.off("loadstart", o))
            }
            proxyNativeTracks_() {
                Ei.names.forEach(e => {
                    this.proxyNativeTracksForType_(e)
                }
                )
            }
            createEl() {
                let e = this.options_.tag;
                if (!e || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
                    if (e) {
                        const r = e.cloneNode(!0);
                        e.parentNode && e.parentNode.insertBefore(r, e),
                            eh.disposeMediaElement(e),
                            e = r
                    } else {
                        e = le.default.createElement("video");
                        const r = this.options_.tag && Gs(this.options_.tag)
                            , n = ze({}, r);
                        (!Ta || this.options_.nativeControlsForTouch !== !0) && delete n.controls,
                            Tf(e, Object.assign(n, {
                                id: this.options_.techId,
                                class: "vjs-tech"
                            }))
                    }
                    e.playerId = this.options_.playerId
                }
                typeof this.options_.preload < "u" && hn(e, "preload", this.options_.preload),
                    this.options_.disablePictureInPicture !== void 0 && (e.disablePictureInPicture = this.options_.disablePictureInPicture);
                const s = ["loop", "muted", "playsinline", "autoplay"];
                for (let r = 0; r < s.length; r++) {
                    const n = s[r]
                        , a = this.options_[n];
                    typeof a < "u" && (a ? hn(e, n, n) : sl(e, n),
                        e[n] = a)
                }
                return e
            }
            handleLateInit_(e) {
                if (e.networkState === 0 || e.networkState === 3)
                    return;
                if (e.readyState === 0) {
                    let r = !1;
                    const n = function () {
                        r = !0
                    };
                    this.on("loadstart", n);
                    const a = function () {
                        r || this.trigger("loadstart")
                    };
                    this.on("loadedmetadata", a),
                        this.ready(function () {
                            this.off("loadstart", n),
                                this.off("loadedmetadata", a),
                                r || this.trigger("loadstart")
                        });
                    return
                }
                const s = ["loadstart"];
                s.push("loadedmetadata"),
                    e.readyState >= 2 && s.push("loadeddata"),
                    e.readyState >= 3 && s.push("canplay"),
                    e.readyState >= 4 && s.push("canplaythrough"),
                    this.ready(function () {
                        s.forEach(function (r) {
                            this.trigger(r)
                        }, this)
                    })
            }
            setScrubbing(e) {
                this.isScrubbing_ = e
            }
            scrubbing() {
                return this.isScrubbing_
            }
            setCurrentTime(e) {
                try {
                    this.isScrubbing_ && this.el_.fastSeek && tl ? this.el_.fastSeek(e) : this.el_.currentTime = e
                } catch (s) {
                    Ie(s, "Video is not ready. (Video.js)")
                }
            }
            duration() {
                if (this.el_.duration === 1 / 0 && Qi && Ji && this.el_.currentTime === 0) {
                    const e = () => {
                        this.el_.currentTime > 0 && (this.el_.duration === 1 / 0 && this.trigger("durationchange"),
                            this.off("timeupdate", e))
                    }
                        ;
                    return this.on("timeupdate", e),
                        NaN
                }
                return this.el_.duration || NaN
            }
            width() {
                return this.el_.offsetWidth
            }
            height() {
                return this.el_.offsetHeight
            }
            proxyWebkitFullscreen_() {
                if (!("webkitDisplayingFullscreen" in this.el_))
                    return;
                const e = function () {
                    this.trigger("fullscreenchange", {
                        isFullscreen: !1
                    }),
                        this.el_.controls && !this.options_.nativeControlsForTouch && this.controls() && (this.el_.controls = !1)
                }
                    , s = function () {
                        "webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture" && (this.one("webkitendfullscreen", e),
                            this.trigger("fullscreenchange", {
                                isFullscreen: !0,
                                nativeIOSFullscreen: !0
                            }))
                    };
                this.on("webkitbeginfullscreen", s),
                    this.on("dispose", () => {
                        this.off("webkitbeginfullscreen", s),
                            this.off("webkitendfullscreen", e)
                    }
                    )
            }
            supportsFullScreen() {
                return typeof this.el_.webkitEnterFullScreen == "function"
            }
            enterFullScreen() {
                const e = this.el_;
                if (e.paused && e.networkState <= e.HAVE_METADATA)
                    ts(this.el_.play()),
                        this.setTimeout(function () {
                            e.pause();
                            try {
                                e.webkitEnterFullScreen()
                            } catch (s) {
                                this.trigger("fullscreenerror", s)
                            }
                        }, 0);
                else
                    try {
                        e.webkitEnterFullScreen()
                    } catch (s) {
                        this.trigger("fullscreenerror", s)
                    }
            }
            exitFullScreen() {
                if (!this.el_.webkitDisplayingFullscreen) {
                    this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
                    return
                }
                this.el_.webkitExitFullScreen()
            }
            requestPictureInPicture() {
                return this.el_.requestPictureInPicture()
            }
            requestVideoFrameCallback(e) {
                return this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.requestVideoFrameCallback(e) : super.requestVideoFrameCallback(e)
            }
            cancelVideoFrameCallback(e) {
                this.featuresVideoFrameCallback && !this.el_.webkitKeys ? this.el_.cancelVideoFrameCallback(e) : super.cancelVideoFrameCallback(e)
            }
            src(e) {
                if (e === void 0)
                    return this.el_.src;
                this.setSrc(e)
            }
            reset() {
                eh.resetMediaElement(this.el_)
            }
            currentSrc() {
                return this.currentSource_ ? this.currentSource_.src : this.el_.currentSrc
            }
            setControls(e) {
                this.el_.controls = !!e
            }
            addTextTrack(e, s, r) {
                return this.featuresNativeTextTracks ? this.el_.addTextTrack(e, s, r) : super.addTextTrack(e, s, r)
            }
            createRemoteTextTrack(e) {
                if (!this.featuresNativeTextTracks)
                    return super.createRemoteTextTrack(e);
                const s = le.default.createElement("track");
                return e.kind && (s.kind = e.kind),
                    e.label && (s.label = e.label),
                    (e.language || e.srclang) && (s.srclang = e.language || e.srclang),
                    e.default && (s.default = e.default),
                    e.id && (s.id = e.id),
                    e.src && (s.src = e.src),
                    s
            }
            addRemoteTextTrack(e, s) {
                const r = super.addRemoteTextTrack(e, s);
                return this.featuresNativeTextTracks && this.el().appendChild(r),
                    r
            }
            removeRemoteTextTrack(e) {
                if (super.removeRemoteTextTrack(e),
                    this.featuresNativeTextTracks) {
                    const s = this.$$("track");
                    let r = s.length;
                    for (; r--;)
                        (e === s[r] || e === s[r].track) && this.el().removeChild(s[r])
                }
            }
            getVideoPlaybackQuality() {
                if (typeof this.el().getVideoPlaybackQuality == "function")
                    return this.el().getVideoPlaybackQuality();
                const e = {};
                return typeof this.el().webkitDroppedFrameCount < "u" && typeof this.el().webkitDecodedFrameCount < "u" && (e.droppedVideoFrames = this.el().webkitDroppedFrameCount,
                    e.totalVideoFrames = this.el().webkitDecodedFrameCount),
                    O.default.performance && (e.creationTime = O.default.performance.now()),
                    e
            }
        }
        ;
    Xo(me, "TEST_VID", function () {
        if (!ln())
            return;
        const t = le.default.createElement("video")
            , e = le.default.createElement("track");
        return e.kind = "captions",
            e.srclang = "en",
            e.label = "English",
            t.appendChild(e),
            t
    }),
        me.isSupported = function () {
            try {
                me.TEST_VID.volume = .5
            } catch (t) {
                return !1
            }
            return !!(me.TEST_VID && me.TEST_VID.canPlayType)
        }
        ,
        me.canPlayType = function (t) {
            return me.TEST_VID.canPlayType(t)
        }
        ,
        me.canPlaySource = function (t, e) {
            return me.canPlayType(t.type)
        }
        ,
        me.canControlVolume = function () {
            try {
                const t = me.TEST_VID.volume;
                me.TEST_VID.volume = t / 2 + .1;
                const e = t !== me.TEST_VID.volume;
                return e && jt ? (O.default.setTimeout(() => {
                    me && me.prototype && (me.prototype.featuresVolumeControl = t !== me.TEST_VID.volume)
                }
                ),
                    !1) : e
            } catch (t) {
                return !1
            }
        }
        ,
        me.canMuteVolume = function () {
            try {
                const t = me.TEST_VID.muted;
                return me.TEST_VID.muted = !t,
                    me.TEST_VID.muted ? hn(me.TEST_VID, "muted", "muted") : sl(me.TEST_VID, "muted", "muted"),
                    t !== me.TEST_VID.muted
            } catch (t) {
                return !1
            }
        }
        ,
        me.canControlPlaybackRate = function () {
            if (Qi && Ji && Yo < 58)
                return !1;
            try {
                const t = me.TEST_VID.playbackRate;
                return me.TEST_VID.playbackRate = t / 2 + .1,
                    t !== me.TEST_VID.playbackRate
            } catch (t) {
                return !1
            }
        }
        ,
        me.canOverrideAttributes = function () {
            try {
                const t = () => { }
                    ;
                Object.defineProperty(le.default.createElement("video"), "src", {
                    get: t,
                    set: t
                }),
                    Object.defineProperty(le.default.createElement("audio"), "src", {
                        get: t,
                        set: t
                    }),
                    Object.defineProperty(le.default.createElement("video"), "innerHTML", {
                        get: t,
                        set: t
                    }),
                    Object.defineProperty(le.default.createElement("audio"), "innerHTML", {
                        get: t,
                        set: t
                    })
            } catch (t) {
                return !1
            }
            return !0
        }
        ,
        me.supportsNativeTextTracks = function () {
            return tl || jt && Ji
        }
        ,
        me.supportsNativeVideoTracks = function () {
            return !!(me.TEST_VID && me.TEST_VID.videoTracks)
        }
        ,
        me.supportsNativeAudioTracks = function () {
            return !!(me.TEST_VID && me.TEST_VID.audioTracks)
        }
        ,
        me.Events = ["loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange"],
        [["featuresMuteControl", "canMuteVolume"], ["featuresPlaybackRate", "canControlPlaybackRate"], ["featuresSourceset", "canOverrideAttributes"], ["featuresNativeTextTracks", "supportsNativeTextTracks"], ["featuresNativeVideoTracks", "supportsNativeVideoTracks"], ["featuresNativeAudioTracks", "supportsNativeAudioTracks"]].forEach(function ([t, e]) {
            Xo(me.prototype, t, () => me[e](), !0)
        }),
        me.prototype.featuresVolumeControl = me.canControlVolume(),
        me.prototype.movingMediaElementInDOM = !jt,
        me.prototype.featuresFullscreenResize = !0,
        me.prototype.featuresProgressEvents = !0,
        me.prototype.featuresTimeupdateEvents = !0,
        me.prototype.featuresVideoFrameCallback = !!(me.TEST_VID && me.TEST_VID.requestVideoFrameCallback),
        me.disposeMediaElement = function (t) {
            if (t) {
                for (t.parentNode && t.parentNode.removeChild(t); t.hasChildNodes();)
                    t.removeChild(t.firstChild);
                t.removeAttribute("src"),
                    typeof t.load == "function" && function () {
                        try {
                            t.load()
                        } catch (e) { }
                    }()
            }
        }
        ,
        me.resetMediaElement = function (t) {
            if (!t)
                return;
            const e = t.querySelectorAll("source");
            let s = e.length;
            for (; s--;)
                t.removeChild(e[s]);
            t.removeAttribute("src"),
                typeof t.load == "function" && function () {
                    try {
                        t.load()
                    } catch (r) { }
                }()
        }
        ,
        ["muted", "defaultMuted", "autoplay", "controls", "loop", "playsinline"].forEach(function (t) {
            me.prototype[t] = function () {
                return this.el_[t] || this.el_.hasAttribute(t)
            }
        }),
        ["muted", "defaultMuted", "autoplay", "loop", "playsinline"].forEach(function (t) {
            me.prototype["set" + tt(t)] = function (e) {
                this.el_[t] = e,
                    e ? this.el_.setAttribute(t, t) : this.el_.removeAttribute(t)
            }
        }),
        ["paused", "currentTime", "buffered", "volume", "poster", "preload", "error", "seeking", "seekable", "ended", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "played", "networkState", "readyState", "videoWidth", "videoHeight", "crossOrigin"].forEach(function (t) {
            me.prototype[t] = function () {
                return this.el_[t]
            }
        }),
        ["volume", "src", "poster", "preload", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "crossOrigin"].forEach(function (t) {
            me.prototype["set" + tt(t)] = function (e) {
                this.el_[t] = e
            }
        }),
        ["pause", "load", "play"].forEach(function (t) {
            me.prototype[t] = function () {
                return this.el_[t]()
            }
        }),
        He.withSourceHandlers(me),
        me.nativeSourceHandler = {},
        me.nativeSourceHandler.canPlayType = function (t) {
            try {
                return me.TEST_VID.canPlayType(t)
            } catch (e) {
                return ""
            }
        }
        ,
        me.nativeSourceHandler.canHandleSource = function (t, e) {
            if (t.type)
                return me.nativeSourceHandler.canPlayType(t.type);
            if (t.src) {
                const s = $h(t.src);
                return me.nativeSourceHandler.canPlayType(`video/${s}`)
            }
            return ""
        }
        ,
        me.nativeSourceHandler.handleSource = function (t, e, s) {
            e.setSrc(t.src)
        }
        ,
        me.nativeSourceHandler.dispose = function () { }
        ,
        me.registerSourceHandler(me.nativeSourceHandler),
        He.registerTech("Html5", me);
    var jp = ["progress", "abort", "suspend", "emptied", "stalled", "loadedmetadata", "loadeddata", "timeupdate", "resize", "volumechange", "texttrackchange"]
        , pd = {
            canplay: "CanPlay",
            canplaythrough: "CanPlayThrough",
            playing: "Playing",
            seeked: "Seeked"
        }
        , md = ["tiny", "xsmall", "small", "medium", "large", "xlarge", "huge"]
        , vl = {};
    md.forEach(t => {
        const e = t.charAt(0) === "x" ? `x-${t.substring(1)}` : t;
        vl[t] = `vjs-layout-${e}`
    }
    );
    var $T = {
        tiny: 210,
        xsmall: 320,
        small: 425,
        medium: 768,
        large: 1440,
        xlarge: 2560,
        huge: 1 / 0
    }
        , ht = class pa extends J {
            constructor(e, s, r) {
                if (e.id = e.id || s.id || `vjs_video_${Zi()}`,
                    s = Object.assign(pa.getTagSettings(e), s),
                    s.initChildren = !1,
                    s.createEl = !1,
                    s.evented = !1,
                    s.reportTouchActivity = !1,
                    !s.language) {
                    const o = e.closest("[lang]");
                    o && (s.language = o.getAttribute("lang"))
                }
                if (super(null, s, r),
                    this.boundDocumentFullscreenChange_ = o => this.documentFullscreenChange_(o),
                    this.boundFullWindowOnEscKey_ = o => this.fullWindowOnEscKey(o),
                    this.boundUpdateStyleEl_ = o => this.updateStyleEl_(o),
                    this.boundApplyInitTime_ = o => this.applyInitTime_(o),
                    this.boundUpdateCurrentBreakpoint_ = o => this.updateCurrentBreakpoint_(o),
                    this.boundHandleTechClick_ = o => this.handleTechClick_(o),
                    this.boundHandleTechDoubleClick_ = o => this.handleTechDoubleClick_(o),
                    this.boundHandleTechTouchStart_ = o => this.handleTechTouchStart_(o),
                    this.boundHandleTechTouchMove_ = o => this.handleTechTouchMove_(o),
                    this.boundHandleTechTouchEnd_ = o => this.handleTechTouchEnd_(o),
                    this.boundHandleTechTap_ = o => this.handleTechTap_(o),
                    this.isFullscreen_ = !1,
                    this.log = lf(this.id_),
                    this.fsApi_ = Wo,
                    this.isPosterFromTech_ = !1,
                    this.queuedCallbacks_ = [],
                    this.isReady_ = !1,
                    this.hasStarted_ = !1,
                    this.userActive_ = !1,
                    this.debugEnabled_ = !1,
                    this.audioOnlyMode_ = !1,
                    this.audioPosterMode_ = !1,
                    this.audioOnlyCache_ = {
                        playerHeight: null,
                        hiddenChildren: []
                    },
                    !this.options_ || !this.options_.techOrder || !this.options_.techOrder.length)
                    throw new Error("No techOrder specified. Did you overwrite videojs.options instead of just changing the properties you want to override?");
                if (this.tag = e,
                    this.tagAttributes = e && Gs(e),
                    this.language(this.options_.language),
                    s.languages) {
                    const o = {};
                    Object.getOwnPropertyNames(s.languages).forEach(function (u) {
                        o[u.toLowerCase()] = s.languages[u]
                    }),
                        this.languages_ = o
                } else
                    this.languages_ = pa.prototype.options_.languages;
                this.resetCache_(),
                    this.poster_ = s.poster || "",
                    this.controls_ = !!s.controls,
                    e.controls = !1,
                    e.removeAttribute("controls"),
                    this.changingSrc_ = !1,
                    this.playCallbacks_ = [],
                    this.playTerminatedQueue_ = [],
                    e.hasAttribute("autoplay") ? this.autoplay(!0) : this.autoplay(this.options_.autoplay),
                    s.plugins && Object.keys(s.plugins).forEach(o => {
                        if (typeof this[o] != "function")
                            throw new Error(`plugin "${o}" does not exist`)
                    }
                    ),
                    this.scrubbing_ = !1,
                    this.el_ = this.createEl(),
                    Mh(this, {
                        eventBusKey: "el_"
                    }),
                    this.fsApi_.requestFullscreen && (ui(le.default, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_),
                        this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_)),
                    this.fluid_ && this.on(["playerreset", "resize"], this.boundUpdateStyleEl_);
                const n = ze(this.options_);
                if (s.plugins && Object.keys(s.plugins).forEach(o => {
                    this[o](s.plugins[o])
                }
                ),
                    s.debug && this.debug(!0),
                    this.options_.playerOptions = n,
                    this.middleware_ = [],
                    this.playbackRates(s.playbackRates),
                    s.experimentalSvgIcons) {
                    const u = new O.default.DOMParser().parseFromString(fT, "image/svg+xml");
                    if (u.querySelector("parsererror"))
                        Ie.warn("Failed to load SVG Icons. Falling back to Font Icons."),
                            this.options_.experimentalSvgIcons = null;
                    else {
                        const f = u.documentElement;
                        f.style.display = "none",
                            this.el_.appendChild(f),
                            this.addClass("vjs-svg-icons-enabled")
                    }
                }
                this.initChildren(),
                    this.isAudio(e.nodeName.toLowerCase() === "audio"),
                    this.controls() ? this.addClass("vjs-controls-enabled") : this.addClass("vjs-controls-disabled"),
                    this.el_.setAttribute("role", "region"),
                    this.isAudio() ? this.el_.setAttribute("aria-label", this.localize("Audio Player")) : this.el_.setAttribute("aria-label", this.localize("Video Player")),
                    this.isAudio() && this.addClass("vjs-audio"),
                    Ta && this.addClass("vjs-touch-enabled"),
                    jt || this.addClass("vjs-workinghover"),
                    pa.players[this.id_] = this;
                const a = nf.split(".")[0];
                this.addClass(`vjs-v${a}`),
                    this.userActive(!0),
                    this.reportUserActivity(),
                    this.one("play", o => this.listenForUserActivity_(o)),
                    this.on("keydown", o => this.handleKeyDown(o)),
                    this.on("languagechange", o => this.handleLanguagechange(o)),
                    this.breakpoints(this.options_.breakpoints),
                    this.responsive(this.options_.responsive),
                    this.on("ready", () => {
                        this.audioPosterMode(this.options_.audioPosterMode),
                            this.audioOnlyMode(this.options_.audioOnlyMode)
                    }
                    )
            }
            dispose() {
                this.trigger("dispose"),
                    this.off("dispose"),
                    kt(le.default, this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_),
                    kt(le.default, "keydown", this.boundFullWindowOnEscKey_),
                    this.styleEl_ && this.styleEl_.parentNode && (this.styleEl_.parentNode.removeChild(this.styleEl_),
                        this.styleEl_ = null),
                    pa.players[this.id_] = null,
                    this.tag && this.tag.player && (this.tag.player = null),
                    this.el_ && this.el_.player && (this.el_.player = null),
                    this.tech_ && (this.tech_.dispose(),
                        this.isPosterFromTech_ = !1,
                        this.poster_ = ""),
                    this.playerElIngest_ && (this.playerElIngest_ = null),
                    this.tag && (this.tag = null),
                    uT(this),
                    $t.names.forEach(e => {
                        const s = $t[e]
                            , r = this[s.getterName]();
                        r && r.off && r.off()
                    }
                    ),
                    super.dispose({
                        restoreEl: this.options_.restoreEl
                    })
            }
            createEl() {
                let e = this.tag, s, r = this.playerElIngest_ = e.parentNode && e.parentNode.hasAttribute && e.parentNode.hasAttribute("data-vjs-player");
                const n = this.tag.tagName.toLowerCase() === "video-js";
                r ? s = this.el_ = e.parentNode : n || (s = this.el_ = super.createEl("div"));
                const a = Gs(e);
                if (n) {
                    for (s = this.el_ = e,
                        e = this.tag = le.default.createElement("video"); s.children.length;)
                        e.appendChild(s.firstChild);
                    ba(s, "video-js") || vr(s, "video-js"),
                        s.appendChild(e),
                        r = this.playerElIngest_ = s,
                        Object.keys(s).forEach(u => {
                            try {
                                e[u] = s[u]
                            } catch (c) { }
                        }
                        )
                }
                if (e.setAttribute("tabindex", "-1"),
                    a.tabindex = "-1",
                    Ji && Jo && (e.setAttribute("role", "application"),
                        a.role = "application"),
                    e.removeAttribute("width"),
                    e.removeAttribute("height"),
                    "width" in a && delete a.width,
                    "height" in a && delete a.height,
                    Object.getOwnPropertyNames(a).forEach(function (u) {
                        n && u === "class" || s.setAttribute(u, a[u]),
                            n && e.setAttribute(u, a[u])
                    }),
                    e.playerId = e.id,
                    e.id += "_html5_api",
                    e.className = "vjs-tech",
                    e.player = s.player = this,
                    this.addClass("vjs-paused"),
                    O.default.VIDEOJS_NO_DYNAMIC_STYLE !== !0) {
                    this.styleEl_ = Pf("vjs-styles-dimensions");
                    const u = Ws(".vjs-styles-defaults")
                        , c = Ws("head");
                    c.insertBefore(this.styleEl_, u ? u.nextSibling : c.firstChild)
                }
                this.fill_ = !1,
                    this.fluid_ = !1,
                    this.width(this.options_.width),
                    this.height(this.options_.height),
                    this.fill(this.options_.fill),
                    this.fluid(this.options_.fluid),
                    this.aspectRatio(this.options_.aspectRatio),
                    this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
                const o = e.getElementsByTagName("a");
                for (let u = 0; u < o.length; u++) {
                    const c = o.item(u);
                    vr(c, "vjs-hidden"),
                        c.setAttribute("hidden", "hidden")
                }
                return e.initNetworkState_ = e.networkState,
                    e.parentNode && !r && e.parentNode.insertBefore(s, e),
                    Ah(e, s),
                    this.children_.unshift(e),
                    this.el_.setAttribute("lang", this.language_),
                    this.el_.setAttribute("translate", "no"),
                    this.el_ = s,
                    s
            }
            crossOrigin(e) {
                if (typeof e > "u")
                    return this.techGet_("crossOrigin");
                if (e !== null && e !== "anonymous" && e !== "use-credentials") {
                    Ie.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${e}"`);
                    return
                }
                this.techCall_("setCrossOrigin", e),
                    this.posterImage && this.posterImage.crossOrigin(e)
            }
            width(e) {
                return this.dimension("width", e)
            }
            height(e) {
                return this.dimension("height", e)
            }
            dimension(e, s) {
                const r = e + "_";
                if (s === void 0)
                    return this[r] || 0;
                if (s === "" || s === "auto") {
                    this[r] = void 0,
                        this.updateStyleEl_();
                    return
                }
                const n = parseFloat(s);
                if (isNaN(n)) {
                    Ie.error(`Improper value "${s}" supplied for for ${e}`);
                    return
                }
                this[r] = n,
                    this.updateStyleEl_()
            }
            fluid(e) {
                if (e === void 0)
                    return !!this.fluid_;
                this.fluid_ = !!e,
                    Ts(this) && this.off(["playerreset", "resize"], this.boundUpdateStyleEl_),
                    e ? (this.addClass("vjs-fluid"),
                        this.fill(!1),
                        U0(this, () => {
                            this.on(["playerreset", "resize"], this.boundUpdateStyleEl_)
                        }
                        )) : this.removeClass("vjs-fluid"),
                    this.updateStyleEl_()
            }
            fill(e) {
                if (e === void 0)
                    return !!this.fill_;
                this.fill_ = !!e,
                    e ? (this.addClass("vjs-fill"),
                        this.fluid(!1)) : this.removeClass("vjs-fill")
            }
            aspectRatio(e) {
                if (e === void 0)
                    return this.aspectRatio_;
                if (!/^\d+\:\d+$/.test(e))
                    throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
                this.aspectRatio_ = e,
                    this.fluid(!0),
                    this.updateStyleEl_()
            }
            updateStyleEl_() {
                if (O.default.VIDEOJS_NO_DYNAMIC_STYLE === !0) {
                    const u = typeof this.width_ == "number" ? this.width_ : this.options_.width
                        , c = typeof this.height_ == "number" ? this.height_ : this.options_.height
                        , f = this.tech_ && this.tech_.el();
                    f && (u >= 0 && (f.width = u),
                        c >= 0 && (f.height = c));
                    return
                }
                let e, s, r, n;
                this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto" ? r = this.aspectRatio_ : this.videoWidth() > 0 ? r = this.videoWidth() + ":" + this.videoHeight() : r = "16:9";
                const a = r.split(":")
                    , o = a[1] / a[0];
                this.width_ !== void 0 ? e = this.width_ : this.height_ !== void 0 ? e = this.height_ / o : e = this.videoWidth() || 300,
                    this.height_ !== void 0 ? s = this.height_ : s = e * o,
                    /^[^a-zA-Z]/.test(this.id()) ? n = "dimensions-" + this.id() : n = this.id() + "-dimensions",
                    this.addClass(n),
                    Lf(this.styleEl_, `
      .${n} {
        width: ${e}px;
        height: ${s}px;
      }

      .${n}.vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: ${o * 100}%;
      }
    `)
            }
            loadTech_(e, s) {
                this.tech_ && this.unloadTech_();
                const r = tt(e)
                    , n = e.charAt(0).toLowerCase() + e.slice(1);
                r !== "Html5" && this.tag && (He.getTech("Html5").disposeMediaElement(this.tag),
                    this.tag.player = null,
                    this.tag = null),
                    this.techName_ = r,
                    this.isReady_ = !1;
                let a = this.autoplay();
                (typeof this.autoplay() == "string" || this.autoplay() === !0 && this.options_.normalizeAutoplay) && (a = !1);
                const o = {
                    source: s,
                    autoplay: a,
                    nativeControlsForTouch: this.options_.nativeControlsForTouch,
                    playerId: this.id(),
                    techId: `${this.id()}_${n}_api`,
                    playsinline: this.options_.playsinline,
                    preload: this.options_.preload,
                    loop: this.options_.loop,
                    disablePictureInPicture: this.options_.disablePictureInPicture,
                    muted: this.options_.muted,
                    poster: this.poster(),
                    language: this.language(),
                    playerElIngest: this.playerElIngest_ || !1,
                    "vtt.js": this.options_["vtt.js"],
                    canOverridePoster: !!this.options_.techCanOverridePoster,
                    enableSourceset: this.options_.enableSourceset
                };
                $t.names.forEach(c => {
                    const f = $t[c];
                    o[f.getterName] = this[f.privateName]
                }
                ),
                    Object.assign(o, this.options_[r]),
                    Object.assign(o, this.options_[n]),
                    Object.assign(o, this.options_[e.toLowerCase()]),
                    this.tag && (o.tag = this.tag),
                    s && s.src === this.cache_.src && this.cache_.currentTime > 0 && (o.startTime = this.cache_.currentTime);
                const u = He.getTech(e);
                if (!u)
                    throw new Error(`No Tech named '${r}' exists! '${r}' should be registered using videojs.registerTech()'`);
                this.tech_ = new u(o),
                    this.tech_.ready(Ge(this, this.handleTechReady_), !0),
                    Vf.jsonToTextTracks(this.textTracksJson_ || [], this.tech_),
                    jp.forEach(c => {
                        this.on(this.tech_, c, f => this[`handleTech${tt(c)}_`](f))
                    }
                    ),
                    Object.keys(pd).forEach(c => {
                        this.on(this.tech_, c, f => {
                            if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {
                                this.queuedCallbacks_.push({
                                    callback: this[`handleTech${pd[c]}_`].bind(this),
                                    event: f
                                });
                                return
                            }
                            this[`handleTech${pd[c]}_`](f)
                        }
                        )
                    }
                    ),
                    this.on(this.tech_, "loadstart", c => this.handleTechLoadStart_(c)),
                    this.on(this.tech_, "sourceset", c => this.handleTechSourceset_(c)),
                    this.on(this.tech_, "waiting", c => this.handleTechWaiting_(c)),
                    this.on(this.tech_, "ended", c => this.handleTechEnded_(c)),
                    this.on(this.tech_, "seeking", c => this.handleTechSeeking_(c)),
                    this.on(this.tech_, "play", c => this.handleTechPlay_(c)),
                    this.on(this.tech_, "pause", c => this.handleTechPause_(c)),
                    this.on(this.tech_, "durationchange", c => this.handleTechDurationChange_(c)),
                    this.on(this.tech_, "fullscreenchange", (c, f) => this.handleTechFullscreenChange_(c, f)),
                    this.on(this.tech_, "fullscreenerror", (c, f) => this.handleTechFullscreenError_(c, f)),
                    this.on(this.tech_, "enterpictureinpicture", c => this.handleTechEnterPictureInPicture_(c)),
                    this.on(this.tech_, "leavepictureinpicture", c => this.handleTechLeavePictureInPicture_(c)),
                    this.on(this.tech_, "error", c => this.handleTechError_(c)),
                    this.on(this.tech_, "posterchange", c => this.handleTechPosterChange_(c)),
                    this.on(this.tech_, "textdata", c => this.handleTechTextData_(c)),
                    this.on(this.tech_, "ratechange", c => this.handleTechRateChange_(c)),
                    this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_),
                    this.usingNativeControls(this.techGet_("controls")),
                    this.controls() && !this.usingNativeControls() && this.addTechControlsListeners_(),
                    this.tech_.el().parentNode !== this.el() && (r !== "Html5" || !this.tag) && Ah(this.tech_.el(), this.el()),
                    this.tag && (this.tag.player = null,
                        this.tag = null)
            }
            unloadTech_() {
                $t.names.forEach(e => {
                    const s = $t[e];
                    this[s.privateName] = this[s.getterName]()
                }
                ),
                    this.textTracksJson_ = Vf.textTracksToJson(this.tech_),
                    this.isReady_ = !1,
                    this.tech_.dispose(),
                    this.tech_ = !1,
                    this.isPosterFromTech_ && (this.poster_ = "",
                        this.trigger("posterchange")),
                    this.isPosterFromTech_ = !1
            }
            tech(e) {
                return e === void 0 && Ie.warn(`Using the tech directly can be dangerous. I hope you know what you're doing.
See https://github.com/videojs/video.js/issues/2617 for more info.
`),
                    this.tech_
            }
            addTechControlsListeners_() {
                this.removeTechControlsListeners_(),
                    this.on(this.tech_, "click", this.boundHandleTechClick_),
                    this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_),
                    this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_),
                    this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_),
                    this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_),
                    this.on(this.tech_, "tap", this.boundHandleTechTap_)
            }
            removeTechControlsListeners_() {
                this.off(this.tech_, "tap", this.boundHandleTechTap_),
                    this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_),
                    this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_),
                    this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_),
                    this.off(this.tech_, "click", this.boundHandleTechClick_),
                    this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_)
            }
            handleTechReady_() {
                this.triggerReady(),
                    this.cache_.volume && this.techCall_("setVolume", this.cache_.volume),
                    this.handleTechPosterChange_(),
                    this.handleTechDurationChange_()
            }
            handleTechLoadStart_() {
                this.removeClass("vjs-ended", "vjs-seeking"),
                    this.error(null),
                    this.handleTechDurationChange_(),
                    this.paused() ? (this.hasStarted(!1),
                        this.trigger("loadstart")) : this.trigger("loadstart"),
                    this.manualAutoplay_(this.autoplay() === !0 && this.options_.normalizeAutoplay ? "play" : this.autoplay())
            }
            manualAutoplay_(e) {
                if (!this.tech_ || typeof e != "string")
                    return;
                const s = () => {
                    const n = this.muted();
                    this.muted(!0);
                    const a = () => {
                        this.muted(n)
                    }
                        ;
                    this.playTerminatedQueue_.push(a);
                    const o = this.play();
                    if (wa(o))
                        return o.catch(u => {
                            throw a(),
                            new Error(`Rejection at manualAutoplay. Restoring muted value. ${u || ""}`)
                        }
                        )
                }
                    ;
                let r;
                if (e === "any" && !this.muted() ? (r = this.play(),
                    wa(r) && (r = r.catch(s))) : e === "muted" && !this.muted() ? r = s() : r = this.play(),
                    !!wa(r))
                    return r.then(() => {
                        this.trigger({
                            type: "autoplay-success",
                            autoplay: e
                        })
                    }
                    ).catch(() => {
                        this.trigger({
                            type: "autoplay-failure",
                            autoplay: e
                        })
                    }
                    )
            }
            updateSourceCaches_(e = "") {
                let s = e
                    , r = "";
                typeof s != "string" && (s = e.src,
                    r = e.type),
                    this.cache_.source = this.cache_.source || {},
                    this.cache_.sources = this.cache_.sources || [],
                    s && !r && (r = cT(this, s)),
                    this.cache_.source = ze({}, e, {
                        src: s,
                        type: r
                    });
                const n = this.cache_.sources.filter(c => c.src && c.src === s)
                    , a = []
                    , o = this.$$("source")
                    , u = [];
                for (let c = 0; c < o.length; c++) {
                    const f = Gs(o[c]);
                    a.push(f),
                        f.src && f.src === s && u.push(f.src)
                }
                u.length && !n.length ? this.cache_.sources = a : n.length || (this.cache_.sources = [this.cache_.source]),
                    this.cache_.src = s
            }
            handleTechSourceset_(e) {
                if (!this.changingSrc_) {
                    let s = a => this.updateSourceCaches_(a);
                    const r = this.currentSource().src
                        , n = e.src;
                    r && !/^blob:/.test(r) && /^blob:/.test(n) && (!this.lastSource_ || this.lastSource_.tech !== n && this.lastSource_.player !== r) && (s = () => { }
                    ),
                        s(n),
                        e.src || this.tech_.any(["sourceset", "loadstart"], a => {
                            if (a.type === "sourceset")
                                return;
                            const o = this.techGet_("currentSrc");
                            this.lastSource_.tech = o,
                                this.updateSourceCaches_(o)
                        }
                        )
                }
                this.lastSource_ = {
                    player: this.currentSource().src,
                    tech: e.src
                },
                    this.trigger({
                        src: e.src,
                        type: "sourceset"
                    })
            }
            hasStarted(e) {
                if (e === void 0)
                    return this.hasStarted_;
                e !== this.hasStarted_ && (this.hasStarted_ = e,
                    this.hasStarted_ ? this.addClass("vjs-has-started") : this.removeClass("vjs-has-started"))
            }
            handleTechPlay_() {
                this.removeClass("vjs-ended", "vjs-paused"),
                    this.addClass("vjs-playing"),
                    this.hasStarted(!0),
                    this.trigger("play")
            }
            handleTechRateChange_() {
                this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0 && (this.queuedCallbacks_.forEach(e => e.callback(e.event)),
                    this.queuedCallbacks_ = []),
                    this.cache_.lastPlaybackRate = this.tech_.playbackRate(),
                    this.trigger("ratechange")
            }
            handleTechWaiting_() {
                this.addClass("vjs-waiting"),
                    this.trigger("waiting");
                const e = this.currentTime()
                    , s = () => {
                        e !== this.currentTime() && (this.removeClass("vjs-waiting"),
                            this.off("timeupdate", s))
                    }
                    ;
                this.on("timeupdate", s)
            }
            handleTechCanPlay_() {
                this.removeClass("vjs-waiting"),
                    this.trigger("canplay")
            }
            handleTechCanPlayThrough_() {
                this.removeClass("vjs-waiting"),
                    this.trigger("canplaythrough")
            }
            handleTechPlaying_() {
                this.removeClass("vjs-waiting"),
                    this.trigger("playing")
            }
            handleTechSeeking_() {
                this.addClass("vjs-seeking"),
                    this.trigger("seeking")
            }
            handleTechSeeked_() {
                this.removeClass("vjs-seeking", "vjs-ended"),
                    this.trigger("seeked")
            }
            handleTechPause_() {
                this.removeClass("vjs-playing"),
                    this.addClass("vjs-paused"),
                    this.trigger("pause")
            }
            handleTechEnded_() {
                this.addClass("vjs-ended"),
                    this.removeClass("vjs-waiting"),
                    this.options_.loop ? (this.currentTime(0),
                        this.play()) : this.paused() || this.pause(),
                    this.trigger("ended")
            }
            handleTechDurationChange_() {
                this.duration(this.techGet_("duration"))
            }
            handleTechClick_(e) {
                this.controls_ && (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click == "function" ? this.options_.userActions.click.call(this, e) : this.paused() ? ts(this.play()) : this.pause())
            }
            handleTechDoubleClick_(e) {
                if (!this.controls_)
                    return;
                Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), r => r.contains(e.target)) || (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== !1) && (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick == "function" ? this.options_.userActions.doubleClick.call(this, e) : this.isFullscreen() ? this.exitFullscreen() : this.requestFullscreen())
            }
            handleTechTap_() {
                this.userActive(!this.userActive())
            }
            handleTechTouchStart_() {
                this.userWasActive = this.userActive()
            }
            handleTechTouchMove_() {
                this.userWasActive && this.reportUserActivity()
            }
            handleTechTouchEnd_(e) {
                e.cancelable && e.preventDefault()
            }
            toggleFullscreenClass_() {
                this.isFullscreen() ? this.addClass("vjs-fullscreen") : this.removeClass("vjs-fullscreen")
            }
            documentFullscreenChange_(e) {
                const s = e.target.player;
                if (s && s !== this)
                    return;
                const r = this.el();
                let n = le.default[this.fsApi_.fullscreenElement] === r;
                !n && r.matches && (n = r.matches(":" + this.fsApi_.fullscreen)),
                    this.isFullscreen(n)
            }
            handleTechFullscreenChange_(e, s) {
                s && (s.nativeIOSFullscreen && (this.addClass("vjs-ios-native-fs"),
                    this.tech_.one("webkitendfullscreen", () => {
                        this.removeClass("vjs-ios-native-fs")
                    }
                    )),
                    this.isFullscreen(s.isFullscreen))
            }
            handleTechFullscreenError_(e, s) {
                this.trigger("fullscreenerror", s)
            }
            togglePictureInPictureClass_() {
                this.isInPictureInPicture() ? this.addClass("vjs-picture-in-picture") : this.removeClass("vjs-picture-in-picture")
            }
            handleTechEnterPictureInPicture_(e) {
                this.isInPictureInPicture(!0)
            }
            handleTechLeavePictureInPicture_(e) {
                this.isInPictureInPicture(!1)
            }
            handleTechError_() {
                const e = this.tech_.error();
                e && this.error(e)
            }
            handleTechTextData_() {
                let e = null;
                arguments.length > 1 && (e = arguments[1]),
                    this.trigger("textdata", e)
            }
            getCache() {
                return this.cache_
            }
            resetCache_() {
                this.cache_ = {
                    currentTime: 0,
                    initTime: 0,
                    inactivityTimeout: this.options_.inactivityTimeout,
                    duration: NaN,
                    lastVolume: 1,
                    lastPlaybackRate: this.defaultPlaybackRate(),
                    media: null,
                    src: "",
                    source: {},
                    sources: [],
                    playbackRates: [],
                    volume: 1
                }
            }
            techCall_(e, s) {
                this.ready(function () {
                    if (e in oT)
                        return nT(this.middleware_, this.tech_, e, s);
                    if (e in ep)
                        return Zf(this.middleware_, this.tech_, e, s);
                    try {
                        this.tech_ && this.tech_[e](s)
                    } catch (r) {
                        throw Ie(r),
                        r
                    }
                }, !0)
            }
            techGet_(e) {
                if (!(!this.tech_ || !this.tech_.isReady_)) {
                    if (e in aT)
                        return rT(this.middleware_, this.tech_, e);
                    if (e in ep)
                        return Zf(this.middleware_, this.tech_, e);
                    try {
                        return this.tech_[e]()
                    } catch (s) {
                        throw this.tech_[e] === void 0 ? (Ie(`Video.js: ${e} method not defined for ${this.techName_} playback technology.`, s),
                            s) : s.name === "TypeError" ? (Ie(`Video.js: ${e} unavailable on ${this.techName_} playback technology element.`, s),
                                this.tech_.isReady_ = !1,
                                s) : (Ie(s),
                                    s)
                    }
                }
            }
            play() {
                return new Promise(e => {
                    this.play_(e)
                }
                )
            }
            play_(e = ts) {
                this.playCallbacks_.push(e);
                const s = !!(!this.changingSrc_ && (this.src() || this.currentSrc()))
                    , r = !!(tl || jt);
                if (this.waitToPlay_ && (this.off(["ready", "loadstart"], this.waitToPlay_),
                    this.waitToPlay_ = null),
                    !this.isReady_ || !s) {
                    this.waitToPlay_ = o => {
                        this.play_()
                    }
                        ,
                        this.one(["ready", "loadstart"], this.waitToPlay_),
                        !s && r && this.load();
                    return
                }
                const n = this.techGet_("play");
                r && this.hasClass("vjs-ended") && this.resetProgressBar_(),
                    n === null ? this.runPlayTerminatedQueue_() : this.runPlayCallbacks_(n)
            }
            runPlayTerminatedQueue_() {
                const e = this.playTerminatedQueue_.slice(0);
                this.playTerminatedQueue_ = [],
                    e.forEach(function (s) {
                        s()
                    })
            }
            runPlayCallbacks_(e) {
                const s = this.playCallbacks_.slice(0);
                this.playCallbacks_ = [],
                    this.playTerminatedQueue_ = [],
                    s.forEach(function (r) {
                        r(e)
                    })
            }
            pause() {
                this.techCall_("pause")
            }
            paused() {
                return this.techGet_("paused") !== !1
            }
            played() {
                return this.techGet_("played") || Li(0, 0)
            }
            scrubbing(e) {
                if (typeof e > "u")
                    return this.scrubbing_;
                this.scrubbing_ = !!e,
                    this.techCall_("setScrubbing", this.scrubbing_),
                    e ? this.addClass("vjs-scrubbing") : this.removeClass("vjs-scrubbing")
            }
            currentTime(e) {
                if (e === void 0)
                    return this.cache_.currentTime = this.techGet_("currentTime") || 0,
                        this.cache_.currentTime;
                if (e < 0 && (e = 0),
                    !this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
                    this.cache_.initTime = e,
                        this.off("canplay", this.boundApplyInitTime_),
                        this.one("canplay", this.boundApplyInitTime_);
                    return
                }
                this.techCall_("setCurrentTime", e),
                    this.cache_.initTime = 0,
                    isFinite(e) && (this.cache_.currentTime = Number(e))
            }
            applyInitTime_() {
                this.currentTime(this.cache_.initTime)
            }
            duration(e) {
                if (e === void 0)
                    return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
                e = parseFloat(e),
                    e < 0 && (e = 1 / 0),
                    e !== this.cache_.duration && (this.cache_.duration = e,
                        e === 1 / 0 ? this.addClass("vjs-live") : this.removeClass("vjs-live"),
                        isNaN(e) || this.trigger("durationchange"))
            }
            remainingTime() {
                return this.duration() - this.currentTime()
            }
            remainingTimeDisplay() {
                return Math.floor(this.duration()) - Math.floor(this.currentTime())
            }
            buffered() {
                let e = this.techGet_("buffered");
                return (!e || !e.length) && (e = Li(0, 0)),
                    e
            }
            seekable() {
                let e = this.techGet_("seekable");
                return (!e || !e.length) && (e = Li(0, 0)),
                    e
            }
            seeking() {
                return this.techGet_("seeking")
            }
            ended() {
                return this.techGet_("ended")
            }
            networkState() {
                return this.techGet_("networkState")
            }
            readyState() {
                return this.techGet_("readyState")
            }
            bufferedPercent() {
                return $f(this.buffered(), this.duration())
            }
            bufferedEnd() {
                const e = this.buffered()
                    , s = this.duration();
                let r = e.end(e.length - 1);
                return r > s && (r = s),
                    r
            }
            volume(e) {
                let s;
                if (e !== void 0) {
                    s = Math.max(0, Math.min(1, e)),
                        this.cache_.volume = s,
                        this.techCall_("setVolume", s),
                        s > 0 && this.lastVolume_(s);
                    return
                }
                return s = parseFloat(this.techGet_("volume")),
                    isNaN(s) ? 1 : s
            }
            muted(e) {
                if (e !== void 0) {
                    this.techCall_("setMuted", e);
                    return
                }
                return this.techGet_("muted") || !1
            }
            defaultMuted(e) {
                return e !== void 0 && this.techCall_("setDefaultMuted", e),
                    this.techGet_("defaultMuted") || !1
            }
            lastVolume_(e) {
                if (e !== void 0 && e !== 0) {
                    this.cache_.lastVolume = e;
                    return
                }
                return this.cache_.lastVolume
            }
            supportsFullScreen() {
                return this.techGet_("supportsFullScreen") || !1
            }
            isFullscreen(e) {
                if (e !== void 0) {
                    const s = this.isFullscreen_;
                    this.isFullscreen_ = !!e,
                        this.isFullscreen_ !== s && this.fsApi_.prefixed && this.trigger("fullscreenchange"),
                        this.toggleFullscreenClass_();
                    return
                }
                return this.isFullscreen_
            }
            requestFullscreen(e) {
                this.isInPictureInPicture() && this.exitPictureInPicture();
                const s = this;
                return new Promise((r, n) => {
                    function a() {
                        s.off("fullscreenerror", u),
                            s.off("fullscreenchange", o)
                    }
                    function o() {
                        a(),
                            r()
                    }
                    function u(f, v) {
                        a(),
                            n(v)
                    }
                    s.one("fullscreenchange", o),
                        s.one("fullscreenerror", u);
                    const c = s.requestFullscreenHelper_(e);
                    c && (c.then(a, a),
                        c.then(r, n))
                }
                )
            }
            requestFullscreenHelper_(e) {
                let s;
                if (this.fsApi_.prefixed || (s = this.options_.fullscreen && this.options_.fullscreen.options || {},
                    e !== void 0 && (s = e)),
                    this.fsApi_.requestFullscreen) {
                    const r = this.el_[this.fsApi_.requestFullscreen](s);
                    return r && r.then(() => this.isFullscreen(!0), () => this.isFullscreen(!1)),
                        r
                } else
                    this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("enterFullScreen") : this.enterFullWindow()
            }
            exitFullscreen() {
                const e = this;
                return new Promise((s, r) => {
                    function n() {
                        e.off("fullscreenerror", o),
                            e.off("fullscreenchange", a)
                    }
                    function a() {
                        n(),
                            s()
                    }
                    function o(c, f) {
                        n(),
                            r(f)
                    }
                    e.one("fullscreenchange", a),
                        e.one("fullscreenerror", o);
                    const u = e.exitFullscreenHelper_();
                    u && (u.then(n, n),
                        u.then(s, r))
                }
                )
            }
            exitFullscreenHelper_() {
                if (this.fsApi_.requestFullscreen) {
                    const e = le.default[this.fsApi_.exitFullscreen]();
                    return e && ts(e.then(() => this.isFullscreen(!1))),
                        e
                } else
                    this.tech_.supportsFullScreen() && !this.options_.preferFullWindow ? this.techCall_("exitFullScreen") : this.exitFullWindow()
            }
            enterFullWindow() {
                this.isFullscreen(!0),
                    this.isFullWindow = !0,
                    this.docOrigOverflow = le.default.documentElement.style.overflow,
                    ui(le.default, "keydown", this.boundFullWindowOnEscKey_),
                    le.default.documentElement.style.overflow = "hidden",
                    vr(le.default.body, "vjs-full-window"),
                    this.trigger("enterFullWindow")
            }
            fullWindowOnEscKey(e) {
                we.default.isEventKey(e, "Esc") && this.isFullscreen() === !0 && (this.isFullWindow ? this.exitFullWindow() : this.exitFullscreen())
            }
            exitFullWindow() {
                this.isFullscreen(!1),
                    this.isFullWindow = !1,
                    kt(le.default, "keydown", this.boundFullWindowOnEscKey_),
                    le.default.documentElement.style.overflow = this.docOrigOverflow,
                    il(le.default.body, "vjs-full-window"),
                    this.trigger("exitFullWindow")
            }
            disablePictureInPicture(e) {
                if (e === void 0)
                    return this.techGet_("disablePictureInPicture");
                this.techCall_("setDisablePictureInPicture", e),
                    this.options_.disablePictureInPicture = e,
                    this.trigger("disablepictureinpicturechanged")
            }
            isInPictureInPicture(e) {
                if (e !== void 0) {
                    this.isInPictureInPicture_ = !!e,
                        this.togglePictureInPictureClass_();
                    return
                }
                return !!this.isInPictureInPicture_
            }
            requestPictureInPicture() {
                if (this.options_.enableDocumentPictureInPicture && O.default.documentPictureInPicture) {
                    const e = le.default.createElement(this.el().tagName);
                    return e.classList = this.el().classList,
                        e.classList.add("vjs-pip-container"),
                        this.posterImage && e.appendChild(this.posterImage.el().cloneNode(!0)),
                        this.titleBar && e.appendChild(this.titleBar.el().cloneNode(!0)),
                        e.appendChild(De("p", {
                            className: "vjs-pip-text"
                        }, {}, this.localize("Playing in picture-in-picture"))),
                        O.default.documentPictureInPicture.requestWindow({
                            width: this.videoWidth(),
                            height: this.videoHeight()
                        }).then(s => (kf(s),
                            this.el_.parentNode.insertBefore(e, this.el_),
                            s.document.body.appendChild(this.el_),
                            s.document.body.classList.add("vjs-pip-window"),
                            this.player_.isInPictureInPicture(!0),
                            this.player_.trigger("enterpictureinpicture"),
                            s.addEventListener("pagehide", r => {
                                const n = r.target.querySelector(".video-js");
                                e.parentNode.replaceChild(n, e),
                                    this.player_.isInPictureInPicture(!1),
                                    this.player_.trigger("leavepictureinpicture")
                            }
                            ),
                            s))
                }
                return "pictureInPictureEnabled" in le.default && this.disablePictureInPicture() === !1 ? this.techGet_("requestPictureInPicture") : Promise.reject("No PiP mode is available")
            }
            exitPictureInPicture() {
                if (O.default.documentPictureInPicture && O.default.documentPictureInPicture.window)
                    return O.default.documentPictureInPicture.window.close(),
                        Promise.resolve();
                if ("pictureInPictureEnabled" in le.default)
                    return le.default.exitPictureInPicture()
            }
            handleKeyDown(e) {
                const { userActions: s } = this.options_;
                !s || !s.hotkeys || (n => {
                    const a = n.tagName.toLowerCase();
                    if (n.isContentEditable)
                        return !0;
                    const o = ["button", "checkbox", "hidden", "radio", "reset", "submit"];
                    return a === "input" ? o.indexOf(n.type) === -1 : ["textarea"].indexOf(a) !== -1
                }
                )(this.el_.ownerDocument.activeElement) || (typeof s.hotkeys == "function" ? s.hotkeys.call(this, e) : this.handleHotkeys(e))
            }
            handleHotkeys(e) {
                const s = this.options_.userActions ? this.options_.userActions.hotkeys : {}
                    , { fullscreenKey: r = o => we.default.isEventKey(o, "f"), muteKey: n = o => we.default.isEventKey(o, "m"), playPauseKey: a = o => we.default.isEventKey(o, "k") || we.default.isEventKey(o, "Space") } = s;
                if (r.call(this, e)) {
                    e.preventDefault(),
                        e.stopPropagation();
                    const o = J.getComponent("FullscreenToggle");
                    le.default[this.fsApi_.fullscreenEnabled] !== !1 && o.prototype.handleClick.call(this, e)
                } else
                    n.call(this, e) ? (e.preventDefault(),
                        e.stopPropagation(),
                        J.getComponent("MuteToggle").prototype.handleClick.call(this, e)) : a.call(this, e) && (e.preventDefault(),
                            e.stopPropagation(),
                            J.getComponent("PlayToggle").prototype.handleClick.call(this, e))
            }
            canPlayType(e) {
                let s;
                for (let r = 0, n = this.options_.techOrder; r < n.length; r++) {
                    const a = n[r];
                    let o = He.getTech(a);
                    if (o || (o = J.getComponent(a)),
                        !o) {
                        Ie.error(`The "${a}" tech is undefined. Skipped browser support check for that tech.`);
                        continue
                    }
                    if (o.isSupported() && (s = o.canPlayType(e),
                        s))
                        return s
                }
                return ""
            }
            selectSource(e) {
                const s = this.options_.techOrder.map(u => [u, He.getTech(u)]).filter(([u, c]) => c ? c.isSupported() : (Ie.error(`The "${u}" tech is undefined. Skipped browser support check for that tech.`),
                    !1))
                    , r = function (u, c, f) {
                        let v;
                        return u.some(T => c.some(D => {
                            if (v = f(T, D),
                                v)
                                return !0
                        }
                        )),
                            v
                    };
                let n;
                const a = u => (c, f) => u(f, c)
                    , o = ([u, c], f) => {
                        if (c.canPlaySource(f, this.options_[u.toLowerCase()]))
                            return {
                                source: f,
                                tech: u
                            }
                    }
                    ;
                return this.options_.sourceOrder ? n = r(e, s, a(o)) : n = r(s, e, o),
                    n || !1
            }
            handleSrc_(e, s) {
                if (typeof e > "u")
                    return this.cache_.src || "";
                this.resetRetryOnError_ && this.resetRetryOnError_();
                const r = tp(e);
                if (!r.length) {
                    this.setTimeout(function () {
                        this.error({
                            code: 4,
                            message: this.options_.notSupportedMessage
                        })
                    }, 0);
                    return
                }
                if (this.changingSrc_ = !0,
                    s || (this.cache_.sources = r),
                    this.updateSourceCaches_(r[0]),
                    iT(this, r[0], (n, a) => {
                        if (this.middleware_ = a,
                            s || (this.cache_.sources = r),
                            this.updateSourceCaches_(n),
                            this.src_(n)) {
                            if (r.length > 1)
                                return this.handleSrc_(r.slice(1));
                            this.changingSrc_ = !1,
                                this.setTimeout(function () {
                                    this.error({
                                        code: 4,
                                        message: this.options_.notSupportedMessage
                                    })
                                }, 0),
                                this.triggerReady();
                            return
                        }
                        sT(a, this.tech_)
                    }
                    ),
                    r.length > 1) {
                    const n = () => {
                        this.error(null),
                            this.handleSrc_(r.slice(1), !0)
                    }
                        , a = () => {
                            this.off("error", n)
                        }
                        ;
                    this.one("error", n),
                        this.one("playing", a),
                        this.resetRetryOnError_ = () => {
                            this.off("error", n),
                                this.off("playing", a)
                        }
                }
            }
            src(e) {
                return this.handleSrc_(e, !1)
            }
            src_(e) {
                const s = this.selectSource([e]);
                return s ? Ff(s.tech, this.techName_) ? (this.ready(function () {
                    this.tech_.constructor.prototype.hasOwnProperty("setSource") ? this.techCall_("setSource", e) : this.techCall_("src", e.src),
                        this.changingSrc_ = !1
                }, !0),
                    !1) : (this.changingSrc_ = !0,
                        this.loadTech_(s.tech, s.source),
                        this.tech_.ready(() => {
                            this.changingSrc_ = !1
                        }
                        ),
                        !1) : !0
            }
            load() {
                if (this.tech_ && this.tech_.vhs) {
                    this.src(this.currentSource());
                    return
                }
                this.techCall_("load")
            }
            reset() {
                if (this.paused())
                    this.doReset_();
                else {
                    const e = this.play();
                    ts(e.then(() => this.doReset_()))
                }
            }
            doReset_() {
                this.tech_ && this.tech_.clearTracks("text"),
                    this.removeClass("vjs-playing"),
                    this.addClass("vjs-paused"),
                    this.resetCache_(),
                    this.poster(""),
                    this.loadTech_(this.options_.techOrder[0], null),
                    this.techCall_("reset"),
                    this.resetControlBarUI_(),
                    this.error(null),
                    this.titleBar && this.titleBar.update({
                        title: void 0,
                        description: void 0
                    }),
                    Ts(this) && this.trigger("playerreset")
            }
            resetControlBarUI_() {
                this.resetProgressBar_(),
                    this.resetPlaybackRate_(),
                    this.resetVolumeBar_()
            }
            resetProgressBar_() {
                this.currentTime(0);
                const { currentTimeDisplay: e, durationDisplay: s, progressControl: r, remainingTimeDisplay: n } = this.controlBar || {}
                    , { seekBar: a } = r || {};
                e && e.updateContent(),
                    s && s.updateContent(),
                    n && n.updateContent(),
                    a && (a.update(),
                        a.loadProgressBar && a.loadProgressBar.update())
            }
            resetPlaybackRate_() {
                this.playbackRate(this.defaultPlaybackRate()),
                    this.handleTechRateChange_()
            }
            resetVolumeBar_() {
                this.volume(1),
                    this.trigger("volumechange")
            }
            currentSources() {
                const e = this.currentSource()
                    , s = [];
                return Object.keys(e).length !== 0 && s.push(e),
                    this.cache_.sources || s
            }
            currentSource() {
                return this.cache_.source || {}
            }
            currentSrc() {
                return this.currentSource() && this.currentSource().src || ""
            }
            currentType() {
                return this.currentSource() && this.currentSource().type || ""
            }
            preload(e) {
                if (e !== void 0) {
                    this.techCall_("setPreload", e),
                        this.options_.preload = e;
                    return
                }
                return this.techGet_("preload")
            }
            autoplay(e) {
                if (e === void 0)
                    return this.options_.autoplay || !1;
                let s;
                typeof e == "string" && /(any|play|muted)/.test(e) || e === !0 && this.options_.normalizeAutoplay ? (this.options_.autoplay = e,
                    this.manualAutoplay_(typeof e == "string" ? e : "play"),
                    s = !1) : e ? this.options_.autoplay = !0 : this.options_.autoplay = !1,
                    s = typeof s > "u" ? this.options_.autoplay : s,
                    this.tech_ && this.techCall_("setAutoplay", s)
            }
            playsinline(e) {
                return e !== void 0 && (this.techCall_("setPlaysinline", e),
                    this.options_.playsinline = e),
                    this.techGet_("playsinline")
            }
            loop(e) {
                if (e !== void 0) {
                    this.techCall_("setLoop", e),
                        this.options_.loop = e;
                    return
                }
                return this.techGet_("loop")
            }
            poster(e) {
                if (e === void 0)
                    return this.poster_;
                e || (e = ""),
                    e !== this.poster_ && (this.poster_ = e,
                        this.techCall_("setPoster", e),
                        this.isPosterFromTech_ = !1,
                        this.trigger("posterchange"))
            }
            handleTechPosterChange_() {
                if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
                    const e = this.tech_.poster() || "";
                    e !== this.poster_ && (this.poster_ = e,
                        this.isPosterFromTech_ = !0,
                        this.trigger("posterchange"))
                }
            }
            controls(e) {
                if (e === void 0)
                    return !!this.controls_;
                e = !!e,
                    this.controls_ !== e && (this.controls_ = e,
                        this.usingNativeControls() && this.techCall_("setControls", e),
                        this.controls_ ? (this.removeClass("vjs-controls-disabled"),
                            this.addClass("vjs-controls-enabled"),
                            this.trigger("controlsenabled"),
                            this.usingNativeControls() || this.addTechControlsListeners_()) : (this.removeClass("vjs-controls-enabled"),
                                this.addClass("vjs-controls-disabled"),
                                this.trigger("controlsdisabled"),
                                this.usingNativeControls() || this.removeTechControlsListeners_()))
            }
            usingNativeControls(e) {
                if (e === void 0)
                    return !!this.usingNativeControls_;
                e = !!e,
                    this.usingNativeControls_ !== e && (this.usingNativeControls_ = e,
                        this.usingNativeControls_ ? (this.addClass("vjs-using-native-controls"),
                            this.trigger("usingnativecontrols")) : (this.removeClass("vjs-using-native-controls"),
                                this.trigger("usingcustomcontrols")))
            }
            error(e) {
                if (e === void 0)
                    return this.error_ || null;
                if ($s("beforeerror").forEach(s => {
                    const r = s(this, e);
                    if (!(Yi(r) && !Array.isArray(r) || typeof r == "string" || typeof r == "number" || r === null)) {
                        this.log.error("please return a value that MediaError expects in beforeerror hooks");
                        return
                    }
                    e = r
                }
                ),
                    this.options_.suppressNotSupportedError && e && e.code === 4) {
                    const s = function () {
                        this.error(e)
                    };
                    this.options_.suppressNotSupportedError = !1,
                        this.any(["click", "touchstart"], s),
                        this.one("loadstart", function () {
                            this.off(["click", "touchstart"], s)
                        });
                    return
                }
                if (e === null) {
                    this.error_ = null,
                        this.removeClass("vjs-error"),
                        this.errorDisplay && this.errorDisplay.close();
                    return
                }
                this.error_ = new qt(e),
                    this.addClass("vjs-error"),
                    Ie.error(`(CODE:${this.error_.code} ${qt.errorTypes[this.error_.code]})`, this.error_.message, this.error_),
                    this.trigger("error"),
                    $s("error").forEach(s => s(this, this.error_))
            }
            reportUserActivity(e) {
                this.userActivity_ = !0
            }
            userActive(e) {
                if (e === void 0)
                    return this.userActive_;
                if (e = !!e,
                    e !== this.userActive_) {
                    if (this.userActive_ = e,
                        this.userActive_) {
                        this.userActivity_ = !0,
                            this.removeClass("vjs-user-inactive"),
                            this.addClass("vjs-user-active"),
                            this.trigger("useractive");
                        return
                    }
                    this.tech_ && this.tech_.one("mousemove", function (s) {
                        s.stopPropagation(),
                            s.preventDefault()
                    }),
                        this.userActivity_ = !1,
                        this.removeClass("vjs-user-active"),
                        this.addClass("vjs-user-inactive"),
                        this.trigger("userinactive")
                }
            }
            listenForUserActivity_() {
                let e, s, r;
                const n = Ge(this, this.reportUserActivity)
                    , a = function (T) {
                        (T.screenX !== s || T.screenY !== r) && (s = T.screenX,
                            r = T.screenY,
                            n())
                    }
                    , o = function () {
                        n(),
                            this.clearInterval(e),
                            e = this.setInterval(n, 250)
                    }
                    , u = function (T) {
                        n(),
                            this.clearInterval(e)
                    };
                this.on("mousedown", o),
                    this.on("mousemove", a),
                    this.on("mouseup", u),
                    this.on("mouseleave", u);
                const c = this.getChild("controlBar");
                c && !jt && !Qi && (c.on("mouseenter", function (T) {
                    this.player().options_.inactivityTimeout !== 0 && (this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout),
                        this.player().options_.inactivityTimeout = 0
                }),
                    c.on("mouseleave", function (T) {
                        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout
                    })),
                    this.on("keydown", n),
                    this.on("keyup", n);
                let f;
                const v = function () {
                    if (!this.userActivity_)
                        return;
                    this.userActivity_ = !1,
                        this.userActive(!0),
                        this.clearTimeout(f);
                    const T = this.options_.inactivityTimeout;
                    T <= 0 || (f = this.setTimeout(function () {
                        this.userActivity_ || this.userActive(!1)
                    }, T))
                };
                this.setInterval(v, 250)
            }
            playbackRate(e) {
                if (e !== void 0) {
                    this.techCall_("setPlaybackRate", e);
                    return
                }
                return this.tech_ && this.tech_.featuresPlaybackRate ? this.cache_.lastPlaybackRate || this.techGet_("playbackRate") : 1
            }
            defaultPlaybackRate(e) {
                return e !== void 0 ? this.techCall_("setDefaultPlaybackRate", e) : this.tech_ && this.tech_.featuresPlaybackRate ? this.techGet_("defaultPlaybackRate") : 1
            }
            isAudio(e) {
                if (e !== void 0) {
                    this.isAudio_ = !!e;
                    return
                }
                return !!this.isAudio_
            }
            enableAudioOnlyUI_() {
                this.addClass("vjs-audio-only-mode");
                const e = this.children()
                    , s = this.getChild("ControlBar")
                    , r = s && s.currentHeight();
                e.forEach(n => {
                    n !== s && n.el_ && !n.hasClass("vjs-hidden") && (n.hide(),
                        this.audioOnlyCache_.hiddenChildren.push(n))
                }
                ),
                    this.audioOnlyCache_.playerHeight = this.currentHeight(),
                    this.height(r),
                    this.trigger("audioonlymodechange")
            }
            disableAudioOnlyUI_() {
                this.removeClass("vjs-audio-only-mode"),
                    this.audioOnlyCache_.hiddenChildren.forEach(e => e.show()),
                    this.height(this.audioOnlyCache_.playerHeight),
                    this.trigger("audioonlymodechange")
            }
            audioOnlyMode(e) {
                if (typeof e != "boolean" || e === this.audioOnlyMode_)
                    return this.audioOnlyMode_;
                if (this.audioOnlyMode_ = e,
                    e) {
                    const s = [];
                    return this.isInPictureInPicture() && s.push(this.exitPictureInPicture()),
                        this.isFullscreen() && s.push(this.exitFullscreen()),
                        this.audioPosterMode() && s.push(this.audioPosterMode(!1)),
                        Promise.all(s).then(() => this.enableAudioOnlyUI_())
                }
                return Promise.resolve().then(() => this.disableAudioOnlyUI_())
            }
            enablePosterModeUI_() {
                (this.tech_ && this.tech_).hide(),
                    this.addClass("vjs-audio-poster-mode"),
                    this.trigger("audiopostermodechange")
            }
            disablePosterModeUI_() {
                (this.tech_ && this.tech_).show(),
                    this.removeClass("vjs-audio-poster-mode"),
                    this.trigger("audiopostermodechange")
            }
            audioPosterMode(e) {
                return typeof e != "boolean" || e === this.audioPosterMode_ ? this.audioPosterMode_ : (this.audioPosterMode_ = e,
                    e ? this.audioOnlyMode() ? this.audioOnlyMode(!1).then(() => {
                        this.enablePosterModeUI_()
                    }
                    ) : Promise.resolve().then(() => {
                        this.enablePosterModeUI_()
                    }
                    ) : Promise.resolve().then(() => {
                        this.disablePosterModeUI_()
                    }
                    ))
            }
            addTextTrack(e, s, r) {
                if (this.tech_)
                    return this.tech_.addTextTrack(e, s, r)
            }
            addRemoteTextTrack(e, s) {
                if (this.tech_)
                    return this.tech_.addRemoteTextTrack(e, s)
            }
            removeRemoteTextTrack(e = {}) {
                let { track: s } = e;
                if (s || (s = e),
                    this.tech_)
                    return this.tech_.removeRemoteTextTrack(s)
            }
            getVideoPlaybackQuality() {
                return this.techGet_("getVideoPlaybackQuality")
            }
            videoWidth() {
                return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0
            }
            videoHeight() {
                return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0
            }
            language(e) {
                if (e === void 0)
                    return this.language_;
                this.language_ !== String(e).toLowerCase() && (this.language_ = String(e).toLowerCase(),
                    Ts(this) && this.trigger("languagechange"))
            }
            languages() {
                return ze(pa.prototype.options_.languages, this.languages_)
            }
            toJSON() {
                const e = ze(this.options_)
                    , s = e.tracks;
                e.tracks = [];
                for (let r = 0; r < s.length; r++) {
                    let n = s[r];
                    n = ze(n),
                        n.player = void 0,
                        e.tracks[r] = n
                }
                return e
            }
            createModal(e, s) {
                s = s || {},
                    s.content = e || "";
                const r = new pn(this, s);
                return this.addChild(r),
                    r.on("dispose", () => {
                        this.removeChild(r)
                    }
                    ),
                    r.open(),
                    r
            }
            updateCurrentBreakpoint_() {
                if (!this.responsive())
                    return;
                const e = this.currentBreakpoint()
                    , s = this.currentWidth();
                for (let r = 0; r < md.length; r++) {
                    const n = md[r]
                        , a = this.breakpoints_[n];
                    if (s <= a) {
                        if (e === n)
                            return;
                        e && this.removeClass(vl[e]),
                            this.addClass(vl[n]),
                            this.breakpoint_ = n;
                        break
                    }
                }
            }
            removeCurrentBreakpoint_() {
                const e = this.currentBreakpointClass();
                this.breakpoint_ = "",
                    e && this.removeClass(e)
            }
            breakpoints(e) {
                return e === void 0 ? Object.assign(this.breakpoints_) : (this.breakpoint_ = "",
                    this.breakpoints_ = Object.assign({}, $T, e),
                    this.updateCurrentBreakpoint_(),
                    Object.assign(this.breakpoints_))
            }
            responsive(e) {
                if (e === void 0)
                    return this.responsive_;
                e = !!e;
                const s = this.responsive_;
                if (e !== s)
                    return this.responsive_ = e,
                        e ? (this.on("playerresize", this.boundUpdateCurrentBreakpoint_),
                            this.updateCurrentBreakpoint_()) : (this.off("playerresize", this.boundUpdateCurrentBreakpoint_),
                                this.removeCurrentBreakpoint_()),
                        e
            }
            currentBreakpoint() {
                return this.breakpoint_
            }
            currentBreakpointClass() {
                return vl[this.breakpoint_] || ""
            }
            loadMedia(e, s) {
                if (!e || typeof e != "object")
                    return;
                const r = this.crossOrigin();
                this.reset(),
                    this.cache_.media = ze(e);
                const { artist: n, artwork: a, description: o, poster: u, src: c, textTracks: f, title: v } = this.cache_.media;
                !a && u && (this.cache_.media.artwork = [{
                    src: u,
                    type: fl(u)
                }]),
                    r && this.crossOrigin(r),
                    c && this.src(c),
                    u && this.poster(u),
                    Array.isArray(f) && f.forEach(T => this.addRemoteTextTrack(T, !1)),
                    this.titleBar && this.titleBar.update({
                        title: v,
                        description: o || n || ""
                    }),
                    this.ready(s)
            }
            getMedia() {
                if (!this.cache_.media) {
                    const e = this.poster()
                        , s = this.currentSources()
                        , r = Array.prototype.map.call(this.remoteTextTracks(), a => ({
                            kind: a.kind,
                            label: a.label,
                            language: a.language,
                            src: a.src
                        }))
                        , n = {
                            src: s,
                            textTracks: r
                        };
                    return e && (n.poster = e,
                        n.artwork = [{
                            src: n.poster,
                            type: fl(n.poster)
                        }]),
                        n
                }
                return ze(this.cache_.media)
            }
            static getTagSettings(e) {
                const s = {
                    sources: [],
                    tracks: []
                }
                    , r = Gs(e)
                    , n = r["data-setup"];
                if (ba(e, "vjs-fill") && (r.fill = !0),
                    ba(e, "vjs-fluid") && (r.fluid = !0),
                    n !== null) {
                    const [a, o] = (0,
                        qy.default)(n || "{}");
                    a && Ie.error(a),
                        Object.assign(r, o)
                }
                if (Object.assign(s, r),
                    e.hasChildNodes()) {
                    const a = e.childNodes;
                    for (let o = 0, u = a.length; o < u; o++) {
                        const c = a[o]
                            , f = c.nodeName.toLowerCase();
                        f === "source" ? s.sources.push(Gs(c)) : f === "track" && s.tracks.push(Gs(c))
                    }
                }
                return s
            }
            debug(e) {
                if (e === void 0)
                    return this.debugEnabled_;
                e ? (this.trigger("debugon"),
                    this.previousLogLevel_ = this.log.level,
                    this.log.level("debug"),
                    this.debugEnabled_ = !0) : (this.trigger("debugoff"),
                        this.log.level(this.previousLogLevel_),
                        this.previousLogLevel_ = void 0,
                        this.debugEnabled_ = !1)
            }
            playbackRates(e) {
                if (e === void 0)
                    return this.cache_.playbackRates;
                Array.isArray(e) && e.every(s => typeof s == "number") && (this.cache_.playbackRates = e,
                    this.trigger("playbackrateschange"))
            }
        }
        ;
    $t.names.forEach(function (t) {
        const e = $t[t];
        ht.prototype[e.getterName] = function () {
            return this.tech_ ? this.tech_[e.getterName]() : (this[e.privateName] = this[e.privateName] || new e.ListClass,
                this[e.privateName])
        }
    }),
        ht.prototype.crossorigin = ht.prototype.crossOrigin,
        ht.players = {};
    var La = O.default.navigator;
    ht.prototype.options_ = {
        techOrder: He.defaultTechOrder_,
        html5: {},
        enableSourceset: !0,
        inactivityTimeout: 2e3,
        playbackRates: [],
        liveui: !1,
        children: ["mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager"],
        language: La && (La.languages && La.languages[0] || La.userLanguage || La.language) || "en",
        languages: {},
        notSupportedMessage: "No compatible source was found for this media.",
        normalizeAutoplay: !1,
        fullscreen: {
            options: {
                navigationUI: "hide"
            }
        },
        breakpoints: {},
        responsive: !1,
        audioOnlyMode: !1,
        audioPosterMode: !1
    },
        jp.forEach(function (t) {
            ht.prototype[`handleTech${tt(t)}_`] = function () {
                return this.trigger(t)
            }
        }),
        J.registerComponent("Player", ht);
    var yl = "plugin"
        , Tn = "activePlugins_"
        , bn = {}
        , _l = t => bn.hasOwnProperty(t)
        , Tl = t => _l(t) ? bn[t] : void 0
        , Hp = (t, e) => {
            t[Tn] = t[Tn] || {},
                t[Tn][e] = !0
        }
        , bl = (t, e, s) => {
            const r = (s ? "before" : "") + "pluginsetup";
            t.trigger(r, e),
                t.trigger(r + ":" + e.name, e)
        }
        , VT = function (t, e) {
            const s = function () {
                bl(this, {
                    name: t,
                    plugin: e,
                    instance: null
                }, !0);
                const r = e.apply(this, arguments);
                return Hp(this, t),
                    bl(this, {
                        name: t,
                        plugin: e,
                        instance: r
                    }),
                    r
            };
            return Object.keys(e).forEach(function (r) {
                s[r] = e[r]
            }),
                s
        }
        , qp = (t, e) => (e.prototype.name = t,
            function (...s) {
                bl(this, {
                    name: t,
                    plugin: e,
                    instance: null
                }, !0);
                const r = new e(this, ...s);
                return this[t] = () => r,
                    bl(this, r.getEventHash()),
                    r
            }
        )
        , is = class th {
            constructor(e) {
                if (this.constructor === th)
                    throw new Error("Plugin must be sub-classed; not directly instantiated.");
                this.player = e,
                    this.log || (this.log = this.player.log.createLogger(this.name)),
                    Mh(this),
                    delete this.trigger,
                    Bf(this, this.constructor.defaultState),
                    Hp(e, this.name),
                    this.dispose = this.dispose.bind(this),
                    e.on("dispose", this.dispose)
            }
            version() {
                return this.constructor.VERSION
            }
            getEventHash(e = {}) {
                return e.name = this.name,
                    e.plugin = this.constructor,
                    e.instance = this,
                    e
            }
            trigger(e, s = {}) {
                return fn(this.eventBusEl_, e, this.getEventHash(s))
            }
            handleStateChanged(e) { }
            dispose() {
                const { name: e, player: s } = this;
                this.trigger("dispose"),
                    this.off(),
                    s.off("dispose", this.dispose),
                    s[Tn][e] = !1,
                    this.player = this.state = null,
                    s[e] = qp(e, bn[e])
            }
            static isBasic(e) {
                const s = typeof e == "string" ? Tl(e) : e;
                return typeof s == "function" && !th.prototype.isPrototypeOf(s.prototype)
            }
            static registerPlugin(e, s) {
                if (typeof e != "string")
                    throw new Error(`Illegal plugin name, "${e}", must be a string, was ${typeof e}.`);
                if (_l(e))
                    Ie.warn(`A plugin named "${e}" already exists. You may want to avoid re-registering plugins!`);
                else if (ht.prototype.hasOwnProperty(e))
                    throw new Error(`Illegal plugin name, "${e}", cannot share a name with an existing player method!`);
                if (typeof s != "function")
                    throw new Error(`Illegal plugin for "${e}", must be a function, was ${typeof s}.`);
                return bn[e] = s,
                    e !== yl && (th.isBasic(s) ? ht.prototype[e] = VT(e, s) : ht.prototype[e] = qp(e, s)),
                    s
            }
            static deregisterPlugin(e) {
                if (e === yl)
                    throw new Error("Cannot de-register base plugin.");
                _l(e) && (delete bn[e],
                    delete ht.prototype[e])
            }
            static getPlugins(e = Object.keys(bn)) {
                let s;
                return e.forEach(r => {
                    const n = Tl(r);
                    n && (s = s || {},
                        s[r] = n)
                }
                ),
                    s
            }
            static getPluginVersion(e) {
                const s = Tl(e);
                return s && s.VERSION || ""
            }
        }
        ;
    is.getPlugin = Tl,
        is.BASE_PLUGIN_NAME = yl,
        is.registerPlugin(yl, is),
        ht.prototype.usingPlugin = function (t) {
            return !!this[Tn] && this[Tn][t] === !0
        }
        ,
        ht.prototype.hasPlugin = function (t) {
            return !!_l(t)
        }
        ;
    function zT(t, e) {
        let s = !1;
        return function (...r) {
            return s || Ie.warn(t),
                s = !0,
                e.apply(this, r)
        }
    }
    function Oi(t, e, s, r) {
        return zT(`${e} is deprecated and will be removed in ${t}.0; please use ${s} instead.`, r)
    }
    var $p = t => t.indexOf("#") === 0 ? t.slice(1) : t;
    function U(t, e, s) {
        let r = U.getPlayer(t);
        if (r)
            return e && Ie.warn(`Player "${t}" is already initialised. Options will not be applied.`),
                s && r.ready(s),
                r;
        const n = typeof t == "string" ? Ws("#" + $p(t)) : t;
        if (!un(n))
            throw new TypeError("The element or ID supplied is not valid. (videojs)");
        const o = ("getRootNode" in n ? n.getRootNode() instanceof O.default.ShadowRoot : !1) ? n.getRootNode() : n.ownerDocument.body;
        (!n.ownerDocument.defaultView || !o.contains(n)) && Ie.warn("The element supplied is not included in the DOM"),
            e = e || {},
            e.restoreEl === !0 && (e.restoreEl = (n.parentNode && n.parentNode.hasAttribute("data-vjs-player") ? n.parentNode : n).cloneNode(!0)),
            $s("beforesetup").forEach(c => {
                const f = c(n, ze(e));
                if (!Yi(f) || Array.isArray(f)) {
                    Ie.error("please return an object in beforesetup hooks");
                    return
                }
                e = ze(e, f)
            }
            );
        const u = J.getComponent("Player");
        return r = new u(n, e, s),
            $s("setup").forEach(c => c(r)),
            r
    }
    if (U.hooks_ = _s,
        U.hooks = $s,
        U.hook = A0,
        U.hookOnce = w0,
        U.removeHook = af,
        O.default.VIDEOJS_NO_DYNAMIC_STYLE !== !0 && ln()) {
        let t = Ws(".vjs-styles-defaults");
        if (!t) {
            t = Pf("vjs-styles-defaults");
            const e = Ws("head");
            e && e.insertBefore(t, e.firstChild),
                Lf(t, `
      .video-js {
        width: 300px;
        height: 150px;
      }

      .vjs-fluid:not(.vjs-audio-only-mode) {
        padding-top: 56.25%
      }
    `)
        }
    }
    kh(1, U),
        U.VERSION = nf,
        U.options = ht.prototype.options_,
        U.getPlayers = () => ht.players,
        U.getPlayer = t => {
            const e = ht.players;
            let s;
            if (typeof t == "string") {
                const r = $p(t)
                    , n = e[r];
                if (n)
                    return n;
                s = Ws("#" + r)
            } else
                s = t;
            if (un(s)) {
                const { player: r, playerId: n } = s;
                if (r || e[n])
                    return r || e[n]
            }
        }
        ,
        U.getAllPlayers = () => Object.keys(ht.players).map(t => ht.players[t]).filter(Boolean),
        U.players = ht.players,
        U.getComponent = J.getComponent,
        U.registerComponent = (t, e) => (He.isTech(e) && Ie.warn(`The ${t} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`),
            J.registerComponent.call(J, t, e)),
        U.getTech = He.getTech,
        U.registerTech = He.registerTech,
        U.use = tT,
        Object.defineProperty(U, "middleware", {
            value: {},
            writeable: !1,
            enumerable: !0
        }),
        Object.defineProperty(U.middleware, "TERMINATOR", {
            value: cl,
            writeable: !1,
            enumerable: !0
        }),
        U.browser = I0,
        U.obj = x0,
        U.mergeOptions = Oi(9, "videojs.mergeOptions", "videojs.obj.merge", ze),
        U.defineLazyProperty = Oi(9, "videojs.defineLazyProperty", "videojs.obj.defineLazyProperty", Xo),
        U.bind = Oi(9, "videojs.bind", "native Function.prototype.bind", Ge),
        U.registerPlugin = is.registerPlugin,
        U.deregisterPlugin = is.deregisterPlugin,
        U.plugin = (t, e) => (Ie.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead"),
            is.registerPlugin(t, e)),
        U.getPlugins = is.getPlugins,
        U.getPlugin = is.getPlugin,
        U.getPluginVersion = is.getPluginVersion,
        U.addLanguage = function (t, e) {
            return t = ("" + t).toLowerCase(),
                U.options.languages = ze(U.options.languages, {
                    [t]: e
                }),
                U.options.languages[t]
        }
        ,
        U.log = Ie,
        U.createLogger = lf,
        U.time = V0,
        U.createTimeRange = Oi(9, "videojs.createTimeRange", "videojs.time.createTimeRanges", Li),
        U.createTimeRanges = Oi(9, "videojs.createTimeRanges", "videojs.time.createTimeRanges", Li),
        U.formatTime = Oi(9, "videojs.formatTime", "videojs.time.formatTime", _r),
        U.setFormatTime = Oi(9, "videojs.setFormatTime", "videojs.time.setFormatTime", Hf),
        U.resetFormatTime = Oi(9, "videojs.resetFormatTime", "videojs.time.resetFormatTime", qf),
        U.parseUrl = Oi(9, "videojs.parseUrl", "videojs.url.parseUrl", qh),
        U.isCrossOrigin = Oi(9, "videojs.isCrossOrigin", "videojs.url.isCrossOrigin", dl),
        U.EventTarget = bi,
        U.any = Ph,
        U.on = ui,
        U.one = ll,
        U.off = kt,
        U.trigger = fn,
        U.xhr = Dc.default,
        U.TextTrack = Da,
        U.AudioTrack = Qf,
        U.VideoTrack = Jf,
        ["isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent"].forEach(t => {
            U[t] = function () {
                return Ie.warn(`videojs.${t}() is deprecated; use videojs.dom.${t}() instead`),
                    xf[t].apply(null, arguments)
            }
        }
        ),
        U.computedStyle = Oi(9, "videojs.computedStyle", "videojs.dom.computedStyle", cn),
        U.dom = xf,
        U.fn = F0,
        U.num = bT,
        U.str = q0,
        U.url = Z0;
    var GT = class {
        constructor(t) {
            let e = this;
            return e.id = t.id,
                e.label = e.id,
                e.width = t.width,
                e.height = t.height,
                e.bitrate = t.bandwidth,
                e.frameRate = t.frameRate,
                e.enabled_ = t.enabled,
                Object.defineProperty(e, "enabled", {
                    get() {
                        return e.enabled_()
                    },
                    set(s) {
                        e.enabled_(s)
                    }
                }),
                e
        }
    }
        , El = class extends U.EventTarget {
            constructor() {
                super();
                let t = this;
                return t.levels_ = [],
                    t.selectedIndex_ = -1,
                    Object.defineProperty(t, "selectedIndex", {
                        get() {
                            return t.selectedIndex_
                        }
                    }),
                    Object.defineProperty(t, "length", {
                        get() {
                            return t.levels_.length
                        }
                    }),
                    t[Symbol.iterator] = () => t.levels_.values(),
                    t
            }
            addQualityLevel(t) {
                let e = this.getQualityLevelById(t.id);
                if (e)
                    return e;
                const s = this.levels_.length;
                return e = new GT(t),
                    "" + s in this || Object.defineProperty(this, s, {
                        get() {
                            return this.levels_[s]
                        }
                    }),
                    this.levels_.push(e),
                    this.trigger({
                        qualityLevel: e,
                        type: "addqualitylevel"
                    }),
                    e
            }
            removeQualityLevel(t) {
                let e = null;
                for (let s = 0, r = this.length; s < r; s++)
                    if (this[s] === t) {
                        e = this.levels_.splice(s, 1)[0],
                            this.selectedIndex_ === s ? this.selectedIndex_ = -1 : this.selectedIndex_ > s && this.selectedIndex_--;
                        break
                    }
                return e && this.trigger({
                    qualityLevel: t,
                    type: "removequalitylevel"
                }),
                    e
            }
            getQualityLevelById(t) {
                for (let e = 0, s = this.length; e < s; e++) {
                    const r = this[e];
                    if (r.id === t)
                        return r
                }
                return null
            }
            dispose() {
                this.selectedIndex_ = -1,
                    this.levels_.length = 0
            }
        }
        ;
    El.prototype.allowedEvents_ = {
        change: "change",
        addqualitylevel: "addqualitylevel",
        removequalitylevel: "removequalitylevel"
    };
    for (const t in El.prototype.allowedEvents_)
        El.prototype["on" + t] = null;
    var Vp = "4.0.0"
        , WT = function (t, e) {
            const s = t.qualityLevels
                , r = new El
                , n = function () {
                    r.dispose(),
                        t.qualityLevels = s,
                        t.off("dispose", n)
                };
            return t.on("dispose", n),
                t.qualityLevels = () => r,
                t.qualityLevels.VERSION = Vp,
                r
        }
        , zp = function (t) {
            return WT(this, U.obj.merge({}, t))
        };
    U.registerPlugin("qualityLevels", zp),
        zp.VERSION = Vp;
    var ii = jo
        , Sl = (t, e) => e && e.responseURL && t !== e.responseURL ? e.responseURL : t
        , Ci = t => U.log.debug ? U.log.debug.bind(U, "VHS:", `${t} >`) : function () { }
        ;
    function Re(...t) {
        const e = U.obj || U;
        return (e.merge || e.mergeOptions).apply(e, t)
    }
    function xt(...t) {
        const e = U.time || U;
        return (e.createTimeRanges || e.createTimeRanges).apply(e, t)
    }
    var Ks = 1 / 30
        , ss = Ks * 3
        , Gp = function (t, e) {
            const s = [];
            let r;
            if (t && t.length)
                for (r = 0; r < t.length; r++)
                    e(t.start(r), t.end(r)) && s.push([t.start(r), t.end(r)]);
            return xt(s)
        }
        , En = function (t, e) {
            return Gp(t, function (s, r) {
                return s - ss <= e && r + ss >= e
            })
        }
        , Cl = function (t, e) {
            return Gp(t, function (s) {
                return s - Ks >= e
            })
        }
        , KT = function (t) {
            if (t.length < 2)
                return xt();
            const e = [];
            for (let s = 1; s < t.length; s++) {
                const r = t.end(s - 1)
                    , n = t.start(s);
                e.push([r, n])
            }
            return xt(e)
        }
        , XT = function (t, e) {
            let s = null
                , r = null
                , n = 0;
            const a = []
                , o = [];
            if (!t || !t.length || !e || !e.length)
                return xt();
            let u = t.length;
            for (; u--;)
                a.push({
                    time: t.start(u),
                    type: "start"
                }),
                    a.push({
                        time: t.end(u),
                        type: "end"
                    });
            for (u = e.length; u--;)
                a.push({
                    time: e.start(u),
                    type: "start"
                }),
                    a.push({
                        time: e.end(u),
                        type: "end"
                    });
            for (a.sort(function (c, f) {
                return c.time - f.time
            }),
                u = 0; u < a.length; u++)
                a[u].type === "start" ? (n++,
                    n === 2 && (s = a[u].time)) : a[u].type === "end" && (n--,
                        n === 1 && (r = a[u].time)),
                    s !== null && r !== null && (o.push([s, r]),
                        s = null,
                        r = null);
            return xt(o)
        }
        , Wp = t => {
            const e = [];
            if (!t || !t.length)
                return "";
            for (let s = 0; s < t.length; s++)
                e.push(t.start(s) + " => " + t.end(s));
            return e.join(", ")
        }
        , YT = function (t, e, s = 1) {
            return ((t.length ? t.end(t.length - 1) : 0) - e) / s
        }
        , Sr = t => {
            const e = [];
            for (let s = 0; s < t.length; s++)
                e.push({
                    start: t.start(s),
                    end: t.end(s)
                });
            return e
        }
        , QT = function (t, e) {
            if (t === e)
                return !1;
            if (!t && e || !e && t || t.length !== e.length)
                return !0;
            for (let s = 0; s < t.length; s++)
                if (t.start(s) !== e.start(s) || t.end(s) !== e.end(s))
                    return !0;
            return !1
        }
        , Kp = function (t) {
            if (!(!t || !t.length || !t.end))
                return t.end(t.length - 1)
        }
        , gd = function (t, e) {
            let s = 0;
            if (!t || !t.length)
                return s;
            for (let r = 0; r < t.length; r++) {
                const n = t.start(r)
                    , a = t.end(r);
                if (!(e > a)) {
                    if (e > n && e <= a) {
                        s += a - e;
                        continue
                    }
                    s += a - n
                }
            }
            return s
        }
        , vd = (t, e) => {
            if (!e.preload)
                return e.duration;
            let s = 0;
            return (e.parts || []).forEach(function (r) {
                s += r.duration
            }),
                (e.preloadHints || []).forEach(function (r) {
                    r.type === "PART" && (s += t.partTargetDuration)
                }),
                s
        }
        , yd = t => (t.segments || []).reduce((e, s, r) => (s.parts ? s.parts.forEach(function (n, a) {
            e.push({
                duration: n.duration,
                segmentIndex: r,
                partIndex: a,
                part: n,
                segment: s
            })
        }) : e.push({
            duration: s.duration,
            segmentIndex: r,
            partIndex: null,
            segment: s,
            part: null
        }),
            e), [])
        , Xp = t => {
            const e = t.segments && t.segments.length && t.segments[t.segments.length - 1];
            return e && e.parts || []
        }
        , Yp = ({ preloadSegment: t }) => {
            if (!t)
                return;
            const { parts: e, preloadHints: s } = t;
            let r = (s || []).reduce((n, a) => n + (a.type === "PART" ? 1 : 0), 0);
            return r += e && e.length ? e.length : 0,
                r
        }
        , Qp = (t, e) => {
            if (e.endList)
                return 0;
            if (t && t.suggestedPresentationDelay)
                return t.suggestedPresentationDelay;
            const s = Xp(e).length > 0;
            return s && e.serverControl && e.serverControl.partHoldBack ? e.serverControl.partHoldBack : s && e.partTargetDuration ? e.partTargetDuration * 3 : e.serverControl && e.serverControl.holdBack ? e.serverControl.holdBack : e.targetDuration ? e.targetDuration * 3 : 0
        }
        , JT = function (t, e) {
            let s = 0
                , r = e - t.mediaSequence
                , n = t.segments[r];
            if (n) {
                if (typeof n.start < "u")
                    return {
                        result: n.start,
                        precise: !0
                    };
                if (typeof n.end < "u")
                    return {
                        result: n.end - n.duration,
                        precise: !0
                    }
            }
            for (; r--;) {
                if (n = t.segments[r],
                    typeof n.end < "u")
                    return {
                        result: s + n.end,
                        precise: !0
                    };
                if (s += vd(t, n),
                    typeof n.start < "u")
                    return {
                        result: s + n.start,
                        precise: !0
                    }
            }
            return {
                result: s,
                precise: !1
            }
        }
        , ZT = function (t, e) {
            let s = 0, r, n = e - t.mediaSequence;
            for (; n < t.segments.length; n++) {
                if (r = t.segments[n],
                    typeof r.start < "u")
                    return {
                        result: r.start - s,
                        precise: !0
                    };
                if (s += vd(t, r),
                    typeof r.end < "u")
                    return {
                        result: r.end - s,
                        precise: !0
                    }
            }
            return {
                result: -1,
                precise: !1
            }
        }
        , Jp = function (t, e, s) {
            if (typeof e > "u" && (e = t.mediaSequence + t.segments.length),
                e < t.mediaSequence)
                return 0;
            const r = JT(t, e);
            if (r.precise)
                return r.result;
            const n = ZT(t, e);
            return n.precise ? n.result : r.result + s
        }
        , Zp = function (t, e, s) {
            if (!t)
                return 0;
            if (typeof s != "number" && (s = 0),
                typeof e > "u") {
                if (t.totalDuration)
                    return t.totalDuration;
                if (!t.endList)
                    return O.default.Infinity
            }
            return Jp(t, e, s)
        }
        , Oa = function ({ defaultDuration: t, durationList: e, startIndex: s, endIndex: r }) {
            let n = 0;
            if (s > r && ([s, r] = [r, s]),
                s < 0) {
                for (let a = s; a < Math.min(0, r); a++)
                    n += t;
                s = 0
            }
            for (let a = s; a < r; a++)
                n += e[a].duration;
            return n
        }
        , em = function (t, e, s, r) {
            if (!t || !t.segments)
                return null;
            if (t.endList)
                return Zp(t);
            if (e === null)
                return null;
            e = e || 0;
            let n = Jp(t, t.mediaSequence + t.segments.length, e);
            return s && (r = typeof r == "number" ? r : Qp(null, t),
                n -= r),
                Math.max(0, n)
        }
        , e2 = function (t, e, s) {
            const n = e || 0;
            let a = em(t, e, !0, s);
            return a === null ? xt() : (a < n && (a = n),
                xt(n, a))
        }
        , t2 = function ({ playlist: t, currentTime: e, startingSegmentIndex: s, startingPartIndex: r, startTime: n, exactManifestTimings: a }) {
            let o = e - n;
            const u = yd(t);
            let c = 0;
            for (let f = 0; f < u.length; f++) {
                const v = u[f];
                if (s === v.segmentIndex && !(typeof r == "number" && typeof v.partIndex == "number" && r !== v.partIndex)) {
                    c = f;
                    break
                }
            }
            if (o < 0) {
                if (c > 0)
                    for (let f = c - 1; f >= 0; f--) {
                        const v = u[f];
                        if (o += v.duration,
                            a) {
                            if (o < 0)
                                continue
                        } else if (o + Ks <= 0)
                            continue;
                        return {
                            partIndex: v.partIndex,
                            segmentIndex: v.segmentIndex,
                            startTime: n - Oa({
                                defaultDuration: t.targetDuration,
                                durationList: u,
                                startIndex: c,
                                endIndex: f
                            })
                        }
                    }
                return {
                    partIndex: u[0] && u[0].partIndex || null,
                    segmentIndex: u[0] && u[0].segmentIndex || 0,
                    startTime: e
                }
            }
            if (c < 0) {
                for (let f = c; f < 0; f++)
                    if (o -= t.targetDuration,
                        o < 0)
                        return {
                            partIndex: u[0] && u[0].partIndex || null,
                            segmentIndex: u[0] && u[0].segmentIndex || 0,
                            startTime: e
                        };
                c = 0
            }
            for (let f = c; f < u.length; f++) {
                const v = u[f];
                if (o -= v.duration,
                    a) {
                    if (o > 0)
                        continue
                } else if (o - Ks >= 0)
                    continue;
                return {
                    partIndex: v.partIndex,
                    segmentIndex: v.segmentIndex,
                    startTime: n + Oa({
                        defaultDuration: t.targetDuration,
                        durationList: u,
                        startIndex: c,
                        endIndex: f
                    })
                }
            }
            return {
                segmentIndex: u[u.length - 1].segmentIndex,
                partIndex: u[u.length - 1].partIndex,
                startTime: e
            }
        }
        , tm = function (t) {
            return t.excludeUntil && t.excludeUntil > Date.now()
        }
        , _d = function (t) {
            return t.excludeUntil && t.excludeUntil === 1 / 0
        }
        , Al = function (t) {
            const e = tm(t);
            return !t.disabled && !e
        }
        , i2 = function (t) {
            return t.disabled
        }
        , s2 = function (t) {
            for (let e = 0; e < t.segments.length; e++)
                if (t.segments[e].key)
                    return !0;
            return !1
        }
        , im = function (t, e) {
            return e.attributes && e.attributes[t]
        }
        , r2 = function (t, e, s, r = 0) {
            return im("BANDWIDTH", s) ? (t * s.attributes.BANDWIDTH - r * 8) / e : NaN
        }
        , Td = (t, e) => {
            if (t.playlists.length === 1)
                return !0;
            const s = e.attributes.BANDWIDTH || Number.MAX_VALUE;
            return t.playlists.filter(r => Al(r) ? (r.attributes.BANDWIDTH || 0) < s : !1).length === 0
        }
        , bd = (t, e) => !t && !e || !t && e || t && !e ? !1 : !!(t === e || t.id && e.id && t.id === e.id || t.resolvedUri && e.resolvedUri && t.resolvedUri === e.resolvedUri || t.uri && e.uri && t.uri === e.uri)
        , sm = function (t, e) {
            const s = t && t.mediaGroups && t.mediaGroups.AUDIO || {};
            let r = !1;
            for (const n in s) {
                for (const a in s[n])
                    if (r = e(s[n][a]),
                        r)
                        break;
                if (r)
                    break
            }
            return !!r
        }
        , Ma = t => {
            if (!t || !t.playlists || !t.playlists.length)
                return sm(t, s => s.playlists && s.playlists.length || s.uri);
            for (let e = 0; e < t.playlists.length; e++) {
                const s = t.playlists[e]
                    , r = s.attributes && s.attributes.CODECS;
                if (!(r && r.split(",").every(a => Mc(a)) || sm(t, a => bd(s, a))))
                    return !1
            }
            return !0
        }
        , si = {
            liveEdgeDelay: Qp,
            duration: Zp,
            seekable: e2,
            getMediaInfoForTime: t2,
            isEnabled: Al,
            isDisabled: i2,
            isExcluded: tm,
            isIncompatible: _d,
            playlistEnd: em,
            isAes: s2,
            hasAttribute: im,
            estimateSegmentRequestTime: r2,
            isLowestEnabledRendition: Td,
            isAudioOnly: Ma,
            playlistMatch: bd,
            segmentDurationWithParts: vd
        }
        , { log: rm } = U
        , Sn = (t, e) => `${t}-${e}`
        , nm = (t, e, s) => `placeholder-uri-${t}-${e}-${s}`
        , n2 = ({ onwarn: t, oninfo: e, manifestString: s, customTagParsers: r = [], customTagMappers: n = [], llhls: a }) => {
            const o = new Qy;
            t && o.on("warn", t),
                e && o.on("info", e),
                r.forEach(f => o.addParser(f)),
                n.forEach(f => o.addTagMapper(f)),
                o.push(s),
                o.end();
            const u = o.manifest;
            if (a || (["preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration"].forEach(function (f) {
                u.hasOwnProperty(f) && delete u[f]
            }),
                u.segments && u.segments.forEach(function (f) {
                    ["parts", "preloadHints"].forEach(function (v) {
                        f.hasOwnProperty(v) && delete f[v]
                    })
                })),
                !u.targetDuration) {
                let f = 10;
                u.segments && u.segments.length && (f = u.segments.reduce((v, T) => Math.max(v, T.duration), 0)),
                    t && t({
                        message: `manifest has no targetDuration defaulting to ${f}`
                    }),
                    u.targetDuration = f
            }
            const c = Xp(u);
            if (c.length && !u.partTargetDuration) {
                const f = c.reduce((v, T) => Math.max(v, T.duration), 0);
                t && (t({
                    message: `manifest has no partTargetDuration defaulting to ${f}`
                }),
                    rm.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.")),
                    u.partTargetDuration = f
            }
            return u
        }
        , Cn = (t, e) => {
            t.mediaGroups && ["AUDIO", "SUBTITLES"].forEach(s => {
                if (t.mediaGroups[s])
                    for (const r in t.mediaGroups[s])
                        for (const n in t.mediaGroups[s][r]) {
                            const a = t.mediaGroups[s][r][n];
                            e(a, s, r, n)
                        }
            }
            )
        }
        , am = ({ playlist: t, uri: e, id: s }) => {
            t.id = s,
                t.playlistErrors_ = 0,
                e && (t.uri = e),
                t.attributes = t.attributes || {}
        }
        , a2 = t => {
            let e = t.playlists.length;
            for (; e--;) {
                const s = t.playlists[e];
                am({
                    playlist: s,
                    id: Sn(e, s.uri)
                }),
                    s.resolvedUri = ii(t.uri, s.uri),
                    t.playlists[s.id] = s,
                    t.playlists[s.uri] = s,
                    s.attributes.BANDWIDTH || rm.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.")
            }
        }
        , o2 = t => {
            Cn(t, e => {
                e.uri && (e.resolvedUri = ii(t.uri, e.uri))
            }
            )
        }
        , l2 = (t, e) => {
            const s = Sn(0, e)
                , r = {
                    mediaGroups: {
                        AUDIO: {},
                        VIDEO: {},
                        "CLOSED-CAPTIONS": {},
                        SUBTITLES: {}
                    },
                    uri: O.default.location.href,
                    resolvedUri: O.default.location.href,
                    playlists: [{
                        uri: e,
                        id: s,
                        resolvedUri: e,
                        attributes: {}
                    }]
                };
            return r.playlists[s] = r.playlists[0],
                r.playlists[e] = r.playlists[0],
                r
        }
        , om = (t, e, s = nm) => {
            t.uri = e;
            for (let n = 0; n < t.playlists.length; n++)
                if (!t.playlists[n].uri) {
                    const a = `placeholder-uri-${n}`;
                    t.playlists[n].uri = a
                }
            const r = Ma(t);
            Cn(t, (n, a, o, u) => {
                if (!n.playlists || !n.playlists.length) {
                    if (r && a === "AUDIO" && !n.uri)
                        for (let c = 0; c < t.playlists.length; c++) {
                            const f = t.playlists[c];
                            if (f.attributes && f.attributes.AUDIO && f.attributes.AUDIO === o)
                                return
                        }
                    n.playlists = [Pi({}, n)]
                }
                n.playlists.forEach(function (c, f) {
                    const v = s(a, o, u, c)
                        , T = Sn(f, v);
                    c.uri ? c.resolvedUri = c.resolvedUri || ii(t.uri, c.uri) : (c.uri = f === 0 ? v : T,
                        c.resolvedUri = c.uri),
                        c.id = c.id || T,
                        c.attributes = c.attributes || {},
                        t.playlists[c.id] = c,
                        t.playlists[c.uri] = c
                })
            }
            ),
                a2(t),
                o2(t)
        }
        , lm = class {
            constructor() {
                this.offset_ = null,
                    this.pendingDateRanges_ = new Map,
                    this.processedDateRanges_ = new Map
            }
            setOffset(t = []) {
                if (this.offset_ !== null || !t.length)
                    return;
                const [e] = t;
                e.programDateTime !== void 0 && (this.offset_ = e.programDateTime / 1e3)
            }
            setPendingDateRanges(t = []) {
                if (!t.length)
                    return;
                const [e] = t
                    , s = e.startDate.getTime();
                this.trimProcessedDateRanges_(s),
                    this.pendingDateRanges_ = t.reduce((r, n) => (r.set(n.id, n),
                        r), new Map)
            }
            processDateRange(t) {
                this.pendingDateRanges_.delete(t.id),
                    this.processedDateRanges_.set(t.id, t)
            }
            getDateRangesToProcess() {
                if (this.offset_ === null)
                    return [];
                const t = {}
                    , e = [];
                this.pendingDateRanges_.forEach((s, r) => {
                    if (!this.processedDateRanges_.has(r) && (s.startTime = s.startDate.getTime() / 1e3 - this.offset_,
                        s.processDateRange = () => this.processDateRange(s),
                        e.push(s),
                        !!s.class))
                        if (t[s.class]) {
                            const n = t[s.class].push(s);
                            s.classListIndex = n - 1
                        } else
                            t[s.class] = [s],
                                s.classListIndex = 0
                }
                );
                for (const s of e) {
                    const r = t[s.class] || [];
                    s.endDate ? s.endTime = s.endDate.getTime() / 1e3 - this.offset_ : s.endOnNext && r[s.classListIndex + 1] ? s.endTime = r[s.classListIndex + 1].startTime : s.duration ? s.endTime = s.startTime + s.duration : s.plannedDuration ? s.endTime = s.startTime + s.plannedDuration : s.endTime = s.startTime
                }
                return e
            }
            trimProcessedDateRanges_(t) {
                new Map(this.processedDateRanges_).forEach((s, r) => {
                    s.startDate.getTime() < t && this.processedDateRanges_.delete(r)
                }
                )
            }
        }
        , { EventTarget: u2 } = U
        , h2 = (t, e) => {
            if (e.endList || !e.serverControl)
                return t;
            const s = {};
            if (e.serverControl.canBlockReload) {
                const { preloadSegment: r } = e;
                let n = e.mediaSequence + e.segments.length;
                if (r) {
                    const a = r.parts || []
                        , o = Yp(e) - 1;
                    o > -1 && o !== a.length - 1 && (s._HLS_part = o),
                        (o > -1 || a.length) && n--
                }
                s._HLS_msn = n
            }
            if (e.serverControl && e.serverControl.canSkipUntil && (s._HLS_skip = e.serverControl.canSkipDateranges ? "v2" : "YES"),
                Object.keys(s).length) {
                const r = new O.default.URL(t);
                ["_HLS_skip", "_HLS_msn", "_HLS_part"].forEach(function (n) {
                    s.hasOwnProperty(n) && r.searchParams.set(n, s[n])
                }),
                    t = r.toString()
            }
            return t
        }
        , d2 = (t, e) => {
            if (!t)
                return e;
            const s = Re(t, e);
            if (t.preloadHints && !e.preloadHints && delete s.preloadHints,
                t.parts && !e.parts)
                delete s.parts;
            else if (t.parts && e.parts)
                for (let r = 0; r < e.parts.length; r++)
                    t.parts && t.parts[r] && (s.parts[r] = Re(t.parts[r], e.parts[r]));
            return !t.skipped && e.skipped && (s.skipped = !1),
                t.preload && !e.preload && (s.preload = !1),
                s
        }
        , c2 = (t, e, s) => {
            const r = t.slice()
                , n = e.slice();
            s = s || 0;
            const a = [];
            let o;
            for (let u = 0; u < n.length; u++) {
                const c = r[u + s]
                    , f = n[u];
                c ? (o = c.map || o,
                    a.push(d2(c, f))) : (o && !f.map && (f.map = o),
                        a.push(f))
            }
            return a
        }
        , um = (t, e) => {
            !t.resolvedUri && t.uri && (t.resolvedUri = ii(e, t.uri)),
                t.key && !t.key.resolvedUri && (t.key.resolvedUri = ii(e, t.key.uri)),
                t.map && !t.map.resolvedUri && (t.map.resolvedUri = ii(e, t.map.uri)),
                t.map && t.map.key && !t.map.key.resolvedUri && (t.map.key.resolvedUri = ii(e, t.map.key.uri)),
                t.parts && t.parts.length && t.parts.forEach(s => {
                    s.resolvedUri || (s.resolvedUri = ii(e, s.uri))
                }
                ),
                t.preloadHints && t.preloadHints.length && t.preloadHints.forEach(s => {
                    s.resolvedUri || (s.resolvedUri = ii(e, s.uri))
                }
                )
        }
        , hm = function (t) {
            const e = t.segments || []
                , s = t.preloadSegment;
            if (s && s.parts && s.parts.length) {
                if (s.preloadHints) {
                    for (let r = 0; r < s.preloadHints.length; r++)
                        if (s.preloadHints[r].type === "MAP")
                            return e
                }
                s.duration = t.targetDuration,
                    s.preload = !0,
                    e.push(s)
            }
            return e
        }
        , dm = (t, e) => t === e || t.segments && e.segments && t.segments.length === e.segments.length && t.endList === e.endList && t.mediaSequence === e.mediaSequence && t.preloadSegment === e.preloadSegment
        , Ed = (t, e, s = dm) => {
            const r = Re(t, {})
                , n = r.playlists[e.id];
            if (!n || s(n, e))
                return null;
            e.segments = hm(e);
            const a = Re(n, e);
            if (a.preloadSegment && !e.preloadSegment && delete a.preloadSegment,
                n.segments) {
                if (e.skip) {
                    e.segments = e.segments || [];
                    for (let o = 0; o < e.skip.skippedSegments; o++)
                        e.segments.unshift({
                            skipped: !0
                        })
                }
                a.segments = c2(n.segments, e.segments, e.mediaSequence - n.mediaSequence)
            }
            a.segments.forEach(o => {
                um(o, a.resolvedUri)
            }
            );
            for (let o = 0; o < r.playlists.length; o++)
                r.playlists[o].id === e.id && (r.playlists[o] = a);
            return r.playlists[e.id] = a,
                r.playlists[e.uri] = a,
                Cn(t, (o, u, c, f) => {
                    if (o.playlists)
                        for (let v = 0; v < o.playlists.length; v++)
                            e.id === o.playlists[v].id && (o.playlists[v] = a)
                }
                ),
                r
        }
        , Sd = (t, e) => {
            const s = t.segments || []
                , r = s[s.length - 1]
                , n = r && r.parts && r.parts[r.parts.length - 1]
                , a = n && n.duration || r && r.duration;
            return e && a ? a * 1e3 : (t.partTargetDuration || t.targetDuration || 10) * 500
        }
        , An = class extends u2 {
            constructor(t, e, s = {}) {
                if (super(),
                    !t)
                    throw new Error("A non-empty playlist URL or object is required");
                this.logger_ = Ci("PlaylistLoader");
                const { withCredentials: r = !1 } = s;
                this.src = t,
                    this.vhs_ = e,
                    this.withCredentials = r,
                    this.addDateRangesToTextTrack_ = s.addDateRangesToTextTrack;
                const n = e.options_;
                this.customTagParsers = n && n.customTagParsers || [],
                    this.customTagMappers = n && n.customTagMappers || [],
                    this.llhls = n && n.llhls,
                    this.dateRangesStorage_ = new lm,
                    this.state = "HAVE_NOTHING",
                    this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this),
                    this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_),
                    this.on("loadedplaylist", this.handleLoadedPlaylist_.bind(this))
            }
            handleLoadedPlaylist_() {
                const t = this.media();
                if (!t)
                    return;
                this.dateRangesStorage_.setOffset(t.segments),
                    this.dateRangesStorage_.setPendingDateRanges(t.dateRanges);
                const e = this.dateRangesStorage_.getDateRangesToProcess();
                !e.length || !this.addDateRangesToTextTrack_ || this.addDateRangesToTextTrack_(e)
            }
            handleMediaupdatetimeout_() {
                if (this.state !== "HAVE_METADATA")
                    return;
                const t = this.media();
                let e = ii(this.main.uri, t.uri);
                this.llhls && (e = h2(e, t)),
                    this.state = "HAVE_CURRENT_METADATA",
                    this.request = this.vhs_.xhr({
                        uri: e,
                        withCredentials: this.withCredentials
                    }, (s, r) => {
                        if (this.request) {
                            if (s)
                                return this.playlistRequestError(this.request, this.media(), "HAVE_METADATA");
                            this.haveMetadata({
                                playlistString: this.request.responseText,
                                url: this.media().uri,
                                id: this.media().id
                            })
                        }
                    }
                    )
            }
            playlistRequestError(t, e, s) {
                const { uri: r, id: n } = e;
                this.request = null,
                    s && (this.state = s),
                    this.error = {
                        playlist: this.main.playlists[n],
                        status: t.status,
                        message: `HLS playlist request error at URL: ${r}.`,
                        responseText: t.responseText,
                        code: t.status >= 500 ? 4 : 2
                    },
                    this.trigger("error")
            }
            parseManifest_({ url: t, manifestString: e }) {
                return n2({
                    onwarn: ({ message: s }) => this.logger_(`m3u8-parser warn for ${t}: ${s}`),
                    oninfo: ({ message: s }) => this.logger_(`m3u8-parser info for ${t}: ${s}`),
                    manifestString: e,
                    customTagParsers: this.customTagParsers,
                    customTagMappers: this.customTagMappers,
                    llhls: this.llhls
                })
            }
            haveMetadata({ playlistString: t, playlistObject: e, url: s, id: r }) {
                this.request = null,
                    this.state = "HAVE_METADATA";
                const n = e || this.parseManifest_({
                    url: s,
                    manifestString: t
                });
                n.lastRequest = Date.now(),
                    am({
                        playlist: n,
                        uri: s,
                        id: r
                    });
                const a = Ed(this.main, n);
                this.targetDuration = n.partTargetDuration || n.targetDuration,
                    this.pendingMedia_ = null,
                    a ? (this.main = a,
                        this.media_ = this.main.playlists[r]) : this.trigger("playlistunchanged"),
                    this.updateMediaUpdateTimeout_(Sd(this.media(), !!a)),
                    this.trigger("loadedplaylist")
            }
            dispose() {
                this.trigger("dispose"),
                    this.stopRequest(),
                    O.default.clearTimeout(this.mediaUpdateTimeout),
                    O.default.clearTimeout(this.finalRenditionTimeout),
                    this.dateRangesStorage_ = new lm,
                    this.off()
            }
            stopRequest() {
                if (this.request) {
                    const t = this.request;
                    this.request = null,
                        t.onreadystatechange = null,
                        t.abort()
                }
            }
            media(t, e) {
                if (!t)
                    return this.media_;
                if (this.state === "HAVE_NOTHING")
                    throw new Error("Cannot switch media playlist from " + this.state);
                if (typeof t == "string") {
                    if (!this.main.playlists[t])
                        throw new Error("Unknown playlist URI: " + t);
                    t = this.main.playlists[t]
                }
                if (O.default.clearTimeout(this.finalRenditionTimeout),
                    e) {
                    const a = (t.partTargetDuration || t.targetDuration) / 2 * 1e3 || 5e3;
                    this.finalRenditionTimeout = O.default.setTimeout(this.media.bind(this, t, !1), a);
                    return
                }
                const s = this.state
                    , r = !this.media_ || t.id !== this.media_.id
                    , n = this.main.playlists[t.id];
                if (n && n.endList || t.endList && t.segments.length) {
                    this.request && (this.request.onreadystatechange = null,
                        this.request.abort(),
                        this.request = null),
                        this.state = "HAVE_METADATA",
                        this.media_ = t,
                        r && (this.trigger("mediachanging"),
                            s === "HAVE_MAIN_MANIFEST" ? this.trigger("loadedmetadata") : this.trigger("mediachange"));
                    return
                }
                if (this.updateMediaUpdateTimeout_(Sd(t, !0)),
                    !!r) {
                    if (this.state = "SWITCHING_MEDIA",
                        this.request) {
                        if (t.resolvedUri === this.request.url)
                            return;
                        this.request.onreadystatechange = null,
                            this.request.abort(),
                            this.request = null
                    }
                    this.media_ && this.trigger("mediachanging"),
                        this.pendingMedia_ = t,
                        this.request = this.vhs_.xhr({
                            uri: t.resolvedUri,
                            withCredentials: this.withCredentials
                        }, (a, o) => {
                            if (this.request) {
                                if (t.lastRequest = Date.now(),
                                    t.resolvedUri = Sl(t.resolvedUri, o),
                                    a)
                                    return this.playlistRequestError(this.request, t, s);
                                this.haveMetadata({
                                    playlistString: o.responseText,
                                    url: t.uri,
                                    id: t.id
                                }),
                                    s === "HAVE_MAIN_MANIFEST" ? this.trigger("loadedmetadata") : this.trigger("mediachange")
                            }
                        }
                        )
                }
            }
            pause() {
                this.mediaUpdateTimeout && (O.default.clearTimeout(this.mediaUpdateTimeout),
                    this.mediaUpdateTimeout = null),
                    this.stopRequest(),
                    this.state === "HAVE_NOTHING" && (this.started = !1),
                    this.state === "SWITCHING_MEDIA" ? this.media_ ? this.state = "HAVE_METADATA" : this.state = "HAVE_MAIN_MANIFEST" : this.state === "HAVE_CURRENT_METADATA" && (this.state = "HAVE_METADATA")
            }
            load(t) {
                this.mediaUpdateTimeout && (O.default.clearTimeout(this.mediaUpdateTimeout),
                    this.mediaUpdateTimeout = null);
                const e = this.media();
                if (t) {
                    const s = e ? (e.partTargetDuration || e.targetDuration) / 2 * 1e3 : 5e3;
                    this.mediaUpdateTimeout = O.default.setTimeout(() => {
                        this.mediaUpdateTimeout = null,
                            this.load()
                    }
                        , s);
                    return
                }
                if (!this.started) {
                    this.start();
                    return
                }
                e && !e.endList ? this.trigger("mediaupdatetimeout") : this.trigger("loadedplaylist")
            }
            updateMediaUpdateTimeout_(t) {
                this.mediaUpdateTimeout && (O.default.clearTimeout(this.mediaUpdateTimeout),
                    this.mediaUpdateTimeout = null),
                    !(!this.media() || this.media().endList) && (this.mediaUpdateTimeout = O.default.setTimeout(() => {
                        this.mediaUpdateTimeout = null,
                            this.trigger("mediaupdatetimeout"),
                            this.updateMediaUpdateTimeout_(t)
                    }
                        , t))
            }
            start() {
                if (this.started = !0,
                    typeof this.src == "object") {
                    this.src.uri || (this.src.uri = O.default.location.href),
                        this.src.resolvedUri = this.src.uri,
                        setTimeout(() => {
                            this.setupInitialPlaylist(this.src)
                        }
                            , 0);
                    return
                }
                this.request = this.vhs_.xhr({
                    uri: this.src,
                    withCredentials: this.withCredentials
                }, (t, e) => {
                    if (!this.request)
                        return;
                    if (this.request = null,
                        t)
                        return this.error = {
                            status: e.status,
                            message: `HLS playlist request error at URL: ${this.src}.`,
                            responseText: e.responseText,
                            code: 2
                        },
                            this.state === "HAVE_NOTHING" && (this.started = !1),
                            this.trigger("error");
                    this.src = Sl(this.src, e);
                    const s = this.parseManifest_({
                        manifestString: e.responseText,
                        url: this.src
                    });
                    this.setupInitialPlaylist(s)
                }
                )
            }
            srcUri() {
                return typeof this.src == "string" ? this.src : this.src.uri
            }
            setupInitialPlaylist(t) {
                if (this.state = "HAVE_MAIN_MANIFEST",
                    t.playlists) {
                    this.main = t,
                        om(this.main, this.srcUri()),
                        t.playlists.forEach(s => {
                            s.segments = hm(s),
                                s.segments.forEach(r => {
                                    um(r, s.resolvedUri)
                                }
                                )
                        }
                        ),
                        this.trigger("loadedplaylist"),
                        this.request || this.media(this.main.playlists[0]);
                    return
                }
                const e = this.srcUri() || O.default.location.href;
                this.main = l2(t, e),
                    this.haveMetadata({
                        playlistObject: t,
                        url: e,
                        id: this.main.playlists[0].id
                    }),
                    this.trigger("loadedmetadata")
            }
            updateOrDeleteClone(t, e) {
                const s = this.main
                    , r = t.ID;
                let n = s.playlists.length;
                for (; n--;) {
                    const a = s.playlists[n];
                    if (a.attributes["PATHWAY-ID"] === r) {
                        const o = a.resolvedUri
                            , u = a.id;
                        if (e) {
                            const c = this.createCloneURI_(a.resolvedUri, t)
                                , f = Sn(r, c)
                                , v = this.createCloneAttributes_(r, a.attributes)
                                , T = this.createClonePlaylist_(a, f, t, v);
                            s.playlists[n] = T,
                                s.playlists[f] = T,
                                s.playlists[c] = T
                        } else
                            s.playlists.splice(n, 1);
                        delete s.playlists[u],
                            delete s.playlists[o]
                    }
                }
                this.updateOrDeleteCloneMedia(t, e)
            }
            updateOrDeleteCloneMedia(t, e) {
                const s = this.main
                    , r = t.ID;
                ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(n => {
                    if (!(!s.mediaGroups[n] || !s.mediaGroups[n][r])) {
                        for (const a in s.mediaGroups[n])
                            if (a === r) {
                                for (const o in s.mediaGroups[n][a])
                                    s.mediaGroups[n][a][o].playlists.forEach((c, f) => {
                                        const v = s.playlists[c.id]
                                            , T = v.id
                                            , D = v.resolvedUri;
                                        delete s.playlists[T],
                                            delete s.playlists[D]
                                    }
                                    );
                                delete s.mediaGroups[n][a]
                            }
                    }
                }
                ),
                    e && this.createClonedMediaGroups_(t)
            }
            addClonePathway(t, e = {}) {
                const s = this.main
                    , r = s.playlists.length
                    , n = this.createCloneURI_(e.resolvedUri, t)
                    , a = Sn(t.ID, n)
                    , o = this.createCloneAttributes_(t.ID, e.attributes)
                    , u = this.createClonePlaylist_(e, a, t, o);
                s.playlists[r] = u,
                    s.playlists[a] = u,
                    s.playlists[n] = u,
                    this.createClonedMediaGroups_(t)
            }
            createClonedMediaGroups_(t) {
                const e = t.ID
                    , s = t["BASE-ID"]
                    , r = this.main;
                ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(n => {
                    if (!(!r.mediaGroups[n] || r.mediaGroups[n][e]))
                        for (const a in r.mediaGroups[n]) {
                            if (a === s)
                                r.mediaGroups[n][e] = {};
                            else
                                continue;
                            for (const o in r.mediaGroups[n][a]) {
                                const u = r.mediaGroups[n][a][o];
                                r.mediaGroups[n][e][o] = Pi({}, u);
                                const c = r.mediaGroups[n][e][o]
                                    , f = this.createCloneURI_(u.resolvedUri, t);
                                c.resolvedUri = f,
                                    c.uri = f,
                                    c.playlists = [],
                                    u.playlists.forEach((v, T) => {
                                        const D = r.playlists[v.id]
                                            , _ = nm(n, e, o)
                                            , L = Sn(e, _);
                                        if (D && !r.playlists[L]) {
                                            const M = this.createClonePlaylist_(D, L, t)
                                                , N = M.resolvedUri;
                                            r.playlists[L] = M,
                                                r.playlists[N] = M
                                        }
                                        c.playlists[T] = this.createClonePlaylist_(v, L, t)
                                    }
                                    )
                            }
                        }
                }
                )
            }
            createClonePlaylist_(t, e, s, r) {
                const n = this.createCloneURI_(t.resolvedUri, s)
                    , a = {
                        resolvedUri: n,
                        uri: n,
                        id: e
                    };
                return t.segments && (a.segments = []),
                    r && (a.attributes = r),
                    Re(t, a)
            }
            createCloneURI_(t, e) {
                const s = new URL(t);
                s.hostname = e["URI-REPLACEMENT"].HOST;
                const r = e["URI-REPLACEMENT"].PARAMS;
                for (const n of Object.keys(r))
                    s.searchParams.set(n, r[n]);
                return s.href
            }
            createCloneAttributes_(t, e) {
                const s = {
                    "PATHWAY-ID": t
                };
                return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(r => {
                    e[r] && (s[r] = t)
                }
                ),
                    s
            }
            getKeyIdSet(t) {
                if (t.contentProtection) {
                    const e = new Set;
                    for (const s in t.contentProtection) {
                        const r = t.contentProtection[s].attributes.keyId;
                        r && e.add(r)
                    }
                    return e
                }
            }
        }
        , { xhr: f2 } = U
        , Cd = function (t, e, s, r) {
            const n = t.responseType === "arraybuffer" ? t.response : t.responseText;
            !e && n && (t.responseTime = Date.now(),
                t.roundTripTime = t.responseTime - t.requestTime,
                t.bytesReceived = n.byteLength || n.length,
                t.bandwidth || (t.bandwidth = Math.floor(t.bytesReceived / t.roundTripTime * 8 * 1e3))),
                s.headers && (t.responseHeaders = s.headers),
                e && e.code === "ETIMEDOUT" && (t.timedout = !0),
                !e && !t.aborted && s.statusCode !== 200 && s.statusCode !== 206 && s.statusCode !== 0 && (e = new Error("XHR Failed with a response of: " + (t && (n || t.responseText)))),
                r(e, t)
        }
        , p2 = (t, e) => {
            if (!t || !t.size)
                return;
            let s = e;
            return t.forEach(r => {
                s = r(s)
            }
            ),
                s
        }
        , m2 = (t, e, s, r) => {
            !t || !t.size || t.forEach(n => {
                n(e, s, r)
            }
            )
        }
        , cm = function () {
            const t = function e(s, r) {
                s = Re({
                    timeout: 45e3
                }, s);
                const n = e.beforeRequest || U.Vhs.xhr.beforeRequest
                    , a = e._requestCallbackSet || U.Vhs.xhr._requestCallbackSet || new Set
                    , o = e._responseCallbackSet || U.Vhs.xhr._responseCallbackSet;
                n && typeof n == "function" && (U.log.warn("beforeRequest is deprecated, use onRequest instead."),
                    a.add(n));
                const u = U.Vhs.xhr.original === !0 ? f2 : U.Vhs.xhr
                    , c = p2(a, s);
                a.delete(n);
                const f = u(c || s, function (T, D) {
                    return m2(o, f, T, D),
                        Cd(f, T, D, r)
                })
                    , v = f.abort;
                return f.abort = function () {
                    return f.aborted = !0,
                        v.apply(f, arguments)
                }
                    ,
                    f.uri = s.uri,
                    f.requestTime = Date.now(),
                    f
            };
            return t.original = !0,
                t
        }
        , g2 = function (t) {
            let e;
            const s = t.offset;
            return typeof t.offset == "bigint" || typeof t.length == "bigint" ? e = O.default.BigInt(t.offset) + O.default.BigInt(t.length) - O.default.BigInt(1) : e = t.offset + t.length - 1,
                "bytes=" + s + "-" + e
        }
        , Ad = function (t) {
            const e = {};
            return t.byterange && (e.Range = g2(t.byterange)),
                e
        }
        , v2 = function (t, e) {
            return t.start(e) + "-" + t.end(e)
        }
        , y2 = function (t, e) {
            const s = t.toString(16);
            return "00".substring(0, 2 - s.length) + s + (e % 2 ? " " : "")
        }
        , _2 = function (t) {
            return t >= 32 && t < 126 ? String.fromCharCode(t) : "."
        }
        , fm = function (t) {
            const e = {};
            return Object.keys(t).forEach(s => {
                const r = t[s];
                Bc(r) ? e[s] = {
                    bytes: r.buffer,
                    byteOffset: r.byteOffset,
                    byteLength: r.byteLength
                } : e[s] = r
            }
            ),
                e
        }
        , wl = function (t) {
            const e = t.byterange || {
                length: 1 / 0,
                offset: 0
            };
            return [e.length, e.offset, t.resolvedUri].join(",")
        }
        , pm = function (t) {
            return t.resolvedUri
        }
        , mm = t => {
            const e = Array.prototype.slice.call(t)
                , s = 16;
            let r = "", n, a;
            for (let o = 0; o < e.length / s; o++)
                n = e.slice(o * s, o * s + s).map(y2).join(""),
                    a = e.slice(o * s, o * s + s).map(_2).join(""),
                    r += n + " " + a + `
`;
            return r
        }
        , T2 = ({ bytes: t }) => mm(t)
        , b2 = t => {
            let e = "", s;
            for (s = 0; s < t.length; s++)
                e += v2(t, s) + " ";
            return e
        }
        , E2 = Object.freeze({
            __proto__: null,
            createTransferableMessage: fm,
            initSegmentId: wl,
            segmentKeyId: pm,
            hexDump: mm,
            tagDump: T2,
            textRanges: b2
        })
        , gm = .25
        , S2 = (t, e) => {
            if (!e.dateTimeObject)
                return null;
            const s = e.videoTimingInfo.transmuxerPrependedSeconds
                , n = e.videoTimingInfo.transmuxedPresentationStart + s
                , a = t - n;
            return new Date(e.dateTimeObject.getTime() + a * 1e3)
        }
        , C2 = t => t.transmuxedPresentationEnd - t.transmuxedPresentationStart - t.transmuxerPrependedSeconds
        , A2 = (t, e) => {
            let s;
            try {
                s = new Date(t)
            } catch (c) {
                return null
            }
            if (!e || !e.segments || e.segments.length === 0)
                return null;
            let r = e.segments[0];
            if (s < new Date(r.dateTimeObject))
                return null;
            for (let c = 0; c < e.segments.length - 1; c++) {
                r = e.segments[c];
                const f = new Date(e.segments[c + 1].dateTimeObject);
                if (s < f)
                    break
            }
            const n = e.segments[e.segments.length - 1]
                , a = n.dateTimeObject
                , o = n.videoTimingInfo ? C2(n.videoTimingInfo) : n.duration + n.duration * gm
                , u = new Date(a.getTime() + o * 1e3);
            return s > u ? null : (s > new Date(a) && (r = n),
            {
                segment: r,
                estimatedStart: r.videoTimingInfo ? r.videoTimingInfo.transmuxedPresentationStart : si.duration(e, e.mediaSequence + e.segments.indexOf(r)),
                type: r.videoTimingInfo ? "accurate" : "estimate"
            })
        }
        , w2 = (t, e) => {
            if (!e || !e.segments || e.segments.length === 0)
                return null;
            let s = 0, r;
            for (let a = 0; a < e.segments.length && (r = e.segments[a],
                s = r.videoTimingInfo ? r.videoTimingInfo.transmuxedPresentationEnd : s + r.duration,
                !(t <= s)); a++)
                ;
            const n = e.segments[e.segments.length - 1];
            if (n.videoTimingInfo && n.videoTimingInfo.transmuxedPresentationEnd < t)
                return null;
            if (t > s) {
                if (t > s + n.duration * gm)
                    return null;
                r = n
            }
            return {
                segment: r,
                estimatedStart: r.videoTimingInfo ? r.videoTimingInfo.transmuxedPresentationStart : s - r.duration,
                type: r.videoTimingInfo ? "accurate" : "estimate"
            }
        }
        , D2 = (t, e) => {
            let s, r;
            try {
                s = new Date(t),
                    r = new Date(e)
            } catch (o) { }
            const n = s.getTime();
            return (r.getTime() - n) / 1e3
        }
        , k2 = t => {
            if (!t.segments || t.segments.length === 0)
                return !1;
            for (let e = 0; e < t.segments.length; e++)
                if (!t.segments[e].dateTimeObject)
                    return !1;
            return !0
        }
        , x2 = ({ playlist: t, time: e = void 0, callback: s }) => {
            if (!s)
                throw new Error("getProgramTime: callback must be provided");
            if (!t || e === void 0)
                return s({
                    message: "getProgramTime: playlist and time must be provided"
                });
            const r = w2(e, t);
            if (!r)
                return s({
                    message: "valid programTime was not found"
                });
            if (r.type === "estimate")
                return s({
                    message: "Accurate programTime could not be determined. Please seek to e.seekTime and try again",
                    seekTime: r.estimatedStart
                });
            const n = {
                mediaSeconds: e
            }
                , a = S2(e, r.segment);
            return a && (n.programDateTime = a.toISOString()),
                s(null, n)
        }
        , vm = ({ programTime: t, playlist: e, retryCount: s = 2, seekTo: r, pauseAfterSeek: n = !0, tech: a, callback: o }) => {
            if (!o)
                throw new Error("seekToProgramTime: callback must be provided");
            if (typeof t > "u" || !e || !r)
                return o({
                    message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
                });
            if (!e.endList && !a.hasStarted_)
                return o({
                    message: "player must be playing a live stream to start buffering"
                });
            if (!k2(e))
                return o({
                    message: "programDateTime tags must be provided in the manifest " + e.resolvedUri
                });
            const u = A2(t, e);
            if (!u)
                return o({
                    message: `${t} was not found in the stream`
                });
            const c = u.segment
                , f = D2(c.dateTimeObject, t);
            if (u.type === "estimate") {
                if (s === 0)
                    return o({
                        message: `${t} is not buffered yet. Try again`
                    });
                r(u.estimatedStart + f),
                    a.one("seeked", () => {
                        vm({
                            programTime: t,
                            playlist: e,
                            retryCount: s - 1,
                            seekTo: r,
                            pauseAfterSeek: n,
                            tech: a,
                            callback: o
                        })
                    }
                    );
                return
            }
            const v = c.start + f
                , T = () => o(null, a.currentTime());
            a.one("seeked", T),
                n && a.pause(),
                r(v)
        }
        , wd = (t, e) => {
            if (t.readyState === 4)
                return e()
        }
        , I2 = (t, e, s) => {
            let r = [], n, a = !1;
            const o = function (v, T, D, _) {
                return T.abort(),
                    a = !0,
                    s(v, T, D, _)
            }
                , u = function (v, T) {
                    if (a)
                        return;
                    if (v)
                        return o(v, T, "", r);
                    const D = T.responseText.substring(r && r.byteLength || 0, T.responseText.length);
                    if (r = d_(r, Fc(D, !0)),
                        n = n || ya(r),
                        r.length < 10 || n && r.length < n + 2)
                        return wd(T, () => o(v, T, "", r));
                    const _ = bh(r);
                    return _ === "ts" && r.length < 188 ? wd(T, () => o(v, T, "", r)) : !_ && r.length < 376 ? wd(T, () => o(v, T, "", r)) : o(null, T, _, r)
                }
                , f = e({
                    uri: t,
                    beforeSend(v) {
                        v.overrideMimeType("text/plain; charset=x-user-defined"),
                            v.addEventListener("progress", function ({ total: T, loaded: D }) {
                                return Cd(v, null, {
                                    statusCode: v.status
                                }, u)
                            })
                    }
                }, function (v, T) {
                    return Cd(f, v, T, u)
                });
            return f
        }
        , { EventTarget: P2 } = U
        , ym = function (t, e) {
            if (!dm(t, e) || t.sidx && e.sidx && (t.sidx.offset !== e.sidx.offset || t.sidx.length !== e.sidx.length))
                return !1;
            if (!t.sidx && e.sidx || t.sidx && !e.sidx || t.segments && !e.segments || !t.segments && e.segments)
                return !1;
            if (!t.segments && !e.segments)
                return !0;
            for (let s = 0; s < t.segments.length; s++) {
                const r = t.segments[s]
                    , n = e.segments[s];
                if (r.uri !== n.uri)
                    return !1;
                if (!r.byterange && !n.byterange)
                    continue;
                const a = r.byterange
                    , o = n.byterange;
                if (a && !o || !a && o || a.offset !== o.offset || a.length !== o.length)
                    return !1
            }
            return !0
        }
        , L2 = (t, e, s, r) => {
            const n = r.attributes.NAME || s;
            return `placeholder-uri-${t}-${e}-${n}`
        }
        , O2 = ({ mainXml: t, srcUrl: e, clientOffset: s, sidxMapping: r, previousManifest: n }) => {
            const a = o0(t, {
                manifestUri: e,
                clientOffset: s,
                sidxMapping: r,
                previousManifest: n
            });
            return om(a, e, L2),
                a
        }
        , M2 = (t, e) => {
            Cn(t, (s, r, n, a) => {
                a in e.mediaGroups[r][n] || delete t.mediaGroups[r][n][a]
            }
            )
        }
        , R2 = (t, e, s) => {
            let r = !0
                , n = Re(t, {
                    duration: e.duration,
                    minimumUpdatePeriod: e.minimumUpdatePeriod,
                    timelineStarts: e.timelineStarts
                });
            for (let a = 0; a < e.playlists.length; a++) {
                const o = e.playlists[a];
                if (o.sidx) {
                    const c = qo(o.sidx);
                    s && s[c] && s[c].sidx && ph(o, s[c].sidx, o.sidx.resolvedUri)
                }
                const u = Ed(n, o, ym);
                u && (n = u,
                    r = !1)
            }
            return Cn(e, (a, o, u, c) => {
                if (a.playlists && a.playlists.length) {
                    const f = a.playlists[0].id
                        , v = Ed(n, a.playlists[0], ym);
                    v && (n = v,
                        c in n.mediaGroups[o][u] || (n.mediaGroups[o][u][c] = a),
                        n.mediaGroups[o][u][c].playlists[0] = n.playlists[f],
                        r = !1)
                }
            }
            ),
                M2(n, e),
                e.minimumUpdatePeriod !== t.minimumUpdatePeriod && (r = !1),
                r ? null : n
        }
        , N2 = (t, e) => (!t.map && !e.map || !!(t.map && e.map && t.map.byterange.offset === e.map.byterange.offset && t.map.byterange.length === e.map.byterange.length)) && t.uri === e.uri && t.byterange.offset === e.byterange.offset && t.byterange.length === e.byterange.length
        , _m = (t, e) => {
            const s = {};
            for (const r in t) {
                const a = t[r].sidx;
                if (a) {
                    const o = qo(a);
                    if (!e[o])
                        break;
                    const u = e[o].sidxInfo;
                    N2(u, a) && (s[o] = e[o])
                }
            }
            return s
        }
        , B2 = (t, e) => {
            let r = _m(t.playlists, e);
            return Cn(t, (n, a, o, u) => {
                if (n.playlists && n.playlists.length) {
                    const c = n.playlists;
                    r = Re(r, _m(c, e))
                }
            }
            ),
                r
        }
        , Dd = class extends P2 {
            constructor(t, e, s = {}, r) {
                super(),
                    this.mainPlaylistLoader_ = r || this,
                    r || (this.isMain_ = !0);
                const { withCredentials: n = !1 } = s;
                if (this.vhs_ = e,
                    this.withCredentials = n,
                    this.addMetadataToTextTrack = s.addMetadataToTextTrack,
                    !t)
                    throw new Error("A non-empty playlist URL or object is required");
                this.on("minimumUpdatePeriod", () => {
                    this.refreshXml_()
                }
                ),
                    this.on("mediaupdatetimeout", () => {
                        this.refreshMedia_(this.media().id)
                    }
                    ),
                    this.state = "HAVE_NOTHING",
                    this.loadedPlaylists_ = {},
                    this.logger_ = Ci("DashPlaylistLoader"),
                    this.isMain_ ? (this.mainPlaylistLoader_.srcUrl = t,
                        this.mainPlaylistLoader_.sidxMapping_ = {}) : this.childPlaylist_ = t
            }
            requestErrored_(t, e, s) {
                if (!this.request)
                    return !0;
                if (this.request = null,
                    t)
                    return this.error = typeof t == "object" && !(t instanceof Error) ? t : {
                        status: e.status,
                        message: "DASH request error at URL: " + e.uri,
                        response: e.response,
                        code: 2
                    },
                        s && (this.state = s),
                        this.trigger("error"),
                        !0
            }
            addSidxSegments_(t, e, s) {
                const r = t.sidx && qo(t.sidx);
                if (!t.sidx || !r || this.mainPlaylistLoader_.sidxMapping_[r]) {
                    this.mediaRequest_ = O.default.setTimeout(() => s(!1), 0);
                    return
                }
                const n = Sl(t.sidx.resolvedUri)
                    , a = (o, u) => {
                        if (this.requestErrored_(o, u, e))
                            return;
                        const c = this.mainPlaylistLoader_.sidxMapping_;
                        let f;
                        try {
                            f = (0,
                                u0.default)(ye(u.response).subarray(8))
                        } catch (v) {
                            this.requestErrored_(v, u, e);
                            return
                        }
                        return c[r] = {
                            sidxInfo: t.sidx,
                            sidx: f
                        },
                            ph(t, f, t.sidx.resolvedUri),
                            s(!0)
                    }
                    ;
                this.request = I2(n, this.vhs_.xhr, (o, u, c, f) => {
                    if (o)
                        return a(o, u);
                    if (!c || c !== "mp4")
                        return a({
                            status: u.status,
                            message: `Unsupported ${c || "unknown"} container type for sidx segment at URL: ${n}`,
                            response: "",
                            playlist: t,
                            internal: !0,
                            playlistExclusionDuration: 1 / 0,
                            code: 2
                        }, u);
                    const { offset: v, length: T } = t.sidx.byterange;
                    if (f.length >= T + v)
                        return a(o, {
                            response: f.subarray(v, v + T),
                            status: u.status,
                            uri: u.uri
                        });
                    this.request = this.vhs_.xhr({
                        uri: n,
                        responseType: "arraybuffer",
                        headers: Ad({
                            byterange: t.sidx.byterange
                        })
                    }, a)
                }
                )
            }
            dispose() {
                this.trigger("dispose"),
                    this.stopRequest(),
                    this.loadedPlaylists_ = {},
                    O.default.clearTimeout(this.minimumUpdatePeriodTimeout_),
                    O.default.clearTimeout(this.mediaRequest_),
                    O.default.clearTimeout(this.mediaUpdateTimeout),
                    this.mediaUpdateTimeout = null,
                    this.mediaRequest_ = null,
                    this.minimumUpdatePeriodTimeout_ = null,
                    this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_),
                        this.mainPlaylistLoader_.createMupOnMedia_ = null),
                    this.off()
            }
            hasPendingRequest() {
                return this.request || this.mediaRequest_
            }
            stopRequest() {
                if (this.request) {
                    const t = this.request;
                    this.request = null,
                        t.onreadystatechange = null,
                        t.abort()
                }
            }
            media(t) {
                if (!t)
                    return this.media_;
                if (this.state === "HAVE_NOTHING")
                    throw new Error("Cannot switch media playlist from " + this.state);
                const e = this.state;
                if (typeof t == "string") {
                    if (!this.mainPlaylistLoader_.main.playlists[t])
                        throw new Error("Unknown playlist URI: " + t);
                    t = this.mainPlaylistLoader_.main.playlists[t]
                }
                const s = !this.media_ || t.id !== this.media_.id;
                if (s && this.loadedPlaylists_[t.id] && this.loadedPlaylists_[t.id].endList) {
                    this.state = "HAVE_METADATA",
                        this.media_ = t,
                        s && (this.trigger("mediachanging"),
                            this.trigger("mediachange"));
                    return
                }
                s && (this.media_ && this.trigger("mediachanging"),
                    this.addSidxSegments_(t, e, r => {
                        this.haveMetadata({
                            startingState: e,
                            playlist: t
                        })
                    }
                    ))
            }
            haveMetadata({ startingState: t, playlist: e }) {
                this.state = "HAVE_METADATA",
                    this.loadedPlaylists_[e.id] = e,
                    this.mediaRequest_ = null,
                    this.refreshMedia_(e.id),
                    t === "HAVE_MAIN_MANIFEST" ? this.trigger("loadedmetadata") : this.trigger("mediachange")
            }
            pause() {
                this.mainPlaylistLoader_.createMupOnMedia_ && (this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_),
                    this.mainPlaylistLoader_.createMupOnMedia_ = null),
                    this.stopRequest(),
                    O.default.clearTimeout(this.mediaUpdateTimeout),
                    this.mediaUpdateTimeout = null,
                    this.isMain_ && (O.default.clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_),
                        this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null),
                    this.state === "HAVE_NOTHING" && (this.started = !1)
            }
            load(t) {
                O.default.clearTimeout(this.mediaUpdateTimeout),
                    this.mediaUpdateTimeout = null;
                const e = this.media();
                if (t) {
                    const s = e ? e.targetDuration / 2 * 1e3 : 5e3;
                    this.mediaUpdateTimeout = O.default.setTimeout(() => this.load(), s);
                    return
                }
                if (!this.started) {
                    this.start();
                    return
                }
                e && !e.endList ? (this.isMain_ && !this.minimumUpdatePeriodTimeout_ && (this.trigger("minimumUpdatePeriod"),
                    this.updateMinimumUpdatePeriodTimeout_()),
                    this.trigger("mediaupdatetimeout")) : this.trigger("loadedplaylist")
            }
            start() {
                if (this.started = !0,
                    !this.isMain_) {
                    this.mediaRequest_ = O.default.setTimeout(() => this.haveMain_(), 0);
                    return
                }
                this.requestMain_((t, e) => {
                    this.haveMain_(),
                        !this.hasPendingRequest() && !this.media_ && this.media(this.mainPlaylistLoader_.main.playlists[0])
                }
                )
            }
            requestMain_(t) {
                this.request = this.vhs_.xhr({
                    uri: this.mainPlaylistLoader_.srcUrl,
                    withCredentials: this.withCredentials
                }, (e, s) => {
                    if (this.requestErrored_(e, s)) {
                        this.state === "HAVE_NOTHING" && (this.started = !1);
                        return
                    }
                    const r = s.responseText !== this.mainPlaylistLoader_.mainXml_;
                    if (this.mainPlaylistLoader_.mainXml_ = s.responseText,
                        s.responseHeaders && s.responseHeaders.date ? this.mainLoaded_ = Date.parse(s.responseHeaders.date) : this.mainLoaded_ = Date.now(),
                        this.mainPlaylistLoader_.srcUrl = Sl(this.mainPlaylistLoader_.srcUrl, s),
                        r) {
                        this.handleMain_(),
                            this.syncClientServerClock_(() => t(s, r));
                        return
                    }
                    return t(s, r)
                }
                )
            }
            syncClientServerClock_(t) {
                const e = l0(this.mainPlaylistLoader_.mainXml_);
                if (e === null)
                    return this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(),
                        t();
                if (e.method === "DIRECT")
                    return this.mainPlaylistLoader_.clientOffset_ = e.value - Date.now(),
                        t();
                this.request = this.vhs_.xhr({
                    uri: ii(this.mainPlaylistLoader_.srcUrl, e.value),
                    method: e.method,
                    withCredentials: this.withCredentials
                }, (s, r) => {
                    if (!this.request)
                        return;
                    if (s)
                        return this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now(),
                            t();
                    let n;
                    e.method === "HEAD" ? !r.responseHeaders || !r.responseHeaders.date ? n = this.mainLoaded_ : n = Date.parse(r.responseHeaders.date) : n = Date.parse(r.responseText),
                        this.mainPlaylistLoader_.clientOffset_ = n - Date.now(),
                        t()
                }
                )
            }
            haveMain_() {
                this.state = "HAVE_MAIN_MANIFEST",
                    this.isMain_ ? this.trigger("loadedplaylist") : this.media_ || this.media(this.childPlaylist_)
            }
            handleMain_() {
                this.mediaRequest_ = null;
                const t = this.mainPlaylistLoader_.main;
                let e = O2({
                    mainXml: this.mainPlaylistLoader_.mainXml_,
                    srcUrl: this.mainPlaylistLoader_.srcUrl,
                    clientOffset: this.mainPlaylistLoader_.clientOffset_,
                    sidxMapping: this.mainPlaylistLoader_.sidxMapping_,
                    previousManifest: t
                });
                t && (e = R2(t, e, this.mainPlaylistLoader_.sidxMapping_)),
                    this.mainPlaylistLoader_.main = e || t;
                const s = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];
                return s && s !== this.mainPlaylistLoader_.srcUrl && (this.mainPlaylistLoader_.srcUrl = s),
                    (!t || e && e.minimumUpdatePeriod !== t.minimumUpdatePeriod) && this.updateMinimumUpdatePeriodTimeout_(),
                    this.addEventStreamToMetadataTrack_(e),
                    !!e
            }
            updateMinimumUpdatePeriodTimeout_() {
                const t = this.mainPlaylistLoader_;
                t.createMupOnMedia_ && (t.off("loadedmetadata", t.createMupOnMedia_),
                    t.createMupOnMedia_ = null),
                    t.minimumUpdatePeriodTimeout_ && (O.default.clearTimeout(t.minimumUpdatePeriodTimeout_),
                        t.minimumUpdatePeriodTimeout_ = null);
                let e = t.main && t.main.minimumUpdatePeriod;
                if (e === 0 && (t.media() ? e = t.media().targetDuration * 1e3 : (t.createMupOnMedia_ = t.updateMinimumUpdatePeriodTimeout_,
                    t.one("loadedmetadata", t.createMupOnMedia_))),
                    typeof e != "number" || e <= 0) {
                    e < 0 && this.logger_(`found invalid minimumUpdatePeriod of ${e}, not setting a timeout`);
                    return
                }
                this.createMUPTimeout_(e)
            }
            createMUPTimeout_(t) {
                const e = this.mainPlaylistLoader_;
                e.minimumUpdatePeriodTimeout_ = O.default.setTimeout(() => {
                    e.minimumUpdatePeriodTimeout_ = null,
                        e.trigger("minimumUpdatePeriod"),
                        e.createMUPTimeout_(t)
                }
                    , t)
            }
            refreshXml_() {
                this.requestMain_((t, e) => {
                    e && (this.media_ && (this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id]),
                        this.mainPlaylistLoader_.sidxMapping_ = B2(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_),
                        this.addSidxSegments_(this.media(), this.state, s => {
                            this.refreshMedia_(this.media().id)
                        }
                        ))
                }
                )
            }
            refreshMedia_(t) {
                if (!t)
                    throw new Error("refreshMedia_ must take a media id");
                this.media_ && this.isMain_ && this.handleMain_();
                const e = this.mainPlaylistLoader_.main.playlists
                    , s = !this.media_ || this.media_ !== e[t];
                if (s ? this.media_ = e[t] : this.trigger("playlistunchanged"),
                    !this.mediaUpdateTimeout) {
                    const r = () => {
                        this.media().endList || (this.mediaUpdateTimeout = O.default.setTimeout(() => {
                            this.trigger("mediaupdatetimeout"),
                                r()
                        }
                            , Sd(this.media(), !!s)))
                    }
                        ;
                    r()
                }
                this.trigger("loadedplaylist")
            }
            addEventStreamToMetadataTrack_(t) {
                if (t && this.mainPlaylistLoader_.main.eventStream) {
                    const e = this.mainPlaylistLoader_.main.eventStream.map(s => ({
                        cueTime: s.start,
                        frames: [{
                            data: s.messageData
                        }]
                    }));
                    this.addMetadataToTextTrack("EventStream", e, this.mainPlaylistLoader_.main.duration)
                }
            }
            getKeyIdSet(t) {
                if (t.contentProtection) {
                    const e = new Set;
                    for (const s in t.contentProtection) {
                        const r = t.contentProtection[s].attributes["cenc:default_KID"];
                        r && e.add(r.replace(/-/g, ""))
                    }
                    return e
                }
            }
        }
        , mt = {
            GOAL_BUFFER_LENGTH: 30,
            MAX_GOAL_BUFFER_LENGTH: 60,
            BACK_BUFFER_LENGTH: 30,
            GOAL_BUFFER_LENGTH_RATE: 1,
            INITIAL_BANDWIDTH: 4194304,
            BANDWIDTH_VARIANCE: 1.2,
            BUFFER_LOW_WATER_LINE: 0,
            MAX_BUFFER_LOW_WATER_LINE: 30,
            EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
            BUFFER_LOW_WATER_LINE_RATE: 1,
            BUFFER_HIGH_WATER_LINE: 30
        }
        , F2 = t => {
            const e = new Uint8Array(new ArrayBuffer(t.length));
            for (let s = 0; s < t.length; s++)
                e[s] = t.charCodeAt(s);
            return e.buffer
        }
        , Tm = function (t) {
            return t.on = t.addEventListener,
                t.off = t.removeEventListener,
                t
        }
        , U2 = function (t) {
            try {
                return URL.createObjectURL(new Blob([t], {
                    type: "application/javascript"
                }))
            } catch (e) {
                const s = new BlobBuilder;
                return s.append(t),
                    URL.createObjectURL(s.getBlob())
            }
        }
        , bm = function (t) {
            return function () {
                const e = U2(t)
                    , s = Tm(new Worker(e));
                s.objURL = e;
                const r = s.terminate;
                return s.on = s.addEventListener,
                    s.off = s.removeEventListener,
                    s.terminate = function () {
                        return URL.revokeObjectURL(e),
                            r.call(this)
                    }
                    ,
                    s
            }
        }
        , Em = function (t) {
            return `var browserWorkerPolyFill = ${Tm.toString()};
browserWorkerPolyFill(self);
` + t
        }
        , Sm = function (t) {
            return t.toString().replace(/^function.+?{/, "").slice(0, -1)
        }
        , j2 = Em(Sm(function () {
            var t = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
                , e = function () {
                    this.init = function () {
                        var l = {};
                        this.on = function (d, m) {
                            l[d] || (l[d] = []),
                                l[d] = l[d].concat(m)
                        }
                            ,
                            this.off = function (d, m) {
                                var p;
                                return l[d] ? (p = l[d].indexOf(m),
                                    l[d] = l[d].slice(),
                                    l[d].splice(p, 1),
                                    p > -1) : !1
                            }
                            ,
                            this.trigger = function (d) {
                                var m, p, g, y;
                                if (m = l[d],
                                    !!m)
                                    if (arguments.length === 2)
                                        for (g = m.length,
                                            p = 0; p < g; ++p)
                                            m[p].call(this, arguments[1]);
                                    else {
                                        for (y = [],
                                            p = arguments.length,
                                            p = 1; p < arguments.length; ++p)
                                            y.push(arguments[p]);
                                        for (g = m.length,
                                            p = 0; p < g; ++p)
                                            m[p].apply(this, y)
                                    }
                            }
                            ,
                            this.dispose = function () {
                                l = {}
                            }
                    }
                };
            e.prototype.pipe = function (l) {
                return this.on("data", function (d) {
                    l.push(d)
                }),
                    this.on("done", function (d) {
                        l.flush(d)
                    }),
                    this.on("partialdone", function (d) {
                        l.partialFlush(d)
                    }),
                    this.on("endedtimeline", function (d) {
                        l.endTimeline(d)
                    }),
                    this.on("reset", function (d) {
                        l.reset(d)
                    }),
                    l
            }
                ,
                e.prototype.push = function (l) {
                    this.trigger("data", l)
                }
                ,
                e.prototype.flush = function (l) {
                    this.trigger("done", l)
                }
                ,
                e.prototype.partialFlush = function (l) {
                    this.trigger("partialdone", l)
                }
                ,
                e.prototype.endTimeline = function (l) {
                    this.trigger("endedtimeline", l)
                }
                ,
                e.prototype.reset = function (l) {
                    this.trigger("reset", l)
                }
                ;
            var s = e, r = Math.pow(2, 32), n = function (l) {
                var d = new DataView(l.buffer, l.byteOffset, l.byteLength), m;
                return d.getBigUint64 ? (m = d.getBigUint64(0),
                    m < Number.MAX_SAFE_INTEGER ? Number(m) : m) : d.getUint32(0) * r + d.getUint32(4)
            }, a = {
                getUint64: n,
                MAX_UINT32: r
            }, o = a.MAX_UINT32, u, c, f, v, T, D, _, L, M, N, x, B, z, R, F, Y, ue, de, ee, G, A, w, H, X, Z, re, he, oe, ie, ae, ce, se, ve, Me, ge, Ce;
            (function () {
                var l;
                if (H = {
                    avc1: [],
                    avcC: [],
                    btrt: [],
                    dinf: [],
                    dref: [],
                    esds: [],
                    ftyp: [],
                    hdlr: [],
                    mdat: [],
                    mdhd: [],
                    mdia: [],
                    mfhd: [],
                    minf: [],
                    moof: [],
                    moov: [],
                    mp4a: [],
                    mvex: [],
                    mvhd: [],
                    pasp: [],
                    sdtp: [],
                    smhd: [],
                    stbl: [],
                    stco: [],
                    stsc: [],
                    stsd: [],
                    stsz: [],
                    stts: [],
                    styp: [],
                    tfdt: [],
                    tfhd: [],
                    traf: [],
                    trak: [],
                    trun: [],
                    trex: [],
                    tkhd: [],
                    vmhd: []
                },
                    !(typeof Uint8Array > "u")) {
                    for (l in H)
                        H.hasOwnProperty(l) && (H[l] = [l.charCodeAt(0), l.charCodeAt(1), l.charCodeAt(2), l.charCodeAt(3)]);
                    X = new Uint8Array(["i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0)]),
                        re = new Uint8Array(["a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0)]),
                        Z = new Uint8Array([0, 0, 0, 1]),
                        he = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]),
                        oe = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]),
                        ie = {
                            video: he,
                            audio: oe
                        },
                        se = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]),
                        ce = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]),
                        ve = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]),
                        Me = ve,
                        ge = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
                        Ce = ve,
                        ae = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0])
                }
            }
            )(),
                u = function (l) {
                    var d = [], m = 0, p, g, y;
                    for (p = 1; p < arguments.length; p++)
                        d.push(arguments[p]);
                    for (p = d.length; p--;)
                        m += d[p].byteLength;
                    for (g = new Uint8Array(m + 8),
                        y = new DataView(g.buffer, g.byteOffset, g.byteLength),
                        y.setUint32(0, g.byteLength),
                        g.set(l, 4),
                        p = 0,
                        m = 8; p < d.length; p++)
                        g.set(d[p], m),
                            m += d[p].byteLength;
                    return g
                }
                ,
                c = function () {
                    return u(H.dinf, u(H.dref, se))
                }
                ,
                f = function (l) {
                    return u(H.esds, new Uint8Array([0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, l.audioobjecttype << 3 | l.samplingfrequencyindex >>> 1, l.samplingfrequencyindex << 7 | l.channelcount << 3, 6, 1, 2]))
                }
                ,
                v = function () {
                    return u(H.ftyp, X, Z, X, re)
                }
                ,
                Y = function (l) {
                    return u(H.hdlr, ie[l])
                }
                ,
                T = function (l) {
                    return u(H.mdat, l)
                }
                ,
                F = function (l) {
                    var d = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, l.duration >>> 24 & 255, l.duration >>> 16 & 255, l.duration >>> 8 & 255, l.duration & 255, 85, 196, 0, 0]);
                    return l.samplerate && (d[12] = l.samplerate >>> 24 & 255,
                        d[13] = l.samplerate >>> 16 & 255,
                        d[14] = l.samplerate >>> 8 & 255,
                        d[15] = l.samplerate & 255),
                        u(H.mdhd, d)
                }
                ,
                R = function (l) {
                    return u(H.mdia, F(l), Y(l.type), _(l))
                }
                ,
                D = function (l) {
                    return u(H.mfhd, new Uint8Array([0, 0, 0, 0, (l & 4278190080) >> 24, (l & 16711680) >> 16, (l & 65280) >> 8, l & 255]))
                }
                ,
                _ = function (l) {
                    return u(H.minf, l.type === "video" ? u(H.vmhd, ae) : u(H.smhd, ce), c(), de(l))
                }
                ,
                L = function (l, d) {
                    for (var m = [], p = d.length; p--;)
                        m[p] = G(d[p]);
                    return u.apply(null, [H.moof, D(l)].concat(m))
                }
                ,
                M = function (l) {
                    for (var d = l.length, m = []; d--;)
                        m[d] = B(l[d]);
                    return u.apply(null, [H.moov, x(4294967295)].concat(m).concat(N(l)))
                }
                ,
                N = function (l) {
                    for (var d = l.length, m = []; d--;)
                        m[d] = A(l[d]);
                    return u.apply(null, [H.mvex].concat(m))
                }
                ,
                x = function (l) {
                    var d = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (l & 4278190080) >> 24, (l & 16711680) >> 16, (l & 65280) >> 8, l & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]);
                    return u(H.mvhd, d)
                }
                ,
                ue = function (l) {
                    var d = l.samples || [], m = new Uint8Array(4 + d.length), p, g;
                    for (g = 0; g < d.length; g++)
                        p = d[g].flags,
                            m[g + 4] = p.dependsOn << 4 | p.isDependedOn << 2 | p.hasRedundancy;
                    return u(H.sdtp, m)
                }
                ,
                de = function (l) {
                    return u(H.stbl, ee(l), u(H.stts, Ce), u(H.stsc, Me), u(H.stsz, ge), u(H.stco, ve))
                }
                ,
                function () {
                    var l, d;
                    ee = function (m) {
                        return u(H.stsd, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]), m.type === "video" ? l(m) : d(m))
                    }
                        ,
                        l = function (m) {
                            var p = m.sps || [], g = m.pps || [], y = [], S = [], C, k;
                            for (C = 0; C < p.length; C++)
                                y.push((p[C].byteLength & 65280) >>> 8),
                                    y.push(p[C].byteLength & 255),
                                    y = y.concat(Array.prototype.slice.call(p[C]));
                            for (C = 0; C < g.length; C++)
                                S.push((g[C].byteLength & 65280) >>> 8),
                                    S.push(g[C].byteLength & 255),
                                    S = S.concat(Array.prototype.slice.call(g[C]));
                            if (k = [H.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (m.width & 65280) >> 8, m.width & 255, (m.height & 65280) >> 8, m.height & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), u(H.avcC, new Uint8Array([1, m.profileIdc, m.profileCompatibility, m.levelIdc, 255].concat([p.length], y, [g.length], S))), u(H.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192]))],
                                m.sarRatio) {
                                var I = m.sarRatio[0]
                                    , q = m.sarRatio[1];
                                k.push(u(H.pasp, new Uint8Array([(I & 4278190080) >> 24, (I & 16711680) >> 16, (I & 65280) >> 8, I & 255, (q & 4278190080) >> 24, (q & 16711680) >> 16, (q & 65280) >> 8, q & 255])))
                            }
                            return u.apply(null, k)
                        }
                        ,
                        d = function (m) {
                            return u(H.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (m.channelcount & 65280) >> 8, m.channelcount & 255, (m.samplesize & 65280) >> 8, m.samplesize & 255, 0, 0, 0, 0, (m.samplerate & 65280) >> 8, m.samplerate & 255, 0, 0]), f(m))
                        }
                }(),
                z = function (l) {
                    var d = new Uint8Array([0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (l.id & 4278190080) >> 24, (l.id & 16711680) >> 16, (l.id & 65280) >> 8, l.id & 255, 0, 0, 0, 0, (l.duration & 4278190080) >> 24, (l.duration & 16711680) >> 16, (l.duration & 65280) >> 8, l.duration & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (l.width & 65280) >> 8, l.width & 255, 0, 0, (l.height & 65280) >> 8, l.height & 255, 0, 0]);
                    return u(H.tkhd, d)
                }
                ,
                G = function (l) {
                    var d, m, p, g, y, S, C;
                    return d = u(H.tfhd, new Uint8Array([0, 0, 0, 58, (l.id & 4278190080) >> 24, (l.id & 16711680) >> 16, (l.id & 65280) >> 8, l.id & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])),
                        S = Math.floor(l.baseMediaDecodeTime / o),
                        C = Math.floor(l.baseMediaDecodeTime % o),
                        m = u(H.tfdt, new Uint8Array([1, 0, 0, 0, S >>> 24 & 255, S >>> 16 & 255, S >>> 8 & 255, S & 255, C >>> 24 & 255, C >>> 16 & 255, C >>> 8 & 255, C & 255])),
                        y = 32 + 20 + 8 + 16 + 8 + 8,
                        l.type === "audio" ? (p = w(l, y),
                            u(H.traf, d, m, p)) : (g = ue(l),
                                p = w(l, g.length + y),
                                u(H.traf, d, m, p, g))
                }
                ,
                B = function (l) {
                    return l.duration = l.duration || 4294967295,
                        u(H.trak, z(l), R(l))
                }
                ,
                A = function (l) {
                    var d = new Uint8Array([0, 0, 0, 0, (l.id & 4278190080) >> 24, (l.id & 16711680) >> 16, (l.id & 65280) >> 8, l.id & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]);
                    return l.type !== "video" && (d[d.length - 1] = 0),
                        u(H.trex, d)
                }
                ,
                function () {
                    var l, d, m;
                    m = function (p, g) {
                        var y = 0
                            , S = 0
                            , C = 0
                            , k = 0;
                        return p.length && (p[0].duration !== void 0 && (y = 1),
                            p[0].size !== void 0 && (S = 2),
                            p[0].flags !== void 0 && (C = 4),
                            p[0].compositionTimeOffset !== void 0 && (k = 8)),
                            [0, 0, y | S | C | k, 1, (p.length & 4278190080) >>> 24, (p.length & 16711680) >>> 16, (p.length & 65280) >>> 8, p.length & 255, (g & 4278190080) >>> 24, (g & 16711680) >>> 16, (g & 65280) >>> 8, g & 255]
                    }
                        ,
                        d = function (p, g) {
                            var y, S, C, k, I, q;
                            for (k = p.samples || [],
                                g += 8 + 12 + 16 * k.length,
                                C = m(k, g),
                                S = new Uint8Array(C.length + k.length * 16),
                                S.set(C),
                                y = C.length,
                                q = 0; q < k.length; q++)
                                I = k[q],
                                    S[y++] = (I.duration & 4278190080) >>> 24,
                                    S[y++] = (I.duration & 16711680) >>> 16,
                                    S[y++] = (I.duration & 65280) >>> 8,
                                    S[y++] = I.duration & 255,
                                    S[y++] = (I.size & 4278190080) >>> 24,
                                    S[y++] = (I.size & 16711680) >>> 16,
                                    S[y++] = (I.size & 65280) >>> 8,
                                    S[y++] = I.size & 255,
                                    S[y++] = I.flags.isLeading << 2 | I.flags.dependsOn,
                                    S[y++] = I.flags.isDependedOn << 6 | I.flags.hasRedundancy << 4 | I.flags.paddingValue << 1 | I.flags.isNonSyncSample,
                                    S[y++] = I.flags.degradationPriority & 61440,
                                    S[y++] = I.flags.degradationPriority & 15,
                                    S[y++] = (I.compositionTimeOffset & 4278190080) >>> 24,
                                    S[y++] = (I.compositionTimeOffset & 16711680) >>> 16,
                                    S[y++] = (I.compositionTimeOffset & 65280) >>> 8,
                                    S[y++] = I.compositionTimeOffset & 255;
                            return u(H.trun, S)
                        }
                        ,
                        l = function (p, g) {
                            var y, S, C, k, I, q;
                            for (k = p.samples || [],
                                g += 8 + 12 + 8 * k.length,
                                C = m(k, g),
                                y = new Uint8Array(C.length + k.length * 8),
                                y.set(C),
                                S = C.length,
                                q = 0; q < k.length; q++)
                                I = k[q],
                                    y[S++] = (I.duration & 4278190080) >>> 24,
                                    y[S++] = (I.duration & 16711680) >>> 16,
                                    y[S++] = (I.duration & 65280) >>> 8,
                                    y[S++] = I.duration & 255,
                                    y[S++] = (I.size & 4278190080) >>> 24,
                                    y[S++] = (I.size & 16711680) >>> 16,
                                    y[S++] = (I.size & 65280) >>> 8,
                                    y[S++] = I.size & 255;
                            return u(H.trun, y)
                        }
                        ,
                        w = function (p, g) {
                            return p.type === "audio" ? l(p, g) : d(p, g)
                        }
                }();
            var ke = {
                ftyp: v,
                mdat: T,
                moof: L,
                moov: M,
                initSegment: function (l) {
                    var d = v(), m = M(l), p;
                    return p = new Uint8Array(d.byteLength + m.byteLength),
                        p.set(d),
                        p.set(m, d.byteLength),
                        p
                }
            }, At = function (l) {
                var d, m, p = [], g = [];
                for (g.byteLength = 0,
                    g.nalCount = 0,
                    g.duration = 0,
                    p.byteLength = 0,
                    d = 0; d < l.length; d++)
                    m = l[d],
                        m.nalUnitType === "access_unit_delimiter_rbsp" ? (p.length && (p.duration = m.dts - p.dts,
                            g.byteLength += p.byteLength,
                            g.nalCount += p.length,
                            g.duration += p.duration,
                            g.push(p)),
                            p = [m],
                            p.byteLength = m.data.byteLength,
                            p.pts = m.pts,
                            p.dts = m.dts) : (m.nalUnitType === "slice_layer_without_partitioning_rbsp_idr" && (p.keyFrame = !0),
                                p.duration = m.dts - p.dts,
                                p.byteLength += m.data.byteLength,
                                p.push(m));
                return g.length && (!p.duration || p.duration <= 0) && (p.duration = g[g.length - 1].duration),
                    g.byteLength += p.byteLength,
                    g.nalCount += p.length,
                    g.duration += p.duration,
                    g.push(p),
                    g
            }, qe = function (l) {
                var d, m, p = [], g = [];
                for (p.byteLength = 0,
                    p.nalCount = 0,
                    p.duration = 0,
                    p.pts = l[0].pts,
                    p.dts = l[0].dts,
                    g.byteLength = 0,
                    g.nalCount = 0,
                    g.duration = 0,
                    g.pts = l[0].pts,
                    g.dts = l[0].dts,
                    d = 0; d < l.length; d++)
                    m = l[d],
                        m.keyFrame ? (p.length && (g.push(p),
                            g.byteLength += p.byteLength,
                            g.nalCount += p.nalCount,
                            g.duration += p.duration),
                            p = [m],
                            p.nalCount = m.length,
                            p.byteLength = m.byteLength,
                            p.pts = m.pts,
                            p.dts = m.dts,
                            p.duration = m.duration) : (p.duration += m.duration,
                                p.nalCount += m.length,
                                p.byteLength += m.byteLength,
                                p.push(m));
                return g.length && p.duration <= 0 && (p.duration = g[g.length - 1].duration),
                    g.byteLength += p.byteLength,
                    g.nalCount += p.nalCount,
                    g.duration += p.duration,
                    g.push(p),
                    g
            }, wt = function (l) {
                var d;
                return !l[0][0].keyFrame && l.length > 1 && (d = l.shift(),
                    l.byteLength -= d.byteLength,
                    l.nalCount -= d.nalCount,
                    l[0][0].dts = d.dts,
                    l[0][0].pts = d.pts,
                    l[0][0].duration += d.duration),
                    l
            }, $i = function () {
                return {
                    size: 0,
                    flags: {
                        isLeading: 0,
                        dependsOn: 1,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradationPriority: 0,
                        isNonSyncSample: 1
                    }
                }
            }, yi = function (l, d) {
                var m = $i();
                return m.dataOffset = d,
                    m.compositionTimeOffset = l.pts - l.dts,
                    m.duration = l.duration,
                    m.size = 4 * l.length,
                    m.size += l.byteLength,
                    l.keyFrame && (m.flags.dependsOn = 2,
                        m.flags.isNonSyncSample = 0),
                    m
            }, Fs = function (l, d) {
                var m, p, g, y, S, C = d || 0, k = [];
                for (m = 0; m < l.length; m++)
                    for (y = l[m],
                        p = 0; p < y.length; p++)
                        S = y[p],
                            g = yi(S, C),
                            C += g.size,
                            k.push(g);
                return k
            }, Pe = function (l) {
                var d, m, p, g, y, S, C = 0, k = l.byteLength, I = l.nalCount, q = k + 4 * I, K = new Uint8Array(q), fe = new DataView(K.buffer);
                for (d = 0; d < l.length; d++)
                    for (g = l[d],
                        m = 0; m < g.length; m++)
                        for (y = g[m],
                            p = 0; p < y.length; p++)
                            S = y[p],
                                fe.setUint32(C, S.data.byteLength),
                                C += 4,
                                K.set(S.data, C),
                                C += S.data.byteLength;
                return K
            }, vt = function (l, d) {
                var m, p = d || 0, g = [];
                return m = yi(l, p),
                    g.push(m),
                    g
            }, Vi = function (l) {
                var d, m, p = 0, g = l.byteLength, y = l.length, S = g + 4 * y, C = new Uint8Array(S), k = new DataView(C.buffer);
                for (d = 0; d < l.length; d++)
                    m = l[d],
                        k.setUint32(p, m.data.byteLength),
                        p += 4,
                        C.set(m.data, p),
                        p += m.data.byteLength;
                return C
            }, Ze = {
                groupNalsIntoFrames: At,
                groupFramesIntoGops: qe,
                extendFirstKeyFrame: wt,
                generateSampleTable: Fs,
                concatenateNalData: Pe,
                generateSampleTableForFrame: vt,
                concatenateNalDataForFrame: Vi
            }, _i = [33, 16, 5, 32, 164, 27], dr = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252], xe = function (l) {
                for (var d = []; l--;)
                    d.push(0);
                return d
            }, Hr = function (l) {
                return Object.keys(l).reduce(function (d, m) {
                    return d[m] = new Uint8Array(l[m].reduce(function (p, g) {
                        return p.concat(g)
                    }, [])),
                        d
                }, {})
            }, $e, Nt = function () {
                if (!$e) {
                    var l = {
                        96e3: [_i, [227, 64], xe(154), [56]],
                        88200: [_i, [231], xe(170), [56]],
                        64e3: [_i, [248, 192], xe(240), [56]],
                        48e3: [_i, [255, 192], xe(268), [55, 148, 128], xe(54), [112]],
                        44100: [_i, [255, 192], xe(268), [55, 163, 128], xe(84), [112]],
                        32e3: [_i, [255, 192], xe(268), [55, 234], xe(226), [112]],
                        24e3: [_i, [255, 192], xe(268), [55, 255, 128], xe(268), [111, 112], xe(126), [224]],
                        16e3: [_i, [255, 192], xe(268), [55, 255, 128], xe(268), [111, 255], xe(269), [223, 108], xe(195), [1, 192]],
                        12e3: [dr, xe(268), [3, 127, 248], xe(268), [6, 255, 240], xe(268), [13, 255, 224], xe(268), [27, 253, 128], xe(259), [56]],
                        11025: [dr, xe(268), [3, 127, 248], xe(268), [6, 255, 240], xe(268), [13, 255, 224], xe(268), [27, 255, 192], xe(268), [55, 175, 128], xe(108), [112]],
                        8e3: [dr, xe(268), [3, 121, 16], xe(47), [7]]
                    };
                    $e = Hr(l)
                }
                return $e
            }, Yt = 9e4, ni, qr, $r, ta, Iu, Pu, vo;
            ni = function (l) {
                return l * Yt
            }
                ,
                qr = function (l, d) {
                    return l * d
                }
                ,
                $r = function (l) {
                    return l / Yt
                }
                ,
                ta = function (l, d) {
                    return l / d
                }
                ,
                Iu = function (l, d) {
                    return ni(ta(l, d))
                }
                ,
                Pu = function (l, d) {
                    return qr($r(l), d)
                }
                ,
                vo = function (l, d, m) {
                    return $r(m ? l : l - d)
                }
                ;
            var Ne = {
                ONE_SECOND_IN_TS: Yt,
                secondsToVideoTs: ni,
                secondsToAudioTs: qr,
                videoTsToSeconds: $r,
                audioTsToSeconds: ta,
                audioTsToVideoTs: Iu,
                videoTsToAudioTs: Pu,
                metadataTsToSeconds: vo
            }
                , Qd = Nt
                , xi = Ne
                , ia = function (l) {
                    var d, m, p = 0;
                    for (d = 0; d < l.length; d++)
                        m = l[d],
                            p += m.data.byteLength;
                    return p
                }
                , Vr = function (l, d, m, p) {
                    var g, y = 0, S = 0, C = 0, k = 0, I, q, K;
                    if (d.length && (g = xi.audioTsToVideoTs(l.baseMediaDecodeTime, l.samplerate),
                        y = Math.ceil(xi.ONE_SECOND_IN_TS / (l.samplerate / 1024)),
                        m && p && (S = g - Math.max(m, p),
                            C = Math.floor(S / y),
                            k = C * y),
                        !(C < 1 || k > xi.ONE_SECOND_IN_TS / 2))) {
                        for (I = Qd()[l.samplerate],
                            I || (I = d[0].data),
                            q = 0; q < C; q++)
                            K = d[0],
                                d.splice(0, 0, {
                                    data: I,
                                    dts: K.dts - y,
                                    pts: K.pts - y
                                });
                        return l.baseMediaDecodeTime -= Math.floor(xi.videoTsToAudioTs(k, l.samplerate)),
                            k
                    }
                }
                , yo = function (l, d, m) {
                    return d.minSegmentDts >= m ? l : (d.minSegmentDts = 1 / 0,
                        l.filter(function (p) {
                            return p.dts >= m ? (d.minSegmentDts = Math.min(d.minSegmentDts, p.dts),
                                d.minSegmentPts = d.minSegmentDts,
                                !0) : !1
                        }))
                }
                , _o = function (l) {
                    var d, m, p = [];
                    for (d = 0; d < l.length; d++)
                        m = l[d],
                            p.push({
                                size: m.data.byteLength,
                                duration: 1024
                            });
                    return p
                }
                , To = function (l) {
                    var d, m, p = 0, g = new Uint8Array(ia(l));
                    for (d = 0; d < l.length; d++)
                        m = l[d],
                            g.set(m.data, p),
                            p += m.data.byteLength;
                    return g
                }
                , sa = {
                    prefixWithSilence: Vr,
                    trimAdtsFramesByEarliestDts: yo,
                    generateSampleTable: _o,
                    concatenateFrameData: To
                }
                , Lu = Ne.ONE_SECOND_IN_TS
                , Ou = function (l, d) {
                    typeof d.pts == "number" && (l.timelineStartInfo.pts === void 0 && (l.timelineStartInfo.pts = d.pts),
                        l.minSegmentPts === void 0 ? l.minSegmentPts = d.pts : l.minSegmentPts = Math.min(l.minSegmentPts, d.pts),
                        l.maxSegmentPts === void 0 ? l.maxSegmentPts = d.pts : l.maxSegmentPts = Math.max(l.maxSegmentPts, d.pts)),
                        typeof d.dts == "number" && (l.timelineStartInfo.dts === void 0 && (l.timelineStartInfo.dts = d.dts),
                            l.minSegmentDts === void 0 ? l.minSegmentDts = d.dts : l.minSegmentDts = Math.min(l.minSegmentDts, d.dts),
                            l.maxSegmentDts === void 0 ? l.maxSegmentDts = d.dts : l.maxSegmentDts = Math.max(l.maxSegmentDts, d.dts))
                }
                , bo = function (l) {
                    delete l.minSegmentDts,
                        delete l.maxSegmentDts,
                        delete l.minSegmentPts,
                        delete l.maxSegmentPts
                }
                , ra = function (l, d) {
                    var m, p, g = l.minSegmentDts;
                    return d || (g -= l.timelineStartInfo.dts),
                        m = l.timelineStartInfo.baseMediaDecodeTime,
                        m += g,
                        m = Math.max(0, m),
                        l.type === "audio" && (p = l.samplerate / Lu,
                            m *= p,
                            m = Math.floor(m)),
                        m
                }
                , Eo = {
                    clearDtsInfo: bo,
                    calculateTrackBaseMediaDecodeTime: ra,
                    collectDtsInfo: Ou
                }
                , So = 4
                , Mu = 128
                , Ru = function (l) {
                    for (var d = 0, m = {
                        payloadType: -1,
                        payloadSize: 0
                    }, p = 0, g = 0; d < l.byteLength && l[d] !== Mu;) {
                        for (; l[d] === 255;)
                            p += 255,
                                d++;
                        for (p += l[d++]; l[d] === 255;)
                            g += 255,
                                d++;
                        if (g += l[d++],
                            !m.payload && p === So) {
                            var y = String.fromCharCode(l[d + 3], l[d + 4], l[d + 5], l[d + 6]);
                            if (y === "GA94") {
                                m.payloadType = p,
                                    m.payloadSize = g,
                                    m.payload = l.subarray(d, d + g);
                                break
                            } else
                                m.payload = void 0
                        }
                        d += g,
                            p = 0,
                            g = 0
                    }
                    return m
                }
                , Co = function (l) {
                    return l.payload[0] !== 181 || (l.payload[1] << 8 | l.payload[2]) !== 49 || String.fromCharCode(l.payload[3], l.payload[4], l.payload[5], l.payload[6]) !== "GA94" || l.payload[7] !== 3 ? null : l.payload.subarray(8, l.payload.length - 1)
                }
                , cr = function (l, d) {
                    var m = [], p, g, y, S;
                    if (!(d[0] & 64))
                        return m;
                    for (g = d[0] & 31,
                        p = 0; p < g; p++)
                        y = p * 3,
                            S = {
                                type: d[y + 2] & 3,
                                pts: l
                            },
                            d[y + 2] & 4 && (S.ccData = d[y + 3] << 8 | d[y + 4],
                                m.push(S));
                    return m
                }
                , Nu = function (l) {
                    for (var d = l.byteLength, m = [], p = 1, g, y; p < d - 2;)
                        l[p] === 0 && l[p + 1] === 0 && l[p + 2] === 3 ? (m.push(p + 2),
                            p += 2) : p++;
                    if (m.length === 0)
                        return l;
                    g = d - m.length,
                        y = new Uint8Array(g);
                    var S = 0;
                    for (p = 0; p < g; S++,
                        p++)
                        S === m[0] && (S++,
                            m.shift()),
                            y[p] = l[S];
                    return y
                }
                , na = {
                    parseSei: Ru,
                    parseUserData: Co,
                    parseCaptionPackets: cr,
                    discardEmulationPreventionBytes: Nu,
                    USER_DATA_REGISTERED_ITU_T_T35: So
                }
                , aa = s
                , oa = na
                , b = function (l) {
                    l = l || {},
                        b.prototype.init.call(this),
                        this.parse708captions_ = typeof l.parse708captions == "boolean" ? l.parse708captions : !0,
                        this.captionPackets_ = [],
                        this.ccStreams_ = [new Oe(0, 0), new Oe(0, 1), new Oe(1, 0), new Oe(1, 1)],
                        this.parse708captions_ && (this.cc708Stream_ = new be({
                            captionServices: l.captionServices
                        })),
                        this.reset(),
                        this.ccStreams_.forEach(function (d) {
                            d.on("data", this.trigger.bind(this, "data")),
                                d.on("partialdone", this.trigger.bind(this, "partialdone")),
                                d.on("done", this.trigger.bind(this, "done"))
                        }, this),
                        this.parse708captions_ && (this.cc708Stream_.on("data", this.trigger.bind(this, "data")),
                            this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone")),
                            this.cc708Stream_.on("done", this.trigger.bind(this, "done")))
                };
            b.prototype = new aa,
                b.prototype.push = function (l) {
                    var d, m, p;
                    if (l.nalUnitType === "sei_rbsp" && (d = oa.parseSei(l.escapedRBSP),
                        !!d.payload && d.payloadType === oa.USER_DATA_REGISTERED_ITU_T_T35 && (m = oa.parseUserData(d),
                            !!m))) {
                        if (l.dts < this.latestDts_) {
                            this.ignoreNextEqualDts_ = !0;
                            return
                        } else if (l.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
                            this.numSameDts_--,
                                this.numSameDts_ || (this.ignoreNextEqualDts_ = !1);
                            return
                        }
                        p = oa.parseCaptionPackets(l.pts, m),
                            this.captionPackets_ = this.captionPackets_.concat(p),
                            this.latestDts_ !== l.dts && (this.numSameDts_ = 0),
                            this.numSameDts_++,
                            this.latestDts_ = l.dts
                    }
                }
                ,
                b.prototype.flushCCStreams = function (l) {
                    this.ccStreams_.forEach(function (d) {
                        return l === "flush" ? d.flush() : d.partialFlush()
                    }, this)
                }
                ,
                b.prototype.flushStream = function (l) {
                    if (!this.captionPackets_.length) {
                        this.flushCCStreams(l);
                        return
                    }
                    this.captionPackets_.forEach(function (d, m) {
                        d.presortIndex = m
                    }),
                        this.captionPackets_.sort(function (d, m) {
                            return d.pts === m.pts ? d.presortIndex - m.presortIndex : d.pts - m.pts
                        }),
                        this.captionPackets_.forEach(function (d) {
                            d.type < 2 ? this.dispatchCea608Packet(d) : this.dispatchCea708Packet(d)
                        }, this),
                        this.captionPackets_.length = 0,
                        this.flushCCStreams(l)
                }
                ,
                b.prototype.flush = function () {
                    return this.flushStream("flush")
                }
                ,
                b.prototype.partialFlush = function () {
                    return this.flushStream("partialFlush")
                }
                ,
                b.prototype.reset = function () {
                    this.latestDts_ = null,
                        this.ignoreNextEqualDts_ = !1,
                        this.numSameDts_ = 0,
                        this.activeCea608Channel_ = [null, null],
                        this.ccStreams_.forEach(function (l) {
                            l.reset()
                        })
                }
                ,
                b.prototype.dispatchCea608Packet = function (l) {
                    this.setsTextOrXDSActive(l) ? this.activeCea608Channel_[l.type] = null : this.setsChannel1Active(l) ? this.activeCea608Channel_[l.type] = 0 : this.setsChannel2Active(l) && (this.activeCea608Channel_[l.type] = 1),
                        this.activeCea608Channel_[l.type] !== null && this.ccStreams_[(l.type << 1) + this.activeCea608Channel_[l.type]].push(l)
                }
                ,
                b.prototype.setsChannel1Active = function (l) {
                    return (l.ccData & 30720) === 4096
                }
                ,
                b.prototype.setsChannel2Active = function (l) {
                    return (l.ccData & 30720) === 6144
                }
                ,
                b.prototype.setsTextOrXDSActive = function (l) {
                    return (l.ccData & 28928) === 256 || (l.ccData & 30974) === 4138 || (l.ccData & 30974) === 6186
                }
                ,
                b.prototype.dispatchCea708Packet = function (l) {
                    this.parse708captions_ && this.cc708Stream_.push(l)
                }
                ;
            var E = {
                127: 9834,
                4128: 32,
                4129: 160,
                4133: 8230,
                4138: 352,
                4140: 338,
                4144: 9608,
                4145: 8216,
                4146: 8217,
                4147: 8220,
                4148: 8221,
                4149: 8226,
                4153: 8482,
                4154: 353,
                4156: 339,
                4157: 8480,
                4159: 376,
                4214: 8539,
                4215: 8540,
                4216: 8541,
                4217: 8542,
                4218: 9168,
                4219: 9124,
                4220: 9123,
                4221: 9135,
                4222: 9126,
                4223: 9121,
                4256: 12600
            }
                , P = function (l) {
                    var d = E[l] || l;
                    return l & 4096 && l === d ? "" : String.fromCharCode(d)
                }
                , W = function (l) {
                    return 32 <= l && l <= 127 || 160 <= l && l <= 255
                }
                , ne = function (l) {
                    this.windowNum = l,
                        this.reset()
                };
            ne.prototype.reset = function () {
                this.clearText(),
                    this.pendingNewLine = !1,
                    this.winAttr = {},
                    this.penAttr = {},
                    this.penLoc = {},
                    this.penColor = {},
                    this.visible = 0,
                    this.rowLock = 0,
                    this.columnLock = 0,
                    this.priority = 0,
                    this.relativePositioning = 0,
                    this.anchorVertical = 0,
                    this.anchorHorizontal = 0,
                    this.anchorPoint = 0,
                    this.rowCount = 1,
                    this.virtualRowCount = this.rowCount + 1,
                    this.columnCount = 41,
                    this.windowStyle = 0,
                    this.penStyle = 0
            }
                ,
                ne.prototype.getText = function () {
                    return this.rows.join(`
`)
                }
                ,
                ne.prototype.clearText = function () {
                    this.rows = [""],
                        this.rowIdx = 0
                }
                ,
                ne.prototype.newLine = function (l) {
                    for (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow == "function" && this.beforeRowOverflow(l),
                        this.rows.length > 0 && (this.rows.push(""),
                            this.rowIdx++); this.rows.length > this.virtualRowCount;)
                        this.rows.shift(),
                            this.rowIdx--
                }
                ,
                ne.prototype.isEmpty = function () {
                    return this.rows.length === 0 ? !0 : this.rows.length === 1 ? this.rows[0] === "" : !1
                }
                ,
                ne.prototype.addText = function (l) {
                    this.rows[this.rowIdx] += l
                }
                ,
                ne.prototype.backspace = function () {
                    if (!this.isEmpty()) {
                        var l = this.rows[this.rowIdx];
                        this.rows[this.rowIdx] = l.substr(0, l.length - 1)
                    }
                }
                ;
            var Se = function (l, d, m) {
                this.serviceNum = l,
                    this.text = "",
                    this.currentWindow = new ne(-1),
                    this.windows = [],
                    this.stream = m,
                    typeof d == "string" && this.createTextDecoder(d)
            };
            Se.prototype.init = function (l, d) {
                this.startPts = l;
                for (var m = 0; m < 8; m++)
                    this.windows[m] = new ne(m),
                        typeof d == "function" && (this.windows[m].beforeRowOverflow = d)
            }
                ,
                Se.prototype.setCurrentWindow = function (l) {
                    this.currentWindow = this.windows[l]
                }
                ,
                Se.prototype.createTextDecoder = function (l) {
                    if (typeof TextDecoder > "u")
                        this.stream.trigger("log", {
                            level: "warn",
                            message: "The `encoding` option is unsupported without TextDecoder support"
                        });
                    else
                        try {
                            this.textDecoder_ = new TextDecoder(l)
                        } catch (d) {
                            this.stream.trigger("log", {
                                level: "warn",
                                message: "TextDecoder could not be created with " + l + " encoding. " + d
                            })
                        }
                }
                ;
            var be = function (l) {
                l = l || {},
                    be.prototype.init.call(this);
                var d = this, m = l.captionServices || {}, p = {}, g;
                Object.keys(m).forEach(y => {
                    g = m[y],
                        /^SERVICE/.test(y) && (p[y] = g.encoding)
                }
                ),
                    this.serviceEncodings = p,
                    this.current708Packet = null,
                    this.services = {},
                    this.push = function (y) {
                        y.type === 3 ? (d.new708Packet(),
                            d.add708Bytes(y)) : (d.current708Packet === null && d.new708Packet(),
                                d.add708Bytes(y))
                    }
            };
            be.prototype = new aa,
                be.prototype.new708Packet = function () {
                    this.current708Packet !== null && this.push708Packet(),
                        this.current708Packet = {
                            data: [],
                            ptsVals: []
                        }
                }
                ,
                be.prototype.add708Bytes = function (l) {
                    var d = l.ccData
                        , m = d >>> 8
                        , p = d & 255;
                    this.current708Packet.ptsVals.push(l.pts),
                        this.current708Packet.data.push(m),
                        this.current708Packet.data.push(p)
                }
                ,
                be.prototype.push708Packet = function () {
                    var l = this.current708Packet
                        , d = l.data
                        , m = null
                        , p = null
                        , g = 0
                        , y = d[g++];
                    for (l.seq = y >> 6,
                        l.sizeCode = y & 63; g < d.length; g++)
                        y = d[g++],
                            m = y >> 5,
                            p = y & 31,
                            m === 7 && p > 0 && (y = d[g++],
                                m = y),
                            this.pushServiceBlock(m, g, p),
                            p > 0 && (g += p - 1)
                }
                ,
                be.prototype.pushServiceBlock = function (l, d, m) {
                    var p, g = d, y = this.current708Packet.data, S = this.services[l];
                    for (S || (S = this.initService(l, g)); g < d + m && g < y.length; g++)
                        p = y[g],
                            W(p) ? g = this.handleText(g, S) : p === 24 ? g = this.multiByteCharacter(g, S) : p === 16 ? g = this.extendedCommands(g, S) : 128 <= p && p <= 135 ? g = this.setCurrentWindow(g, S) : 152 <= p && p <= 159 ? g = this.defineWindow(g, S) : p === 136 ? g = this.clearWindows(g, S) : p === 140 ? g = this.deleteWindows(g, S) : p === 137 ? g = this.displayWindows(g, S) : p === 138 ? g = this.hideWindows(g, S) : p === 139 ? g = this.toggleWindows(g, S) : p === 151 ? g = this.setWindowAttributes(g, S) : p === 144 ? g = this.setPenAttributes(g, S) : p === 145 ? g = this.setPenColor(g, S) : p === 146 ? g = this.setPenLocation(g, S) : p === 143 ? S = this.reset(g, S) : p === 8 ? S.currentWindow.backspace() : p === 12 ? S.currentWindow.clearText() : p === 13 ? S.currentWindow.pendingNewLine = !0 : p === 14 ? S.currentWindow.clearText() : p === 141 && g++
                }
                ,
                be.prototype.extendedCommands = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[++l];
                    return W(p) && (l = this.handleText(l, d, {
                        isExtended: !0
                    })),
                        l
                }
                ,
                be.prototype.getPts = function (l) {
                    return this.current708Packet.ptsVals[Math.floor(l / 2)]
                }
                ,
                be.prototype.initService = function (l, d) {
                    var p = "SERVICE" + l, m = this, p, g;
                    return p in this.serviceEncodings && (g = this.serviceEncodings[p]),
                        this.services[l] = new Se(l, g, m),
                        this.services[l].init(this.getPts(d), function (y) {
                            m.flushDisplayed(y, m.services[l])
                        }),
                        this.services[l]
                }
                ,
                be.prototype.handleText = function (l, d, m) {
                    var p = m && m.isExtended, g = m && m.isMultiByte, y = this.current708Packet.data, S = p ? 4096 : 0, C = y[l], k = y[l + 1], I = d.currentWindow, q, K;
                    function fe(Q) {
                        return Q.map(Ee => ("0" + (Ee & 255).toString(16)).slice(-2)).join("")
                    }
                    if (g ? (K = [C, k],
                        l++) : K = [C],
                        d.textDecoder_ && !p)
                        q = d.textDecoder_.decode(new Uint8Array(K));
                    else if (g) {
                        const Q = fe(K);
                        q = String.fromCharCode(parseInt(Q, 16))
                    } else
                        q = P(S | C);
                    return I.pendingNewLine && !I.isEmpty() && I.newLine(this.getPts(l)),
                        I.pendingNewLine = !1,
                        I.addText(q),
                        l
                }
                ,
                be.prototype.multiByteCharacter = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[l + 1]
                        , g = m[l + 2];
                    return W(p) && W(g) && (l = this.handleText(++l, d, {
                        isMultiByte: !0
                    })),
                        l
                }
                ,
                be.prototype.setCurrentWindow = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[l]
                        , g = p & 7;
                    return d.setCurrentWindow(g),
                        l
                }
                ,
                be.prototype.defineWindow = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[l]
                        , g = p & 7;
                    d.setCurrentWindow(g);
                    var y = d.currentWindow;
                    return p = m[++l],
                        y.visible = (p & 32) >> 5,
                        y.rowLock = (p & 16) >> 4,
                        y.columnLock = (p & 8) >> 3,
                        y.priority = p & 7,
                        p = m[++l],
                        y.relativePositioning = (p & 128) >> 7,
                        y.anchorVertical = p & 127,
                        p = m[++l],
                        y.anchorHorizontal = p,
                        p = m[++l],
                        y.anchorPoint = (p & 240) >> 4,
                        y.rowCount = p & 15,
                        p = m[++l],
                        y.columnCount = p & 63,
                        p = m[++l],
                        y.windowStyle = (p & 56) >> 3,
                        y.penStyle = p & 7,
                        y.virtualRowCount = y.rowCount + 1,
                        l
                }
                ,
                be.prototype.setWindowAttributes = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[l]
                        , g = d.currentWindow.winAttr;
                    return p = m[++l],
                        g.fillOpacity = (p & 192) >> 6,
                        g.fillRed = (p & 48) >> 4,
                        g.fillGreen = (p & 12) >> 2,
                        g.fillBlue = p & 3,
                        p = m[++l],
                        g.borderType = (p & 192) >> 6,
                        g.borderRed = (p & 48) >> 4,
                        g.borderGreen = (p & 12) >> 2,
                        g.borderBlue = p & 3,
                        p = m[++l],
                        g.borderType += (p & 128) >> 5,
                        g.wordWrap = (p & 64) >> 6,
                        g.printDirection = (p & 48) >> 4,
                        g.scrollDirection = (p & 12) >> 2,
                        g.justify = p & 3,
                        p = m[++l],
                        g.effectSpeed = (p & 240) >> 4,
                        g.effectDirection = (p & 12) >> 2,
                        g.displayEffect = p & 3,
                        l
                }
                ,
                be.prototype.flushDisplayed = function (l, d) {
                    for (var m = [], p = 0; p < 8; p++)
                        d.windows[p].visible && !d.windows[p].isEmpty() && m.push(d.windows[p].getText());
                    d.endPts = l,
                        d.text = m.join(`

`),
                        this.pushCaption(d),
                        d.startPts = l
                }
                ,
                be.prototype.pushCaption = function (l) {
                    l.text !== "" && (this.trigger("data", {
                        startPts: l.startPts,
                        endPts: l.endPts,
                        text: l.text,
                        stream: "cc708_" + l.serviceNum
                    }),
                        l.text = "",
                        l.startPts = l.endPts)
                }
                ,
                be.prototype.displayWindows = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[++l]
                        , g = this.getPts(l);
                    this.flushDisplayed(g, d);
                    for (var y = 0; y < 8; y++)
                        p & 1 << y && (d.windows[y].visible = 1);
                    return l
                }
                ,
                be.prototype.hideWindows = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[++l]
                        , g = this.getPts(l);
                    this.flushDisplayed(g, d);
                    for (var y = 0; y < 8; y++)
                        p & 1 << y && (d.windows[y].visible = 0);
                    return l
                }
                ,
                be.prototype.toggleWindows = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[++l]
                        , g = this.getPts(l);
                    this.flushDisplayed(g, d);
                    for (var y = 0; y < 8; y++)
                        p & 1 << y && (d.windows[y].visible ^= 1);
                    return l
                }
                ,
                be.prototype.clearWindows = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[++l]
                        , g = this.getPts(l);
                    this.flushDisplayed(g, d);
                    for (var y = 0; y < 8; y++)
                        p & 1 << y && d.windows[y].clearText();
                    return l
                }
                ,
                be.prototype.deleteWindows = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[++l]
                        , g = this.getPts(l);
                    this.flushDisplayed(g, d);
                    for (var y = 0; y < 8; y++)
                        p & 1 << y && d.windows[y].reset();
                    return l
                }
                ,
                be.prototype.setPenAttributes = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[l]
                        , g = d.currentWindow.penAttr;
                    return p = m[++l],
                        g.textTag = (p & 240) >> 4,
                        g.offset = (p & 12) >> 2,
                        g.penSize = p & 3,
                        p = m[++l],
                        g.italics = (p & 128) >> 7,
                        g.underline = (p & 64) >> 6,
                        g.edgeType = (p & 56) >> 3,
                        g.fontStyle = p & 7,
                        l
                }
                ,
                be.prototype.setPenColor = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[l]
                        , g = d.currentWindow.penColor;
                    return p = m[++l],
                        g.fgOpacity = (p & 192) >> 6,
                        g.fgRed = (p & 48) >> 4,
                        g.fgGreen = (p & 12) >> 2,
                        g.fgBlue = p & 3,
                        p = m[++l],
                        g.bgOpacity = (p & 192) >> 6,
                        g.bgRed = (p & 48) >> 4,
                        g.bgGreen = (p & 12) >> 2,
                        g.bgBlue = p & 3,
                        p = m[++l],
                        g.edgeRed = (p & 48) >> 4,
                        g.edgeGreen = (p & 12) >> 2,
                        g.edgeBlue = p & 3,
                        l
                }
                ,
                be.prototype.setPenLocation = function (l, d) {
                    var m = this.current708Packet.data
                        , p = m[l]
                        , g = d.currentWindow.penLoc;
                    return d.currentWindow.pendingNewLine = !0,
                        p = m[++l],
                        g.row = p & 15,
                        p = m[++l],
                        g.column = p & 63,
                        l
                }
                ,
                be.prototype.reset = function (l, d) {
                    var m = this.getPts(l);
                    return this.flushDisplayed(m, d),
                        this.initService(d.serviceNum, l)
                }
                ;
            var Dt = {
                42: 225,
                92: 233,
                94: 237,
                95: 243,
                96: 250,
                123: 231,
                124: 247,
                125: 209,
                126: 241,
                127: 9608,
                304: 174,
                305: 176,
                306: 189,
                307: 191,
                308: 8482,
                309: 162,
                310: 163,
                311: 9834,
                312: 224,
                313: 160,
                314: 232,
                315: 226,
                316: 234,
                317: 238,
                318: 244,
                319: 251,
                544: 193,
                545: 201,
                546: 211,
                547: 218,
                548: 220,
                549: 252,
                550: 8216,
                551: 161,
                552: 42,
                553: 39,
                554: 8212,
                555: 169,
                556: 8480,
                557: 8226,
                558: 8220,
                559: 8221,
                560: 192,
                561: 194,
                562: 199,
                563: 200,
                564: 202,
                565: 203,
                566: 235,
                567: 206,
                568: 207,
                569: 239,
                570: 212,
                571: 217,
                572: 249,
                573: 219,
                574: 171,
                575: 187,
                800: 195,
                801: 227,
                802: 205,
                803: 204,
                804: 236,
                805: 210,
                806: 242,
                807: 213,
                808: 245,
                809: 123,
                810: 125,
                811: 92,
                812: 94,
                813: 95,
                814: 124,
                815: 126,
                816: 196,
                817: 228,
                818: 214,
                819: 246,
                820: 223,
                821: 165,
                822: 164,
                823: 9474,
                824: 197,
                825: 229,
                826: 216,
                827: 248,
                828: 9484,
                829: 9488,
                830: 9492,
                831: 9496
            }
                , ai = function (l) {
                    return l === null ? "" : (l = Dt[l] || l,
                        String.fromCharCode(l))
                }
                , Bt = 14
                , zi = [4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152]
                , Qt = function () {
                    for (var l = [], d = Bt + 1; d--;)
                        l.push({
                            text: "",
                            indent: 0,
                            offset: 0
                        });
                    return l
                }
                , Oe = function (l, d) {
                    Oe.prototype.init.call(this),
                        this.field_ = l || 0,
                        this.dataChannel_ = d || 0,
                        this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1),
                        this.setConstants(),
                        this.reset(),
                        this.push = function (m) {
                            var p, g, y, S, C;
                            if (p = m.ccData & 32639,
                                p === this.lastControlCode_) {
                                this.lastControlCode_ = null;
                                return
                            }
                            if ((p & 61440) === 4096 ? this.lastControlCode_ = p : p !== this.PADDING_ && (this.lastControlCode_ = null),
                                y = p >>> 8,
                                S = p & 255,
                                p !== this.PADDING_)
                                if (p === this.RESUME_CAPTION_LOADING_)
                                    this.mode_ = "popOn";
                                else if (p === this.END_OF_CAPTION_)
                                    this.mode_ = "popOn",
                                        this.clearFormatting(m.pts),
                                        this.flushDisplayed(m.pts),
                                        g = this.displayed_,
                                        this.displayed_ = this.nonDisplayed_,
                                        this.nonDisplayed_ = g,
                                        this.startPts_ = m.pts;
                                else if (p === this.ROLL_UP_2_ROWS_)
                                    this.rollUpRows_ = 2,
                                        this.setRollUp(m.pts);
                                else if (p === this.ROLL_UP_3_ROWS_)
                                    this.rollUpRows_ = 3,
                                        this.setRollUp(m.pts);
                                else if (p === this.ROLL_UP_4_ROWS_)
                                    this.rollUpRows_ = 4,
                                        this.setRollUp(m.pts);
                                else if (p === this.CARRIAGE_RETURN_)
                                    this.clearFormatting(m.pts),
                                        this.flushDisplayed(m.pts),
                                        this.shiftRowsUp_(),
                                        this.startPts_ = m.pts;
                                else if (p === this.BACKSPACE_)
                                    this.mode_ === "popOn" ? this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1) : this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1);
                                else if (p === this.ERASE_DISPLAYED_MEMORY_)
                                    this.flushDisplayed(m.pts),
                                        this.displayed_ = Qt();
                                else if (p === this.ERASE_NON_DISPLAYED_MEMORY_)
                                    this.nonDisplayed_ = Qt();
                                else if (p === this.RESUME_DIRECT_CAPTIONING_)
                                    this.mode_ !== "paintOn" && (this.flushDisplayed(m.pts),
                                        this.displayed_ = Qt()),
                                        this.mode_ = "paintOn",
                                        this.startPts_ = m.pts;
                                else if (this.isSpecialCharacter(y, S))
                                    y = (y & 3) << 8,
                                        C = ai(y | S),
                                        this[this.mode_](m.pts, C),
                                        this.column_++;
                                else if (this.isExtCharacter(y, S))
                                    this.mode_ === "popOn" ? this.nonDisplayed_[this.row_].text = this.nonDisplayed_[this.row_].text.slice(0, -1) : this.displayed_[this.row_].text = this.displayed_[this.row_].text.slice(0, -1),
                                        y = (y & 3) << 8,
                                        C = ai(y | S),
                                        this[this.mode_](m.pts, C),
                                        this.column_++;
                                else if (this.isMidRowCode(y, S))
                                    this.clearFormatting(m.pts),
                                        this[this.mode_](m.pts, " "),
                                        this.column_++,
                                        (S & 14) === 14 && this.addFormatting(m.pts, ["i"]),
                                        (S & 1) === 1 && this.addFormatting(m.pts, ["u"]);
                                else if (this.isOffsetControlCode(y, S)) {
                                    const I = S & 3;
                                    this.nonDisplayed_[this.row_].offset = I,
                                        this.column_ += I
                                } else if (this.isPAC(y, S)) {
                                    var k = zi.indexOf(p & 7968);
                                    if (this.mode_ === "rollUp" && (k - this.rollUpRows_ + 1 < 0 && (k = this.rollUpRows_ - 1),
                                        this.setRollUp(m.pts, k)),
                                        k !== this.row_ && (this.clearFormatting(m.pts),
                                            this.row_ = k),
                                        S & 1 && this.formatting_.indexOf("u") === -1 && this.addFormatting(m.pts, ["u"]),
                                        (p & 16) === 16) {
                                        const I = (p & 14) >> 1;
                                        this.column_ = I * 4,
                                            this.nonDisplayed_[this.row_].indent += I
                                    }
                                    this.isColorPAC(S) && (S & 14) === 14 && this.addFormatting(m.pts, ["i"])
                                } else
                                    this.isNormalChar(y) && (S === 0 && (S = null),
                                        C = ai(y),
                                        C += ai(S),
                                        this[this.mode_](m.pts, C),
                                        this.column_ += C.length)
                        }
                };
            Oe.prototype = new aa,
                Oe.prototype.flushDisplayed = function (l) {
                    const d = p => {
                        this.trigger("log", {
                            level: "warn",
                            message: "Skipping a malformed 608 caption at index " + p + "."
                        })
                    }
                        , m = [];
                    this.displayed_.forEach((p, g) => {
                        if (p && p.text && p.text.length) {
                            try {
                                p.text = p.text.trim()
                            } catch (y) {
                                d(g)
                            }
                            p.text.length && m.push({
                                text: p.text,
                                line: g + 1,
                                position: 10 + Math.min(70, p.indent * 10) + p.offset * 2.5
                            })
                        } else
                            p == null && d(g)
                    }
                    ),
                        m.length && this.trigger("data", {
                            startPts: this.startPts_,
                            endPts: l,
                            content: m,
                            stream: this.name_
                        })
                }
                ,
                Oe.prototype.reset = function () {
                    this.mode_ = "popOn",
                        this.topRow_ = 0,
                        this.startPts_ = 0,
                        this.displayed_ = Qt(),
                        this.nonDisplayed_ = Qt(),
                        this.lastControlCode_ = null,
                        this.column_ = 0,
                        this.row_ = Bt,
                        this.rollUpRows_ = 2,
                        this.formatting_ = []
                }
                ,
                Oe.prototype.setConstants = function () {
                    this.dataChannel_ === 0 ? (this.BASE_ = 16,
                        this.EXT_ = 17,
                        this.CONTROL_ = (20 | this.field_) << 8,
                        this.OFFSET_ = 23) : this.dataChannel_ === 1 && (this.BASE_ = 24,
                            this.EXT_ = 25,
                            this.CONTROL_ = (28 | this.field_) << 8,
                            this.OFFSET_ = 31),
                        this.PADDING_ = 0,
                        this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32,
                        this.END_OF_CAPTION_ = this.CONTROL_ | 47,
                        this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37,
                        this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38,
                        this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39,
                        this.CARRIAGE_RETURN_ = this.CONTROL_ | 45,
                        this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41,
                        this.BACKSPACE_ = this.CONTROL_ | 33,
                        this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44,
                        this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46
                }
                ,
                Oe.prototype.isSpecialCharacter = function (l, d) {
                    return l === this.EXT_ && d >= 48 && d <= 63
                }
                ,
                Oe.prototype.isExtCharacter = function (l, d) {
                    return (l === this.EXT_ + 1 || l === this.EXT_ + 2) && d >= 32 && d <= 63
                }
                ,
                Oe.prototype.isMidRowCode = function (l, d) {
                    return l === this.EXT_ && d >= 32 && d <= 47
                }
                ,
                Oe.prototype.isOffsetControlCode = function (l, d) {
                    return l === this.OFFSET_ && d >= 33 && d <= 35
                }
                ,
                Oe.prototype.isPAC = function (l, d) {
                    return l >= this.BASE_ && l < this.BASE_ + 8 && d >= 64 && d <= 127
                }
                ,
                Oe.prototype.isColorPAC = function (l) {
                    return l >= 64 && l <= 79 || l >= 96 && l <= 127
                }
                ,
                Oe.prototype.isNormalChar = function (l) {
                    return l >= 32 && l <= 127
                }
                ,
                Oe.prototype.setRollUp = function (l, d) {
                    if (this.mode_ !== "rollUp" && (this.row_ = Bt,
                        this.mode_ = "rollUp",
                        this.flushDisplayed(l),
                        this.nonDisplayed_ = Qt(),
                        this.displayed_ = Qt()),
                        d !== void 0 && d !== this.row_)
                        for (var m = 0; m < this.rollUpRows_; m++)
                            this.displayed_[d - m] = this.displayed_[this.row_ - m],
                                this.displayed_[this.row_ - m] = {
                                    text: "",
                                    indent: 0,
                                    offset: 0
                                };
                    d === void 0 && (d = this.row_),
                        this.topRow_ = d - this.rollUpRows_ + 1
                }
                ,
                Oe.prototype.addFormatting = function (l, d) {
                    this.formatting_ = this.formatting_.concat(d);
                    var m = d.reduce(function (p, g) {
                        return p + "<" + g + ">"
                    }, "");
                    this[this.mode_](l, m)
                }
                ,
                Oe.prototype.clearFormatting = function (l) {
                    if (this.formatting_.length) {
                        var d = this.formatting_.reverse().reduce(function (m, p) {
                            return m + "</" + p + ">"
                        }, "");
                        this.formatting_ = [],
                            this[this.mode_](l, d)
                    }
                }
                ,
                Oe.prototype.popOn = function (l, d) {
                    var m = this.nonDisplayed_[this.row_].text;
                    m += d,
                        this.nonDisplayed_[this.row_].text = m
                }
                ,
                Oe.prototype.rollUp = function (l, d) {
                    var m = this.displayed_[this.row_].text;
                    m += d,
                        this.displayed_[this.row_].text = m
                }
                ,
                Oe.prototype.shiftRowsUp_ = function () {
                    var l;
                    for (l = 0; l < this.topRow_; l++)
                        this.displayed_[l] = {
                            text: "",
                            indent: 0,
                            offset: 0
                        };
                    for (l = this.row_ + 1; l < Bt + 1; l++)
                        this.displayed_[l] = {
                            text: "",
                            indent: 0,
                            offset: 0
                        };
                    for (l = this.topRow_; l < this.row_; l++)
                        this.displayed_[l] = this.displayed_[l + 1];
                    this.displayed_[this.row_] = {
                        text: "",
                        indent: 0,
                        offset: 0
                    }
                }
                ,
                Oe.prototype.paintOn = function (l, d) {
                    var m = this.displayed_[this.row_].text;
                    m += d,
                        this.displayed_[this.row_].text = m
                }
                ;
            var gs = {
                CaptionStream: b,
                Cea608Stream: Oe,
                Cea708Stream: be
            }
                , Jt = {
                    H264_STREAM_TYPE: 27,
                    ADTS_STREAM_TYPE: 15,
                    METADATA_STREAM_TYPE: 21
                }
                , Us = s
                , zr = 8589934592
                , yt = 4294967296
                , Ao = "shared"
                , vs = function (l, d) {
                    var m = 1;
                    for (l > d && (m = -1); Math.abs(d - l) > yt;)
                        l += m * zr;
                    return l
                }
                , la = function (l) {
                    var d, m;
                    la.prototype.init.call(this),
                        this.type_ = l || Ao,
                        this.push = function (p) {
                            if (p.type === "metadata") {
                                this.trigger("data", p);
                                return
                            }
                            this.type_ !== Ao && p.type !== this.type_ || (m === void 0 && (m = p.dts),
                                p.dts = vs(p.dts, m),
                                p.pts = vs(p.pts, m),
                                d = p.dts,
                                this.trigger("data", p))
                        }
                        ,
                        this.flush = function () {
                            m = d,
                                this.trigger("done")
                        }
                        ,
                        this.endTimeline = function () {
                            this.flush(),
                                this.trigger("endedtimeline")
                        }
                        ,
                        this.discontinuity = function () {
                            m = void 0,
                                d = void 0
                        }
                        ,
                        this.reset = function () {
                            this.discontinuity(),
                                this.trigger("reset")
                        }
                };
            la.prototype = new Us;
            var Hg = {
                TimestampRolloverStream: la,
                handleRollover: vs
            }, RE = (l, d, m) => {
                if (!l)
                    return -1;
                for (var p = m; p < l.length; p++)
                    if (l[p] === d)
                        return p;
                return -1
            }
                , NE = {
                    typedArrayIndexOf: RE
                }, Bu = NE.typedArrayIndexOf, Fu = {
                    Iso88591: 0,
                    Utf16: 1,
                    Utf16be: 2,
                    Utf8: 3
                }, qg = function (l, d, m) {
                    var p, g = "";
                    for (p = d; p < m; p++)
                        g += "%" + ("00" + l[p].toString(16)).slice(-2);
                    return g
                }, wo = function (l, d, m) {
                    return decodeURIComponent(qg(l, d, m))
                }, Do = function (l, d, m) {
                    return unescape(qg(l, d, m))
                }, ko = function (l) {
                    return l[0] << 21 | l[1] << 14 | l[2] << 7 | l[3]
                }, xo = {
                    APIC: function (l) {
                        var d = 1, m, p, g = "-->";
                        l.data[0] === Fu.Utf8 && (m = Bu(l.data, 0, d),
                            !(m < 0) && (l.mimeType = Do(l.data, d, m),
                                d = m + 1,
                                l.pictureType = l.data[d],
                                d++,
                                p = Bu(l.data, 0, d),
                                !(p < 0) && (l.description = wo(l.data, d, p),
                                    d = p + 1,
                                    l.mimeType === g ? l.url = Do(l.data, d, l.data.length) : l.pictureData = l.data.subarray(d, l.data.length))))
                    },
                    "T*": function (l) {
                        l.data[0] === Fu.Utf8 && (l.value = wo(l.data, 1, l.data.length).replace(/\0*$/, ""),
                            l.values = l.value.split("\0"))
                    },
                    TXXX: function (l) {
                        var d;
                        l.data[0] === Fu.Utf8 && (d = Bu(l.data, 0, 1),
                            d !== -1 && (l.description = wo(l.data, 1, d),
                                l.value = wo(l.data, d + 1, l.data.length).replace(/\0*$/, ""),
                                l.data = l.value))
                    },
                    "W*": function (l) {
                        l.url = Do(l.data, 0, l.data.length).replace(/\0.*$/, "")
                    },
                    WXXX: function (l) {
                        var d;
                        l.data[0] === Fu.Utf8 && (d = Bu(l.data, 0, 1),
                            d !== -1 && (l.description = wo(l.data, 1, d),
                                l.url = Do(l.data, d + 1, l.data.length).replace(/\0.*$/, "")))
                    },
                    PRIV: function (l) {
                        var d;
                        for (d = 0; d < l.data.length; d++)
                            if (l.data[d] === 0) {
                                l.owner = Do(l.data, 0, d);
                                break
                            }
                        l.privateData = l.data.subarray(d + 1),
                            l.data = l.privateData
                    }
                }, BE = function (l) {
                    var d, m, p = 10, g = 0, y = [];
                    if (!(l.length < 10 || l[0] !== "I".charCodeAt(0) || l[1] !== "D".charCodeAt(0) || l[2] !== "3".charCodeAt(0))) {
                        g = ko(l.subarray(6, 10)),
                            g += 10;
                        var S = l[5] & 64;
                        S && (p += 4,
                            p += ko(l.subarray(10, 14)),
                            g -= ko(l.subarray(16, 20)));
                        do {
                            if (d = ko(l.subarray(p + 4, p + 8)),
                                d < 1)
                                break;
                            m = String.fromCharCode(l[p], l[p + 1], l[p + 2], l[p + 3]);
                            var C = {
                                id: m,
                                data: l.subarray(p + 10, p + d + 10)
                            };
                            C.key = C.id,
                                xo[C.id] ? xo[C.id](C) : C.id[0] === "T" ? xo["T*"](C) : C.id[0] === "W" && xo["W*"](C),
                                y.push(C),
                                p += 10,
                                p += d
                        } while (p < g);
                        return y
                    }
                }, $g = {
                    parseId3Frames: BE,
                    parseSyncSafeInteger: ko,
                    frameParsers: xo
                }, FE = s, UE = Jt, fr = $g, Uu;
            Uu = function (l) {
                var d = {
                    descriptor: l && l.descriptor
                }, m = 0, p = [], g = 0, y;
                if (Uu.prototype.init.call(this),
                    this.dispatchType = UE.METADATA_STREAM_TYPE.toString(16),
                    d.descriptor)
                    for (y = 0; y < d.descriptor.length; y++)
                        this.dispatchType += ("00" + d.descriptor[y].toString(16)).slice(-2);
                this.push = function (S) {
                    var C, k, I, q, K, fe;
                    if (S.type === "timed-metadata") {
                        if (S.dataAlignmentIndicator && (g = 0,
                            p.length = 0),
                            p.length === 0 && (S.data.length < 10 || S.data[0] !== "I".charCodeAt(0) || S.data[1] !== "D".charCodeAt(0) || S.data[2] !== "3".charCodeAt(0))) {
                            this.trigger("log", {
                                level: "warn",
                                message: "Skipping unrecognized metadata packet"
                            });
                            return
                        }
                        if (p.push(S),
                            g += S.data.byteLength,
                            p.length === 1 && (m = fr.parseSyncSafeInteger(S.data.subarray(6, 10)),
                                m += 10),
                            !(g < m)) {
                            for (C = {
                                data: new Uint8Array(m),
                                frames: [],
                                pts: p[0].pts,
                                dts: p[0].dts
                            },
                                K = 0; K < m;)
                                C.data.set(p[0].data.subarray(0, m - K), K),
                                    K += p[0].data.byteLength,
                                    g -= p[0].data.byteLength,
                                    p.shift();
                            k = 10,
                                C.data[5] & 64 && (k += 4,
                                    k += fr.parseSyncSafeInteger(C.data.subarray(10, 14)),
                                    m -= fr.parseSyncSafeInteger(C.data.subarray(16, 20)));
                            do {
                                if (I = fr.parseSyncSafeInteger(C.data.subarray(k + 4, k + 8)),
                                    I < 1) {
                                    this.trigger("log", {
                                        level: "warn",
                                        message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing."
                                    });
                                    break
                                }
                                if (fe = String.fromCharCode(C.data[k], C.data[k + 1], C.data[k + 2], C.data[k + 3]),
                                    q = {
                                        id: fe,
                                        data: C.data.subarray(k + 10, k + I + 10)
                                    },
                                    q.key = q.id,
                                    fr.frameParsers[q.id] ? fr.frameParsers[q.id](q) : q.id[0] === "T" ? fr.frameParsers["T*"](q) : q.id[0] === "W" && fr.frameParsers["W*"](q),
                                    q.owner === "com.apple.streaming.transportStreamTimestamp") {
                                    var Q = q.data
                                        , Ee = (Q[3] & 1) << 30 | Q[4] << 22 | Q[5] << 14 | Q[6] << 6 | Q[7] >>> 2;
                                    Ee *= 4,
                                        Ee += Q[7] & 3,
                                        q.timeStamp = Ee,
                                        C.pts === void 0 && C.dts === void 0 && (C.pts = q.timeStamp,
                                            C.dts = q.timeStamp),
                                        this.trigger("timestamp", q)
                                }
                                C.frames.push(q),
                                    k += 10,
                                    k += I
                            } while (k < m);
                            this.trigger("data", C)
                        }
                    }
                }
            }
                ,
                Uu.prototype = new FE;
            var jE = Uu, Jd = s, Zd = gs, Gi = Jt, HE = Hg.TimestampRolloverStream, ju, Io, Hu, ua = 188, ec = 71;
            ju = function () {
                var l = new Uint8Array(ua)
                    , d = 0;
                ju.prototype.init.call(this),
                    this.push = function (m) {
                        var p = 0, g = ua, y;
                        for (d ? (y = new Uint8Array(m.byteLength + d),
                            y.set(l.subarray(0, d)),
                            y.set(m, d),
                            d = 0) : y = m; g < y.byteLength;) {
                            if (y[p] === ec && y[g] === ec) {
                                this.trigger("data", y.subarray(p, g)),
                                    p += ua,
                                    g += ua;
                                continue
                            }
                            p++,
                                g++
                        }
                        p < y.byteLength && (l.set(y.subarray(p), 0),
                            d = y.byteLength - p)
                    }
                    ,
                    this.flush = function () {
                        d === ua && l[0] === ec && (this.trigger("data", l),
                            d = 0),
                            this.trigger("done")
                    }
                    ,
                    this.endTimeline = function () {
                        this.flush(),
                            this.trigger("endedtimeline")
                    }
                    ,
                    this.reset = function () {
                        d = 0,
                            this.trigger("reset")
                    }
            }
                ,
                ju.prototype = new Jd,
                Io = function () {
                    var l, d, m, p;
                    Io.prototype.init.call(this),
                        p = this,
                        this.packetsWaitingForPmt = [],
                        this.programMapTable = void 0,
                        l = function (g, y) {
                            var S = 0;
                            y.payloadUnitStartIndicator && (S += g[S] + 1),
                                y.type === "pat" ? d(g.subarray(S), y) : m(g.subarray(S), y)
                        }
                        ,
                        d = function (g, y) {
                            y.section_number = g[7],
                                y.last_section_number = g[8],
                                p.pmtPid = (g[10] & 31) << 8 | g[11],
                                y.pmtPid = p.pmtPid
                        }
                        ,
                        m = function (g, y) {
                            var S, C, k, I;
                            if (g[5] & 1) {
                                for (p.programMapTable = {
                                    video: null,
                                    audio: null,
                                    "timed-metadata": {}
                                },
                                    S = (g[1] & 15) << 8 | g[2],
                                    C = 3 + S - 4,
                                    k = (g[10] & 15) << 8 | g[11],
                                    I = 12 + k; I < C;) {
                                    var q = g[I]
                                        , K = (g[I + 1] & 31) << 8 | g[I + 2];
                                    q === Gi.H264_STREAM_TYPE && p.programMapTable.video === null ? p.programMapTable.video = K : q === Gi.ADTS_STREAM_TYPE && p.programMapTable.audio === null ? p.programMapTable.audio = K : q === Gi.METADATA_STREAM_TYPE && (p.programMapTable["timed-metadata"][K] = q),
                                        I += ((g[I + 3] & 15) << 8 | g[I + 4]) + 5
                                }
                                y.programMapTable = p.programMapTable
                            }
                        }
                        ,
                        this.push = function (g) {
                            var y = {}
                                , S = 4;
                            if (y.payloadUnitStartIndicator = !!(g[1] & 64),
                                y.pid = g[1] & 31,
                                y.pid <<= 8,
                                y.pid |= g[2],
                                (g[3] & 48) >>> 4 > 1 && (S += g[S] + 1),
                                y.pid === 0)
                                y.type = "pat",
                                    l(g.subarray(S), y),
                                    this.trigger("data", y);
                            else if (y.pid === this.pmtPid)
                                for (y.type = "pmt",
                                    l(g.subarray(S), y),
                                    this.trigger("data", y); this.packetsWaitingForPmt.length;)
                                    this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
                            else
                                this.programMapTable === void 0 ? this.packetsWaitingForPmt.push([g, S, y]) : this.processPes_(g, S, y)
                        }
                        ,
                        this.processPes_ = function (g, y, S) {
                            S.pid === this.programMapTable.video ? S.streamType = Gi.H264_STREAM_TYPE : S.pid === this.programMapTable.audio ? S.streamType = Gi.ADTS_STREAM_TYPE : S.streamType = this.programMapTable["timed-metadata"][S.pid],
                                S.type = "pes",
                                S.data = g.subarray(y),
                                this.trigger("data", S)
                        }
                }
                ,
                Io.prototype = new Jd,
                Io.STREAM_TYPES = {
                    h264: 27,
                    adts: 15
                },
                Hu = function () {
                    var l = this, d = !1, m = {
                        data: [],
                        size: 0
                    }, p = {
                        data: [],
                        size: 0
                    }, g = {
                        data: [],
                        size: 0
                    }, y, S = function (k, I) {
                        var q;
                        const K = k[0] << 16 | k[1] << 8 | k[2];
                        I.data = new Uint8Array,
                            K === 1 && (I.packetLength = 6 + (k[4] << 8 | k[5]),
                                I.dataAlignmentIndicator = (k[6] & 4) !== 0,
                                q = k[7],
                                q & 192 && (I.pts = (k[9] & 14) << 27 | (k[10] & 255) << 20 | (k[11] & 254) << 12 | (k[12] & 255) << 5 | (k[13] & 254) >>> 3,
                                    I.pts *= 4,
                                    I.pts += (k[13] & 6) >>> 1,
                                    I.dts = I.pts,
                                    q & 64 && (I.dts = (k[14] & 14) << 27 | (k[15] & 255) << 20 | (k[16] & 254) << 12 | (k[17] & 255) << 5 | (k[18] & 254) >>> 3,
                                        I.dts *= 4,
                                        I.dts += (k[18] & 6) >>> 1)),
                                I.data = k.subarray(9 + k[8]))
                    }, C = function (k, I, q) {
                        var K = new Uint8Array(k.size), fe = {
                            type: I
                        }, Q = 0, Ee = 0, Ae = !1, ft;
                        if (!(!k.data.length || k.size < 9)) {
                            for (fe.trackId = k.data[0].pid,
                                Q = 0; Q < k.data.length; Q++)
                                ft = k.data[Q],
                                    K.set(ft.data, Ee),
                                    Ee += ft.data.byteLength;
                            S(K, fe),
                                Ae = I === "video" || fe.packetLength <= k.size,
                                (q || Ae) && (k.size = 0,
                                    k.data.length = 0),
                                Ae && l.trigger("data", fe)
                        }
                    };
                    Hu.prototype.init.call(this),
                        this.push = function (k) {
                            ({
                                pat: function () { },
                                pes: function () {
                                    var I, q;
                                    switch (k.streamType) {
                                        case Gi.H264_STREAM_TYPE:
                                            I = m,
                                                q = "video";
                                            break;
                                        case Gi.ADTS_STREAM_TYPE:
                                            I = p,
                                                q = "audio";
                                            break;
                                        case Gi.METADATA_STREAM_TYPE:
                                            I = g,
                                                q = "timed-metadata";
                                            break;
                                        default:
                                            return
                                    }
                                    k.payloadUnitStartIndicator && C(I, q, !0),
                                        I.data.push(k),
                                        I.size += k.data.byteLength
                                },
                                pmt: function () {
                                    var I = {
                                        type: "metadata",
                                        tracks: []
                                    };
                                    y = k.programMapTable,
                                        y.video !== null && I.tracks.push({
                                            timelineStartInfo: {
                                                baseMediaDecodeTime: 0
                                            },
                                            id: +y.video,
                                            codec: "avc",
                                            type: "video"
                                        }),
                                        y.audio !== null && I.tracks.push({
                                            timelineStartInfo: {
                                                baseMediaDecodeTime: 0
                                            },
                                            id: +y.audio,
                                            codec: "adts",
                                            type: "audio"
                                        }),
                                        d = !0,
                                        l.trigger("data", I)
                                }
                            })[k.type]()
                        }
                        ,
                        this.reset = function () {
                            m.size = 0,
                                m.data.length = 0,
                                p.size = 0,
                                p.data.length = 0,
                                this.trigger("reset")
                        }
                        ,
                        this.flushStreams_ = function () {
                            C(m, "video"),
                                C(p, "audio"),
                                C(g, "timed-metadata")
                        }
                        ,
                        this.flush = function () {
                            if (!d && y) {
                                var k = {
                                    type: "metadata",
                                    tracks: []
                                };
                                y.video !== null && k.tracks.push({
                                    timelineStartInfo: {
                                        baseMediaDecodeTime: 0
                                    },
                                    id: +y.video,
                                    codec: "avc",
                                    type: "video"
                                }),
                                    y.audio !== null && k.tracks.push({
                                        timelineStartInfo: {
                                            baseMediaDecodeTime: 0
                                        },
                                        id: +y.audio,
                                        codec: "adts",
                                        type: "audio"
                                    }),
                                    l.trigger("data", k)
                            }
                            d = !1,
                                this.flushStreams_(),
                                this.trigger("done")
                        }
                }
                ,
                Hu.prototype = new Jd;
            var Vg = {
                PAT_PID: 0,
                MP2T_PACKET_LENGTH: ua,
                TransportPacketStream: ju,
                TransportParseStream: Io,
                ElementaryStream: Hu,
                TimestampRolloverStream: HE,
                CaptionStream: Zd.CaptionStream,
                Cea608Stream: Zd.Cea608Stream,
                Cea708Stream: Zd.Cea708Stream,
                MetadataStream: jE
            };
            for (var tc in Gi)
                Gi.hasOwnProperty(tc) && (Vg[tc] = Gi[tc]);
            var qE = Vg, $E = s, VE = Ne.ONE_SECOND_IN_TS, qu, zg = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
            qu = function (l) {
                var d, m = 0;
                qu.prototype.init.call(this),
                    this.skipWarn_ = function (p, g) {
                        this.trigger("log", {
                            level: "warn",
                            message: `adts skiping bytes ${p} to ${g} in frame ${m} outside syncword`
                        })
                    }
                    ,
                    this.push = function (p) {
                        var g = 0, y, S, C, k, I;
                        if (l || (m = 0),
                            p.type === "audio") {
                            d && d.length ? (C = d,
                                d = new Uint8Array(C.byteLength + p.data.byteLength),
                                d.set(C),
                                d.set(p.data, C.byteLength)) : d = p.data;
                            for (var q; g + 7 < d.length;) {
                                if (d[g] !== 255 || (d[g + 1] & 246) !== 240) {
                                    typeof q != "number" && (q = g),
                                        g++;
                                    continue
                                }
                                if (typeof q == "number" && (this.skipWarn_(q, g),
                                    q = null),
                                    S = (~d[g + 1] & 1) * 2,
                                    y = (d[g + 3] & 3) << 11 | d[g + 4] << 3 | (d[g + 5] & 224) >> 5,
                                    k = ((d[g + 6] & 3) + 1) * 1024,
                                    I = k * VE / zg[(d[g + 2] & 60) >>> 2],
                                    d.byteLength - g < y)
                                    break;
                                this.trigger("data", {
                                    pts: p.pts + m * I,
                                    dts: p.dts + m * I,
                                    sampleCount: k,
                                    audioobjecttype: (d[g + 2] >>> 6 & 3) + 1,
                                    channelcount: (d[g + 2] & 1) << 2 | (d[g + 3] & 192) >>> 6,
                                    samplerate: zg[(d[g + 2] & 60) >>> 2],
                                    samplingfrequencyindex: (d[g + 2] & 60) >>> 2,
                                    samplesize: 16,
                                    data: d.subarray(g + 7 + S, g + y)
                                }),
                                    m++,
                                    g += y
                            }
                            typeof q == "number" && (this.skipWarn_(q, g),
                                q = null),
                                d = d.subarray(g)
                        }
                    }
                    ,
                    this.flush = function () {
                        m = 0,
                            this.trigger("done")
                    }
                    ,
                    this.reset = function () {
                        d = void 0,
                            this.trigger("reset")
                    }
                    ,
                    this.endTimeline = function () {
                        d = void 0,
                            this.trigger("endedtimeline")
                    }
            }
                ,
                qu.prototype = new $E;
            var zE = qu, Gg;
            Gg = function (l) {
                var d = l.byteLength
                    , m = 0
                    , p = 0;
                this.length = function () {
                    return 8 * d
                }
                    ,
                    this.bitsAvailable = function () {
                        return 8 * d + p
                    }
                    ,
                    this.loadWord = function () {
                        var g = l.byteLength - d
                            , y = new Uint8Array(4)
                            , S = Math.min(4, d);
                        if (S === 0)
                            throw new Error("no bytes available");
                        y.set(l.subarray(g, g + S)),
                            m = new DataView(y.buffer).getUint32(0),
                            p = S * 8,
                            d -= S
                    }
                    ,
                    this.skipBits = function (g) {
                        var y;
                        p > g ? (m <<= g,
                            p -= g) : (g -= p,
                                y = Math.floor(g / 8),
                                g -= y * 8,
                                d -= y,
                                this.loadWord(),
                                m <<= g,
                                p -= g)
                    }
                    ,
                    this.readBits = function (g) {
                        var y = Math.min(p, g)
                            , S = m >>> 32 - y;
                        return p -= y,
                            p > 0 ? m <<= y : d > 0 && this.loadWord(),
                            y = g - y,
                            y > 0 ? S << y | this.readBits(y) : S
                    }
                    ,
                    this.skipLeadingZeros = function () {
                        var g;
                        for (g = 0; g < p; ++g)
                            if (m & 2147483648 >>> g)
                                return m <<= g,
                                    p -= g,
                                    g;
                        return this.loadWord(),
                            g + this.skipLeadingZeros()
                    }
                    ,
                    this.skipUnsignedExpGolomb = function () {
                        this.skipBits(1 + this.skipLeadingZeros())
                    }
                    ,
                    this.skipExpGolomb = function () {
                        this.skipBits(1 + this.skipLeadingZeros())
                    }
                    ,
                    this.readUnsignedExpGolomb = function () {
                        var g = this.skipLeadingZeros();
                        return this.readBits(g + 1) - 1
                    }
                    ,
                    this.readExpGolomb = function () {
                        var g = this.readUnsignedExpGolomb();
                        return 1 & g ? 1 + g >>> 1 : -1 * (g >>> 1)
                    }
                    ,
                    this.readBoolean = function () {
                        return this.readBits(1) === 1
                    }
                    ,
                    this.readUnsignedByte = function () {
                        return this.readBits(8)
                    }
                    ,
                    this.loadWord()
            }
                ;
            var GE = Gg, Wg = s, WE = GE, $u, Po, Kg;
            Po = function () {
                var l = 0, d, m;
                Po.prototype.init.call(this),
                    this.push = function (p) {
                        var g;
                        m ? (g = new Uint8Array(m.byteLength + p.data.byteLength),
                            g.set(m),
                            g.set(p.data, m.byteLength),
                            m = g) : m = p.data;
                        for (var y = m.byteLength; l < y - 3; l++)
                            if (m[l + 2] === 1) {
                                d = l + 5;
                                break
                            }
                        for (; d < y;)
                            switch (m[d]) {
                                case 0:
                                    if (m[d - 1] !== 0) {
                                        d += 2;
                                        break
                                    } else if (m[d - 2] !== 0) {
                                        d++;
                                        break
                                    }
                                    l + 3 !== d - 2 && this.trigger("data", m.subarray(l + 3, d - 2));
                                    do
                                        d++;
                                    while (m[d] !== 1 && d < y);
                                    l = d - 2,
                                        d += 3;
                                    break;
                                case 1:
                                    if (m[d - 1] !== 0 || m[d - 2] !== 0) {
                                        d += 3;
                                        break
                                    }
                                    this.trigger("data", m.subarray(l + 3, d - 2)),
                                        l = d - 2,
                                        d += 3;
                                    break;
                                default:
                                    d += 3;
                                    break
                            }
                        m = m.subarray(l),
                            d -= l,
                            l = 0
                    }
                    ,
                    this.reset = function () {
                        m = null,
                            l = 0,
                            this.trigger("reset")
                    }
                    ,
                    this.flush = function () {
                        m && m.byteLength > 3 && this.trigger("data", m.subarray(l + 3)),
                            m = null,
                            l = 0,
                            this.trigger("done")
                    }
                    ,
                    this.endTimeline = function () {
                        this.flush(),
                            this.trigger("endedtimeline")
                    }
            }
                ,
                Po.prototype = new Wg,
                Kg = {
                    100: !0,
                    110: !0,
                    122: !0,
                    244: !0,
                    44: !0,
                    83: !0,
                    86: !0,
                    118: !0,
                    128: !0,
                    138: !0,
                    139: !0,
                    134: !0
                },
                $u = function () {
                    var l = new Po, d, m, p, g, y, S, C;
                    $u.prototype.init.call(this),
                        d = this,
                        this.push = function (k) {
                            k.type === "video" && (m = k.trackId,
                                p = k.pts,
                                g = k.dts,
                                l.push(k))
                        }
                        ,
                        l.on("data", function (k) {
                            var I = {
                                trackId: m,
                                pts: p,
                                dts: g,
                                data: k,
                                nalUnitTypeCode: k[0] & 31
                            };
                            switch (I.nalUnitTypeCode) {
                                case 5:
                                    I.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
                                    break;
                                case 6:
                                    I.nalUnitType = "sei_rbsp",
                                        I.escapedRBSP = y(k.subarray(1));
                                    break;
                                case 7:
                                    I.nalUnitType = "seq_parameter_set_rbsp",
                                        I.escapedRBSP = y(k.subarray(1)),
                                        I.config = S(I.escapedRBSP);
                                    break;
                                case 8:
                                    I.nalUnitType = "pic_parameter_set_rbsp";
                                    break;
                                case 9:
                                    I.nalUnitType = "access_unit_delimiter_rbsp";
                                    break
                            }
                            d.trigger("data", I)
                        }),
                        l.on("done", function () {
                            d.trigger("done")
                        }),
                        l.on("partialdone", function () {
                            d.trigger("partialdone")
                        }),
                        l.on("reset", function () {
                            d.trigger("reset")
                        }),
                        l.on("endedtimeline", function () {
                            d.trigger("endedtimeline")
                        }),
                        this.flush = function () {
                            l.flush()
                        }
                        ,
                        this.partialFlush = function () {
                            l.partialFlush()
                        }
                        ,
                        this.reset = function () {
                            l.reset()
                        }
                        ,
                        this.endTimeline = function () {
                            l.endTimeline()
                        }
                        ,
                        C = function (k, I) {
                            var q = 8, K = 8, fe, Q;
                            for (fe = 0; fe < k; fe++)
                                K !== 0 && (Q = I.readExpGolomb(),
                                    K = (q + Q + 256) % 256),
                                    q = K === 0 ? q : K
                        }
                        ,
                        y = function (k) {
                            for (var I = k.byteLength, q = [], K = 1, fe, Q; K < I - 2;)
                                k[K] === 0 && k[K + 1] === 0 && k[K + 2] === 3 ? (q.push(K + 2),
                                    K += 2) : K++;
                            if (q.length === 0)
                                return k;
                            fe = I - q.length,
                                Q = new Uint8Array(fe);
                            var Ee = 0;
                            for (K = 0; K < fe; Ee++,
                                K++)
                                Ee === q[0] && (Ee++,
                                    q.shift()),
                                    Q[K] = k[Ee];
                            return Q
                        }
                        ,
                        S = function (k) {
                            var I = 0, q = 0, K = 0, fe = 0, Q, Ee, Ae, ft, Ii, Kr, Ev, Sv, Cv, cc, Av, ot = [1, 1], wv, Xr;
                            if (Q = new WE(k),
                                Ee = Q.readUnsignedByte(),
                                ft = Q.readUnsignedByte(),
                                Ae = Q.readUnsignedByte(),
                                Q.skipUnsignedExpGolomb(),
                                Kg[Ee] && (Ii = Q.readUnsignedExpGolomb(),
                                    Ii === 3 && Q.skipBits(1),
                                    Q.skipUnsignedExpGolomb(),
                                    Q.skipUnsignedExpGolomb(),
                                    Q.skipBits(1),
                                    Q.readBoolean()))
                                for (Av = Ii !== 3 ? 8 : 12,
                                    Xr = 0; Xr < Av; Xr++)
                                    Q.readBoolean() && (Xr < 6 ? C(16, Q) : C(64, Q));
                            if (Q.skipUnsignedExpGolomb(),
                                Kr = Q.readUnsignedExpGolomb(),
                                Kr === 0)
                                Q.readUnsignedExpGolomb();
                            else if (Kr === 1)
                                for (Q.skipBits(1),
                                    Q.skipExpGolomb(),
                                    Q.skipExpGolomb(),
                                    Ev = Q.readUnsignedExpGolomb(),
                                    Xr = 0; Xr < Ev; Xr++)
                                    Q.skipExpGolomb();
                            if (Q.skipUnsignedExpGolomb(),
                                Q.skipBits(1),
                                Sv = Q.readUnsignedExpGolomb(),
                                Cv = Q.readUnsignedExpGolomb(),
                                cc = Q.readBits(1),
                                cc === 0 && Q.skipBits(1),
                                Q.skipBits(1),
                                Q.readBoolean() && (I = Q.readUnsignedExpGolomb(),
                                    q = Q.readUnsignedExpGolomb(),
                                    K = Q.readUnsignedExpGolomb(),
                                    fe = Q.readUnsignedExpGolomb()),
                                Q.readBoolean() && Q.readBoolean()) {
                                switch (wv = Q.readUnsignedByte(),
                                wv) {
                                    case 1:
                                        ot = [1, 1];
                                        break;
                                    case 2:
                                        ot = [12, 11];
                                        break;
                                    case 3:
                                        ot = [10, 11];
                                        break;
                                    case 4:
                                        ot = [16, 11];
                                        break;
                                    case 5:
                                        ot = [40, 33];
                                        break;
                                    case 6:
                                        ot = [24, 11];
                                        break;
                                    case 7:
                                        ot = [20, 11];
                                        break;
                                    case 8:
                                        ot = [32, 11];
                                        break;
                                    case 9:
                                        ot = [80, 33];
                                        break;
                                    case 10:
                                        ot = [18, 11];
                                        break;
                                    case 11:
                                        ot = [15, 11];
                                        break;
                                    case 12:
                                        ot = [64, 33];
                                        break;
                                    case 13:
                                        ot = [160, 99];
                                        break;
                                    case 14:
                                        ot = [4, 3];
                                        break;
                                    case 15:
                                        ot = [3, 2];
                                        break;
                                    case 16:
                                        ot = [2, 1];
                                        break;
                                    case 255:
                                        {
                                            ot = [Q.readUnsignedByte() << 8 | Q.readUnsignedByte(), Q.readUnsignedByte() << 8 | Q.readUnsignedByte()];
                                            break
                                        }
                                }
                                ot && ot[0] / ot[1]
                            }
                            return {
                                profileIdc: Ee,
                                levelIdc: Ae,
                                profileCompatibility: ft,
                                width: (Sv + 1) * 16 - I * 2 - q * 2,
                                height: (2 - cc) * (Cv + 1) * 16 - K * 2 - fe * 2,
                                sarRatio: ot
                            }
                        }
                }
                ,
                $u.prototype = new Wg;
            var KE = {
                H264Stream: $u,
                NalByteStream: Po
            }, XE = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], Xg = function (l, d) {
                var m = l[d + 6] << 21 | l[d + 7] << 14 | l[d + 8] << 7 | l[d + 9]
                    , p = l[d + 5]
                    , g = (p & 16) >> 4;
                return m = m >= 0 ? m : 0,
                    g ? m + 20 : m + 10
            }, Yg = function (l, d) {
                return l.length - d < 10 || l[d] !== "I".charCodeAt(0) || l[d + 1] !== "D".charCodeAt(0) || l[d + 2] !== "3".charCodeAt(0) ? d : (d += Xg(l, d),
                    Yg(l, d))
            }, YE = function (l) {
                var d = Yg(l, 0);
                return l.length >= d + 2 && (l[d] & 255) === 255 && (l[d + 1] & 240) === 240 && (l[d + 1] & 22) === 16
            }, Qg = function (l) {
                return l[0] << 21 | l[1] << 14 | l[2] << 7 | l[3]
            }, QE = function (l, d, m) {
                var p, g = "";
                for (p = d; p < m; p++)
                    g += "%" + ("00" + l[p].toString(16)).slice(-2);
                return g
            }, JE = function (l, d, m) {
                return unescape(QE(l, d, m))
            }, ZE = function (l, d) {
                var m = (l[d + 5] & 224) >> 5
                    , p = l[d + 4] << 3
                    , g = l[d + 3] & 6144;
                return g | p | m
            }, eS = function (l, d) {
                return l[d] === "I".charCodeAt(0) && l[d + 1] === "D".charCodeAt(0) && l[d + 2] === "3".charCodeAt(0) ? "timed-metadata" : l[d] & !0 && (l[d + 1] & 240) === 240 ? "audio" : null
            }, tS = function (l) {
                for (var d = 0; d + 5 < l.length;) {
                    if (l[d] !== 255 || (l[d + 1] & 246) !== 240) {
                        d++;
                        continue
                    }
                    return XE[(l[d + 2] & 60) >>> 2]
                }
                return null
            }, iS = function (l) {
                var d, m, p, g;
                d = 10,
                    l[5] & 64 && (d += 4,
                        d += Qg(l.subarray(10, 14)));
                do {
                    if (m = Qg(l.subarray(d + 4, d + 8)),
                        m < 1)
                        return null;
                    if (g = String.fromCharCode(l[d], l[d + 1], l[d + 2], l[d + 3]),
                        g === "PRIV") {
                        p = l.subarray(d + 10, d + m + 10);
                        for (var y = 0; y < p.byteLength; y++)
                            if (p[y] === 0) {
                                var S = JE(p, 0, y);
                                if (S === "com.apple.streaming.transportStreamTimestamp") {
                                    var C = p.subarray(y + 1)
                                        , k = (C[3] & 1) << 30 | C[4] << 22 | C[5] << 14 | C[6] << 6 | C[7] >>> 2;
                                    return k *= 4,
                                        k += C[7] & 3,
                                        k
                                }
                                break
                            }
                    }
                    d += 10,
                        d += m
                } while (d < l.byteLength);
                return null
            }, ic = {
                isLikelyAacData: YE,
                parseId3TagSize: Xg,
                parseAdtsSize: ZE,
                parseType: eS,
                parseSampleRate: tS,
                parseAacTimestamp: iS
            }, sS = s, Jg = ic, Vu;
            Vu = function () {
                var l = new Uint8Array
                    , d = 0;
                Vu.prototype.init.call(this),
                    this.setTimestamp = function (m) {
                        d = m
                    }
                    ,
                    this.push = function (m) {
                        var p = 0, g = 0, y, S, C, k;
                        for (l.length ? (k = l.length,
                            l = new Uint8Array(m.byteLength + k),
                            l.set(l.subarray(0, k)),
                            l.set(m, k)) : l = m; l.length - g >= 3;) {
                            if (l[g] === "I".charCodeAt(0) && l[g + 1] === "D".charCodeAt(0) && l[g + 2] === "3".charCodeAt(0)) {
                                if (l.length - g < 10 || (p = Jg.parseId3TagSize(l, g),
                                    g + p > l.length))
                                    break;
                                S = {
                                    type: "timed-metadata",
                                    data: l.subarray(g, g + p)
                                },
                                    this.trigger("data", S),
                                    g += p;
                                continue
                            } else if ((l[g] & 255) === 255 && (l[g + 1] & 240) === 240) {
                                if (l.length - g < 7 || (p = Jg.parseAdtsSize(l, g),
                                    g + p > l.length))
                                    break;
                                C = {
                                    type: "audio",
                                    data: l.subarray(g, g + p),
                                    pts: d,
                                    dts: d
                                },
                                    this.trigger("data", C),
                                    g += p;
                                continue
                            }
                            g++
                        }
                        y = l.length - g,
                            y > 0 ? l = l.subarray(g) : l = new Uint8Array
                    }
                    ,
                    this.reset = function () {
                        l = new Uint8Array,
                            this.trigger("reset")
                    }
                    ,
                    this.endTimeline = function () {
                        l = new Uint8Array,
                            this.trigger("endedtimeline")
                    }
            }
                ,
                Vu.prototype = new sS;
            var rS = Vu, nS = ["audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize"], aS = nS, oS = ["width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio"], lS = oS, zu = s, Lo = ke, Oo = Ze, Gu = sa, Wi = Eo, js = qE, Wu = Ne, Zg = zE, uS = KE.H264Stream, hS = rS, dS = ic.isLikelyAacData, cS = Ne.ONE_SECOND_IN_TS, sc = aS, rc = lS, Mo, ha, Ku, Gr, fS = function (l, d) {
                d.stream = l,
                    this.trigger("log", d)
            }, ev = function (l, d) {
                for (var m = Object.keys(d), p = 0; p < m.length; p++) {
                    var g = m[p];
                    g === "headOfPipeline" || !d[g].on || d[g].on("log", fS.bind(l, g))
                }
            }, tv = function (l, d) {
                var m;
                if (l.length !== d.length)
                    return !1;
                for (m = 0; m < l.length; m++)
                    if (l[m] !== d[m])
                        return !1;
                return !0
            }, nc = function (l, d, m, p, g, y) {
                var S = m - d
                    , C = p - d
                    , k = g - m;
                return {
                    start: {
                        dts: l,
                        pts: l + S
                    },
                    end: {
                        dts: l + C,
                        pts: l + k
                    },
                    prependedContentDuration: y,
                    baseMediaDecodeTime: l
                }
            };
            ha = function (l, d) {
                var m = [], p, g = 0, y = 0, S = 1 / 0;
                d = d || {},
                    p = d.firstSequenceNumber || 0,
                    ha.prototype.init.call(this),
                    this.push = function (C) {
                        Wi.collectDtsInfo(l, C),
                            l && sc.forEach(function (k) {
                                l[k] = C[k]
                            }),
                            m.push(C)
                    }
                    ,
                    this.setEarliestDts = function (C) {
                        g = C
                    }
                    ,
                    this.setVideoBaseMediaDecodeTime = function (C) {
                        S = C
                    }
                    ,
                    this.setAudioAppendStart = function (C) {
                        y = C
                    }
                    ,
                    this.flush = function () {
                        var C, k, I, q, K, fe, Q;
                        if (m.length === 0) {
                            this.trigger("done", "AudioSegmentStream");
                            return
                        }
                        C = Gu.trimAdtsFramesByEarliestDts(m, l, g),
                            l.baseMediaDecodeTime = Wi.calculateTrackBaseMediaDecodeTime(l, d.keepOriginalTimestamps),
                            Q = Gu.prefixWithSilence(l, C, y, S),
                            l.samples = Gu.generateSampleTable(C),
                            I = Lo.mdat(Gu.concatenateFrameData(C)),
                            m = [],
                            k = Lo.moof(p, [l]),
                            q = new Uint8Array(k.byteLength + I.byteLength),
                            p++,
                            q.set(k),
                            q.set(I, k.byteLength),
                            Wi.clearDtsInfo(l),
                            K = Math.ceil(cS * 1024 / l.samplerate),
                            C.length && (fe = C.length * K,
                                this.trigger("segmentTimingInfo", nc(Wu.audioTsToVideoTs(l.baseMediaDecodeTime, l.samplerate), C[0].dts, C[0].pts, C[0].dts + fe, C[0].pts + fe, Q || 0)),
                                this.trigger("timingInfo", {
                                    start: C[0].pts,
                                    end: C[0].pts + fe
                                })),
                            this.trigger("data", {
                                track: l,
                                boxes: q
                            }),
                            this.trigger("done", "AudioSegmentStream")
                    }
                    ,
                    this.reset = function () {
                        Wi.clearDtsInfo(l),
                            m = [],
                            this.trigger("reset")
                    }
            }
                ,
                ha.prototype = new zu,
                Mo = function (l, d) {
                    var m, p = [], g = [], y, S;
                    d = d || {},
                        m = d.firstSequenceNumber || 0,
                        Mo.prototype.init.call(this),
                        delete l.minPTS,
                        this.gopCache_ = [],
                        this.push = function (C) {
                            Wi.collectDtsInfo(l, C),
                                C.nalUnitType === "seq_parameter_set_rbsp" && !y && (y = C.config,
                                    l.sps = [C.data],
                                    rc.forEach(function (k) {
                                        l[k] = y[k]
                                    }, this)),
                                C.nalUnitType === "pic_parameter_set_rbsp" && !S && (S = C.data,
                                    l.pps = [C.data]),
                                p.push(C)
                        }
                        ,
                        this.flush = function () {
                            for (var C, k, I, q, K, fe, Q = 0, Ee, Ae; p.length && p[0].nalUnitType !== "access_unit_delimiter_rbsp";)
                                p.shift();
                            if (p.length === 0) {
                                this.resetStream_(),
                                    this.trigger("done", "VideoSegmentStream");
                                return
                            }
                            if (C = Oo.groupNalsIntoFrames(p),
                                I = Oo.groupFramesIntoGops(C),
                                I[0][0].keyFrame || (k = this.getGopForFusion_(p[0], l),
                                    k ? (Q = k.duration,
                                        I.unshift(k),
                                        I.byteLength += k.byteLength,
                                        I.nalCount += k.nalCount,
                                        I.pts = k.pts,
                                        I.dts = k.dts,
                                        I.duration += k.duration) : I = Oo.extendFirstKeyFrame(I)),
                                g.length) {
                                var ft;
                                if (d.alignGopsAtEnd ? ft = this.alignGopsAtEnd_(I) : ft = this.alignGopsAtStart_(I),
                                    !ft) {
                                    this.gopCache_.unshift({
                                        gop: I.pop(),
                                        pps: l.pps,
                                        sps: l.sps
                                    }),
                                        this.gopCache_.length = Math.min(6, this.gopCache_.length),
                                        p = [],
                                        this.resetStream_(),
                                        this.trigger("done", "VideoSegmentStream");
                                    return
                                }
                                Wi.clearDtsInfo(l),
                                    I = ft
                            }
                            Wi.collectDtsInfo(l, I),
                                l.samples = Oo.generateSampleTable(I),
                                K = Lo.mdat(Oo.concatenateNalData(I)),
                                l.baseMediaDecodeTime = Wi.calculateTrackBaseMediaDecodeTime(l, d.keepOriginalTimestamps),
                                this.trigger("processedGopsInfo", I.map(function (Ii) {
                                    return {
                                        pts: Ii.pts,
                                        dts: Ii.dts,
                                        byteLength: Ii.byteLength
                                    }
                                })),
                                Ee = I[0],
                                Ae = I[I.length - 1],
                                this.trigger("segmentTimingInfo", nc(l.baseMediaDecodeTime, Ee.dts, Ee.pts, Ae.dts + Ae.duration, Ae.pts + Ae.duration, Q)),
                                this.trigger("timingInfo", {
                                    start: I[0].pts,
                                    end: I[I.length - 1].pts + I[I.length - 1].duration
                                }),
                                this.gopCache_.unshift({
                                    gop: I.pop(),
                                    pps: l.pps,
                                    sps: l.sps
                                }),
                                this.gopCache_.length = Math.min(6, this.gopCache_.length),
                                p = [],
                                this.trigger("baseMediaDecodeTime", l.baseMediaDecodeTime),
                                this.trigger("timelineStartInfo", l.timelineStartInfo),
                                q = Lo.moof(m, [l]),
                                fe = new Uint8Array(q.byteLength + K.byteLength),
                                m++,
                                fe.set(q),
                                fe.set(K, q.byteLength),
                                this.trigger("data", {
                                    track: l,
                                    boxes: fe
                                }),
                                this.resetStream_(),
                                this.trigger("done", "VideoSegmentStream")
                        }
                        ,
                        this.reset = function () {
                            this.resetStream_(),
                                p = [],
                                this.gopCache_.length = 0,
                                g.length = 0,
                                this.trigger("reset")
                        }
                        ,
                        this.resetStream_ = function () {
                            Wi.clearDtsInfo(l),
                                y = void 0,
                                S = void 0
                        }
                        ,
                        this.getGopForFusion_ = function (C) {
                            var k = 45e3, I = 1e4, q = 1 / 0, K, fe, Q, Ee, Ae;
                            for (Ae = 0; Ae < this.gopCache_.length; Ae++)
                                Ee = this.gopCache_[Ae],
                                    Q = Ee.gop,
                                    !(!(l.pps && tv(l.pps[0], Ee.pps[0])) || !(l.sps && tv(l.sps[0], Ee.sps[0]))) && (Q.dts < l.timelineStartInfo.dts || (K = C.dts - Q.dts - Q.duration,
                                        K >= -I && K <= k && (!fe || q > K) && (fe = Ee,
                                            q = K)));
                            return fe ? fe.gop : null
                        }
                        ,
                        this.alignGopsAtStart_ = function (C) {
                            var k, I, q, K, fe, Q, Ee, Ae;
                            for (fe = C.byteLength,
                                Q = C.nalCount,
                                Ee = C.duration,
                                k = I = 0; k < g.length && I < C.length && (q = g[k],
                                    K = C[I],
                                    q.pts !== K.pts);) {
                                if (K.pts > q.pts) {
                                    k++;
                                    continue
                                }
                                I++,
                                    fe -= K.byteLength,
                                    Q -= K.nalCount,
                                    Ee -= K.duration
                            }
                            return I === 0 ? C : I === C.length ? null : (Ae = C.slice(I),
                                Ae.byteLength = fe,
                                Ae.duration = Ee,
                                Ae.nalCount = Q,
                                Ae.pts = Ae[0].pts,
                                Ae.dts = Ae[0].dts,
                                Ae)
                        }
                        ,
                        this.alignGopsAtEnd_ = function (C) {
                            var k, I, q, K, fe, Q;
                            for (k = g.length - 1,
                                I = C.length - 1,
                                fe = null,
                                Q = !1; k >= 0 && I >= 0;) {
                                if (q = g[k],
                                    K = C[I],
                                    q.pts === K.pts) {
                                    Q = !0;
                                    break
                                }
                                if (q.pts > K.pts) {
                                    k--;
                                    continue
                                }
                                k === g.length - 1 && (fe = I),
                                    I--
                            }
                            if (!Q && fe === null)
                                return null;
                            var Ee;
                            if (Q ? Ee = I : Ee = fe,
                                Ee === 0)
                                return C;
                            var Ae = C.slice(Ee)
                                , ft = Ae.reduce(function (Ii, Kr) {
                                    return Ii.byteLength += Kr.byteLength,
                                        Ii.duration += Kr.duration,
                                        Ii.nalCount += Kr.nalCount,
                                        Ii
                                }, {
                                    byteLength: 0,
                                    duration: 0,
                                    nalCount: 0
                                });
                            return Ae.byteLength = ft.byteLength,
                                Ae.duration = ft.duration,
                                Ae.nalCount = ft.nalCount,
                                Ae.pts = Ae[0].pts,
                                Ae.dts = Ae[0].dts,
                                Ae
                        }
                        ,
                        this.alignGopsWith = function (C) {
                            g = C
                        }
                }
                ,
                Mo.prototype = new zu,
                Gr = function (l, d) {
                    this.numberOfTracks = 0,
                        this.metadataStream = d,
                        l = l || {},
                        typeof l.remux < "u" ? this.remuxTracks = !!l.remux : this.remuxTracks = !0,
                        typeof l.keepOriginalTimestamps == "boolean" ? this.keepOriginalTimestamps = l.keepOriginalTimestamps : this.keepOriginalTimestamps = !1,
                        this.pendingTracks = [],
                        this.videoTrack = null,
                        this.pendingBoxes = [],
                        this.pendingCaptions = [],
                        this.pendingMetadata = [],
                        this.pendingBytes = 0,
                        this.emittedTracks = 0,
                        Gr.prototype.init.call(this),
                        this.push = function (m) {
                            if (m.content || m.text)
                                return this.pendingCaptions.push(m);
                            if (m.frames)
                                return this.pendingMetadata.push(m);
                            this.pendingTracks.push(m.track),
                                this.pendingBytes += m.boxes.byteLength,
                                m.track.type === "video" && (this.videoTrack = m.track,
                                    this.pendingBoxes.push(m.boxes)),
                                m.track.type === "audio" && (this.audioTrack = m.track,
                                    this.pendingBoxes.unshift(m.boxes))
                        }
                }
                ,
                Gr.prototype = new zu,
                Gr.prototype.flush = function (l) {
                    var d = 0, m = {
                        captions: [],
                        captionStreams: {},
                        metadata: [],
                        info: {}
                    }, p, g, y, S = 0, C;
                    if (this.pendingTracks.length < this.numberOfTracks) {
                        if (l !== "VideoSegmentStream" && l !== "AudioSegmentStream")
                            return;
                        if (this.remuxTracks)
                            return;
                        if (this.pendingTracks.length === 0) {
                            this.emittedTracks++,
                                this.emittedTracks >= this.numberOfTracks && (this.trigger("done"),
                                    this.emittedTracks = 0);
                            return
                        }
                    }
                    if (this.videoTrack ? (S = this.videoTrack.timelineStartInfo.pts,
                        rc.forEach(function (k) {
                            m.info[k] = this.videoTrack[k]
                        }, this)) : this.audioTrack && (S = this.audioTrack.timelineStartInfo.pts,
                            sc.forEach(function (k) {
                                m.info[k] = this.audioTrack[k]
                            }, this)),
                        this.videoTrack || this.audioTrack) {
                        for (this.pendingTracks.length === 1 ? m.type = this.pendingTracks[0].type : m.type = "combined",
                            this.emittedTracks += this.pendingTracks.length,
                            y = Lo.initSegment(this.pendingTracks),
                            m.initSegment = new Uint8Array(y.byteLength),
                            m.initSegment.set(y),
                            m.data = new Uint8Array(this.pendingBytes),
                            C = 0; C < this.pendingBoxes.length; C++)
                            m.data.set(this.pendingBoxes[C], d),
                                d += this.pendingBoxes[C].byteLength;
                        for (C = 0; C < this.pendingCaptions.length; C++)
                            p = this.pendingCaptions[C],
                                p.startTime = Wu.metadataTsToSeconds(p.startPts, S, this.keepOriginalTimestamps),
                                p.endTime = Wu.metadataTsToSeconds(p.endPts, S, this.keepOriginalTimestamps),
                                m.captionStreams[p.stream] = !0,
                                m.captions.push(p);
                        for (C = 0; C < this.pendingMetadata.length; C++)
                            g = this.pendingMetadata[C],
                                g.cueTime = Wu.metadataTsToSeconds(g.pts, S, this.keepOriginalTimestamps),
                                m.metadata.push(g);
                        for (m.metadata.dispatchType = this.metadataStream.dispatchType,
                            this.pendingTracks.length = 0,
                            this.videoTrack = null,
                            this.pendingBoxes.length = 0,
                            this.pendingCaptions.length = 0,
                            this.pendingBytes = 0,
                            this.pendingMetadata.length = 0,
                            this.trigger("data", m),
                            C = 0; C < m.captions.length; C++)
                            p = m.captions[C],
                                this.trigger("caption", p);
                        for (C = 0; C < m.metadata.length; C++)
                            g = m.metadata[C],
                                this.trigger("id3Frame", g)
                    }
                    this.emittedTracks >= this.numberOfTracks && (this.trigger("done"),
                        this.emittedTracks = 0)
                }
                ,
                Gr.prototype.setRemux = function (l) {
                    this.remuxTracks = l
                }
                ,
                Ku = function (l) {
                    var d = this, m = !0, p, g;
                    Ku.prototype.init.call(this),
                        l = l || {},
                        this.baseMediaDecodeTime = l.baseMediaDecodeTime || 0,
                        this.transmuxPipeline_ = {},
                        this.setupAacPipeline = function () {
                            var y = {};
                            this.transmuxPipeline_ = y,
                                y.type = "aac",
                                y.metadataStream = new js.MetadataStream,
                                y.aacStream = new hS,
                                y.audioTimestampRolloverStream = new js.TimestampRolloverStream("audio"),
                                y.timedMetadataTimestampRolloverStream = new js.TimestampRolloverStream("timed-metadata"),
                                y.adtsStream = new Zg,
                                y.coalesceStream = new Gr(l, y.metadataStream),
                                y.headOfPipeline = y.aacStream,
                                y.aacStream.pipe(y.audioTimestampRolloverStream).pipe(y.adtsStream),
                                y.aacStream.pipe(y.timedMetadataTimestampRolloverStream).pipe(y.metadataStream).pipe(y.coalesceStream),
                                y.metadataStream.on("timestamp", function (S) {
                                    y.aacStream.setTimestamp(S.timeStamp)
                                }),
                                y.aacStream.on("data", function (S) {
                                    S.type !== "timed-metadata" && S.type !== "audio" || y.audioSegmentStream || (g = g || {
                                        timelineStartInfo: {
                                            baseMediaDecodeTime: d.baseMediaDecodeTime
                                        },
                                        codec: "adts",
                                        type: "audio"
                                    },
                                        y.coalesceStream.numberOfTracks++,
                                        y.audioSegmentStream = new ha(g, l),
                                        y.audioSegmentStream.on("log", d.getLogTrigger_("audioSegmentStream")),
                                        y.audioSegmentStream.on("timingInfo", d.trigger.bind(d, "audioTimingInfo")),
                                        y.adtsStream.pipe(y.audioSegmentStream).pipe(y.coalesceStream),
                                        d.trigger("trackinfo", {
                                            hasAudio: !!g,
                                            hasVideo: !!p
                                        }))
                                }),
                                y.coalesceStream.on("data", this.trigger.bind(this, "data")),
                                y.coalesceStream.on("done", this.trigger.bind(this, "done")),
                                ev(this, y)
                        }
                        ,
                        this.setupTsPipeline = function () {
                            var y = {};
                            this.transmuxPipeline_ = y,
                                y.type = "ts",
                                y.metadataStream = new js.MetadataStream,
                                y.packetStream = new js.TransportPacketStream,
                                y.parseStream = new js.TransportParseStream,
                                y.elementaryStream = new js.ElementaryStream,
                                y.timestampRolloverStream = new js.TimestampRolloverStream,
                                y.adtsStream = new Zg,
                                y.h264Stream = new uS,
                                y.captionStream = new js.CaptionStream(l),
                                y.coalesceStream = new Gr(l, y.metadataStream),
                                y.headOfPipeline = y.packetStream,
                                y.packetStream.pipe(y.parseStream).pipe(y.elementaryStream).pipe(y.timestampRolloverStream),
                                y.timestampRolloverStream.pipe(y.h264Stream),
                                y.timestampRolloverStream.pipe(y.adtsStream),
                                y.timestampRolloverStream.pipe(y.metadataStream).pipe(y.coalesceStream),
                                y.h264Stream.pipe(y.captionStream).pipe(y.coalesceStream),
                                y.elementaryStream.on("data", function (S) {
                                    var C;
                                    if (S.type === "metadata") {
                                        for (C = S.tracks.length; C--;)
                                            !p && S.tracks[C].type === "video" ? (p = S.tracks[C],
                                                p.timelineStartInfo.baseMediaDecodeTime = d.baseMediaDecodeTime) : !g && S.tracks[C].type === "audio" && (g = S.tracks[C],
                                                    g.timelineStartInfo.baseMediaDecodeTime = d.baseMediaDecodeTime);
                                        p && !y.videoSegmentStream && (y.coalesceStream.numberOfTracks++,
                                            y.videoSegmentStream = new Mo(p, l),
                                            y.videoSegmentStream.on("log", d.getLogTrigger_("videoSegmentStream")),
                                            y.videoSegmentStream.on("timelineStartInfo", function (k) {
                                                g && !l.keepOriginalTimestamps && (g.timelineStartInfo = k,
                                                    y.audioSegmentStream.setEarliestDts(k.dts - d.baseMediaDecodeTime))
                                            }),
                                            y.videoSegmentStream.on("processedGopsInfo", d.trigger.bind(d, "gopInfo")),
                                            y.videoSegmentStream.on("segmentTimingInfo", d.trigger.bind(d, "videoSegmentTimingInfo")),
                                            y.videoSegmentStream.on("baseMediaDecodeTime", function (k) {
                                                g && y.audioSegmentStream.setVideoBaseMediaDecodeTime(k)
                                            }),
                                            y.videoSegmentStream.on("timingInfo", d.trigger.bind(d, "videoTimingInfo")),
                                            y.h264Stream.pipe(y.videoSegmentStream).pipe(y.coalesceStream)),
                                            g && !y.audioSegmentStream && (y.coalesceStream.numberOfTracks++,
                                                y.audioSegmentStream = new ha(g, l),
                                                y.audioSegmentStream.on("log", d.getLogTrigger_("audioSegmentStream")),
                                                y.audioSegmentStream.on("timingInfo", d.trigger.bind(d, "audioTimingInfo")),
                                                y.audioSegmentStream.on("segmentTimingInfo", d.trigger.bind(d, "audioSegmentTimingInfo")),
                                                y.adtsStream.pipe(y.audioSegmentStream).pipe(y.coalesceStream)),
                                            d.trigger("trackinfo", {
                                                hasAudio: !!g,
                                                hasVideo: !!p
                                            })
                                    }
                                }),
                                y.coalesceStream.on("data", this.trigger.bind(this, "data")),
                                y.coalesceStream.on("id3Frame", function (S) {
                                    S.dispatchType = y.metadataStream.dispatchType,
                                        d.trigger("id3Frame", S)
                                }),
                                y.coalesceStream.on("caption", this.trigger.bind(this, "caption")),
                                y.coalesceStream.on("done", this.trigger.bind(this, "done")),
                                ev(this, y)
                        }
                        ,
                        this.setBaseMediaDecodeTime = function (y) {
                            var S = this.transmuxPipeline_;
                            l.keepOriginalTimestamps || (this.baseMediaDecodeTime = y),
                                g && (g.timelineStartInfo.dts = void 0,
                                    g.timelineStartInfo.pts = void 0,
                                    Wi.clearDtsInfo(g),
                                    S.audioTimestampRolloverStream && S.audioTimestampRolloverStream.discontinuity()),
                                p && (S.videoSegmentStream && (S.videoSegmentStream.gopCache_ = []),
                                    p.timelineStartInfo.dts = void 0,
                                    p.timelineStartInfo.pts = void 0,
                                    Wi.clearDtsInfo(p),
                                    S.captionStream.reset()),
                                S.timestampRolloverStream && S.timestampRolloverStream.discontinuity()
                        }
                        ,
                        this.setAudioAppendStart = function (y) {
                            g && this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(y)
                        }
                        ,
                        this.setRemux = function (y) {
                            var S = this.transmuxPipeline_;
                            l.remux = y,
                                S && S.coalesceStream && S.coalesceStream.setRemux(y)
                        }
                        ,
                        this.alignGopsWith = function (y) {
                            p && this.transmuxPipeline_.videoSegmentStream && this.transmuxPipeline_.videoSegmentStream.alignGopsWith(y)
                        }
                        ,
                        this.getLogTrigger_ = function (y) {
                            var S = this;
                            return function (C) {
                                C.stream = y,
                                    S.trigger("log", C)
                            }
                        }
                        ,
                        this.push = function (y) {
                            if (m) {
                                var S = dS(y);
                                S && this.transmuxPipeline_.type !== "aac" ? this.setupAacPipeline() : !S && this.transmuxPipeline_.type !== "ts" && this.setupTsPipeline(),
                                    m = !1
                            }
                            this.transmuxPipeline_.headOfPipeline.push(y)
                        }
                        ,
                        this.flush = function () {
                            m = !0,
                                this.transmuxPipeline_.headOfPipeline.flush()
                        }
                        ,
                        this.endTimeline = function () {
                            this.transmuxPipeline_.headOfPipeline.endTimeline()
                        }
                        ,
                        this.reset = function () {
                            this.transmuxPipeline_.headOfPipeline && this.transmuxPipeline_.headOfPipeline.reset()
                        }
                        ,
                        this.resetCaptions = function () {
                            this.transmuxPipeline_.captionStream && this.transmuxPipeline_.captionStream.reset()
                        }
                }
                ,
                Ku.prototype = new zu;
            var pS = {
                Transmuxer: Ku,
                VideoSegmentStream: Mo,
                AudioSegmentStream: ha,
                AUDIO_PROPERTIES: sc,
                VIDEO_PROPERTIES: rc,
                generateSegmentTimingInfo: nc
            }, mS = function (l) {
                return l >>> 0
            }, gS = function (l) {
                return ("00" + l.toString(16)).slice(-2)
            }, Xu = {
                toUnsigned: mS,
                toHexString: gS
            }, vS = function (l) {
                var d = "";
                return d += String.fromCharCode(l[0]),
                    d += String.fromCharCode(l[1]),
                    d += String.fromCharCode(l[2]),
                    d += String.fromCharCode(l[3]),
                    d
            }, iv = vS, yS = Xu.toUnsigned, _S = iv, sv = function (l, d) {
                var m = [], p, g, y, S, C;
                if (!d.length)
                    return null;
                for (p = 0; p < l.byteLength;)
                    g = yS(l[p] << 24 | l[p + 1] << 16 | l[p + 2] << 8 | l[p + 3]),
                        y = _S(l.subarray(p + 4, p + 8)),
                        S = g > 1 ? p + g : l.byteLength,
                        y === d[0] && (d.length === 1 ? m.push(l.subarray(p + 8, S)) : (C = sv(l.subarray(p + 8, S), d.slice(1)),
                            C.length && (m = m.concat(C)))),
                        p = S;
                return m
            }, rv = sv, TS = Xu.toUnsigned, bS = a.getUint64, ES = function (l) {
                var d = {
                    version: l[0],
                    flags: new Uint8Array(l.subarray(1, 4))
                };
                return d.version === 1 ? d.baseMediaDecodeTime = bS(l.subarray(4)) : d.baseMediaDecodeTime = TS(l[4] << 24 | l[5] << 16 | l[6] << 8 | l[7]),
                    d
            }, nv = ES, SS = function (l) {
                return {
                    isLeading: (l[0] & 12) >>> 2,
                    dependsOn: l[0] & 3,
                    isDependedOn: (l[1] & 192) >>> 6,
                    hasRedundancy: (l[1] & 48) >>> 4,
                    paddingValue: (l[1] & 14) >>> 1,
                    isNonSyncSample: l[1] & 1,
                    degradationPriority: l[2] << 8 | l[3]
                }
            }, CS = SS, av = CS, AS = function (l) {
                var d = {
                    version: l[0],
                    flags: new Uint8Array(l.subarray(1, 4)),
                    samples: []
                }, m = new DataView(l.buffer, l.byteOffset, l.byteLength), p = d.flags[2] & 1, g = d.flags[2] & 4, y = d.flags[1] & 1, S = d.flags[1] & 2, C = d.flags[1] & 4, k = d.flags[1] & 8, I = m.getUint32(4), q = 8, K;
                for (p && (d.dataOffset = m.getInt32(q),
                    q += 4),
                    g && I && (K = {
                        flags: av(l.subarray(q, q + 4))
                    },
                        q += 4,
                        y && (K.duration = m.getUint32(q),
                            q += 4),
                        S && (K.size = m.getUint32(q),
                            q += 4),
                        k && (d.version === 1 ? K.compositionTimeOffset = m.getInt32(q) : K.compositionTimeOffset = m.getUint32(q),
                            q += 4),
                        d.samples.push(K),
                        I--); I--;)
                    K = {},
                        y && (K.duration = m.getUint32(q),
                            q += 4),
                        S && (K.size = m.getUint32(q),
                            q += 4),
                        C && (K.flags = av(l.subarray(q, q + 4)),
                            q += 4),
                        k && (d.version === 1 ? K.compositionTimeOffset = m.getInt32(q) : K.compositionTimeOffset = m.getUint32(q),
                            q += 4),
                        d.samples.push(K);
                return d
            }, ov = AS, wS = function (l) {
                var d = new DataView(l.buffer, l.byteOffset, l.byteLength), m = {
                    version: l[0],
                    flags: new Uint8Array(l.subarray(1, 4)),
                    trackId: d.getUint32(4)
                }, p = m.flags[2] & 1, g = m.flags[2] & 2, y = m.flags[2] & 8, S = m.flags[2] & 16, C = m.flags[2] & 32, k = m.flags[0] & 65536, I = m.flags[0] & 131072, q;
                return q = 8,
                    p && (q += 4,
                        m.baseDataOffset = d.getUint32(12),
                        q += 4),
                    g && (m.sampleDescriptionIndex = d.getUint32(q),
                        q += 4),
                    y && (m.defaultSampleDuration = d.getUint32(q),
                        q += 4),
                    S && (m.defaultSampleSize = d.getUint32(q),
                        q += 4),
                    C && (m.defaultSampleFlags = d.getUint32(q)),
                    k && (m.durationIsEmpty = !0),
                    !p && I && (m.baseDataOffsetIsMoof = !0),
                    m
            }, lv = wS, Ro;
            typeof window < "u" ? Ro = window : typeof t < "u" ? Ro = t : typeof self < "u" ? Ro = self : Ro = {};
            var uv = Ro, DS = na.discardEmulationPreventionBytes, kS = gs.CaptionStream, No = rv, xS = nv, IS = ov, PS = lv, hv = uv, LS = function (l, d) {
                for (var m = l, p = 0; p < d.length; p++) {
                    var g = d[p];
                    if (m < g.size)
                        return g;
                    m -= g.size
                }
                return null
            }, OS = function (l, d, m) {
                var p = new DataView(l.buffer, l.byteOffset, l.byteLength), g = {
                    logs: [],
                    seiNals: []
                }, y, S, C, k;
                for (S = 0; S + 4 < l.length; S += C)
                    if (C = p.getUint32(S),
                        S += 4,
                        !(C <= 0))
                        switch (l[S] & 31) {
                            case 6:
                                var I = l.subarray(S + 1, S + 1 + C)
                                    , q = LS(S, d);
                                if (y = {
                                    nalUnitType: "sei_rbsp",
                                    size: C,
                                    data: I,
                                    escapedRBSP: DS(I),
                                    trackId: m
                                },
                                    q)
                                    y.pts = q.pts,
                                        y.dts = q.dts,
                                        k = q;
                                else if (k)
                                    y.pts = k.pts,
                                        y.dts = k.dts;
                                else {
                                    g.logs.push({
                                        level: "warn",
                                        message: "We've encountered a nal unit without data at " + S + " for trackId " + m + ". See mux.js#223."
                                    });
                                    break
                                }
                                g.seiNals.push(y);
                                break
                        }
                return g
            }, MS = function (l, d, m) {
                var p = d
                    , g = m.defaultSampleDuration || 0
                    , y = m.defaultSampleSize || 0
                    , S = m.trackId
                    , C = [];
                return l.forEach(function (k) {
                    var I = IS(k)
                        , q = I.samples;
                    q.forEach(function (K) {
                        K.duration === void 0 && (K.duration = g),
                            K.size === void 0 && (K.size = y),
                            K.trackId = S,
                            K.dts = p,
                            K.compositionTimeOffset === void 0 && (K.compositionTimeOffset = 0),
                            typeof p == "bigint" ? (K.pts = p + hv.BigInt(K.compositionTimeOffset),
                                p += hv.BigInt(K.duration)) : (K.pts = p + K.compositionTimeOffset,
                                    p += K.duration)
                    }),
                        C = C.concat(q)
                }),
                    C
            }, RS = function (l, d) {
                var m = No(l, ["moof", "traf"])
                    , p = No(l, ["mdat"])
                    , g = {}
                    , y = [];
                return p.forEach(function (S, C) {
                    var k = m[C];
                    y.push({
                        mdat: S,
                        traf: k
                    })
                }),
                    y.forEach(function (S) {
                        var C = S.mdat, k = S.traf, I = No(k, ["tfhd"]), q = PS(I[0]), K = q.trackId, fe = No(k, ["tfdt"]), Q = fe.length > 0 ? xS(fe[0]).baseMediaDecodeTime : 0, Ee = No(k, ["trun"]), Ae, ft;
                        d === K && Ee.length > 0 && (Ae = MS(Ee, Q, q),
                            ft = OS(C, Ae, K),
                            g[K] || (g[K] = {
                                seiNals: [],
                                logs: []
                            }),
                            g[K].seiNals = g[K].seiNals.concat(ft.seiNals),
                            g[K].logs = g[K].logs.concat(ft.logs))
                    }),
                    g
            }, NS = function (l, d, m) {
                var p;
                if (d === null)
                    return null;
                p = RS(l, d);
                var g = p[d] || {};
                return {
                    seiNals: g.seiNals,
                    logs: g.logs,
                    timescale: m
                }
            }, BS = function () {
                var l = !1, d, m, p, g, y, S;
                this.isInitialized = function () {
                    return l
                }
                    ,
                    this.init = function (C) {
                        d = new kS,
                            l = !0,
                            S = C ? C.isPartial : !1,
                            d.on("data", function (k) {
                                k.startTime = k.startPts / g,
                                    k.endTime = k.endPts / g,
                                    y.captions.push(k),
                                    y.captionStreams[k.stream] = !0
                            }),
                            d.on("log", function (k) {
                                y.logs.push(k)
                            })
                    }
                    ,
                    this.isNewInit = function (C, k) {
                        return C && C.length === 0 || k && typeof k == "object" && Object.keys(k).length === 0 ? !1 : p !== C[0] || g !== k[p]
                    }
                    ,
                    this.parse = function (C, k, I) {
                        var q;
                        if (this.isInitialized()) {
                            if (!k || !I)
                                return null;
                            if (this.isNewInit(k, I))
                                p = k[0],
                                    g = I[p];
                            else if (p === null || !g)
                                return m.push(C),
                                    null
                        } else
                            return null;
                        for (; m.length > 0;) {
                            var K = m.shift();
                            this.parse(K, k, I)
                        }
                        return q = NS(C, p, g),
                            q && q.logs && (y.logs = y.logs.concat(q.logs)),
                            q === null || !q.seiNals ? y.logs.length ? {
                                logs: y.logs,
                                captions: [],
                                captionStreams: []
                            } : null : (this.pushNals(q.seiNals),
                                this.flushStream(),
                                y)
                    }
                    ,
                    this.pushNals = function (C) {
                        if (!this.isInitialized() || !C || C.length === 0)
                            return null;
                        C.forEach(function (k) {
                            d.push(k)
                        })
                    }
                    ,
                    this.flushStream = function () {
                        if (!this.isInitialized())
                            return null;
                        S ? d.partialFlush() : d.flush()
                    }
                    ,
                    this.clearParsedCaptions = function () {
                        y.captions = [],
                            y.captionStreams = {},
                            y.logs = []
                    }
                    ,
                    this.resetCaptionStream = function () {
                        if (!this.isInitialized())
                            return null;
                        d.reset()
                    }
                    ,
                    this.clearAllCaptions = function () {
                        this.clearParsedCaptions(),
                            this.resetCaptionStream()
                    }
                    ,
                    this.reset = function () {
                        m = [],
                            p = null,
                            g = null,
                            y ? this.clearParsedCaptions() : y = {
                                captions: [],
                                captionStreams: {},
                                logs: []
                            },
                            this.resetCaptionStream()
                    }
                    ,
                    this.reset()
            }, FS = BS, US = function (l) {
                for (var d = 0, m = String.fromCharCode(l[d]), p = ""; m !== "\0";)
                    p += m,
                        d++,
                        m = String.fromCharCode(l[d]);
                return p += m,
                    p
            }, jS = {
                uint8ToCString: US
            }, Yu = jS.uint8ToCString, HS = a.getUint64, qS = function (l) {
                var d = 4, m = l[0], p, g, y, S, C, k, I, q;
                if (m === 0) {
                    p = Yu(l.subarray(d)),
                        d += p.length,
                        g = Yu(l.subarray(d)),
                        d += g.length;
                    var K = new DataView(l.buffer);
                    y = K.getUint32(d),
                        d += 4,
                        C = K.getUint32(d),
                        d += 4,
                        k = K.getUint32(d),
                        d += 4,
                        I = K.getUint32(d),
                        d += 4
                } else if (m === 1) {
                    var K = new DataView(l.buffer);
                    y = K.getUint32(d),
                        d += 4,
                        S = HS(l.subarray(d)),
                        d += 8,
                        k = K.getUint32(d),
                        d += 4,
                        I = K.getUint32(d),
                        d += 4,
                        p = Yu(l.subarray(d)),
                        d += p.length,
                        g = Yu(l.subarray(d)),
                        d += g.length
                }
                q = new Uint8Array(l.subarray(d, l.byteLength));
                var fe = {
                    scheme_id_uri: p,
                    value: g,
                    timescale: y || 1,
                    presentation_time: S,
                    presentation_time_delta: C,
                    event_duration: k,
                    id: I,
                    message_data: q
                };
                return VS(m, fe) ? fe : void 0
            }, $S = function (l, d, m, p) {
                return l || l === 0 ? l / d : p + m / d
            }, VS = function (l, d) {
                var m = d.scheme_id_uri !== "\0"
                    , p = l === 0 && dv(d.presentation_time_delta) && m
                    , g = l === 1 && dv(d.presentation_time) && m;
                return !(l > 1) && p || g
            }, dv = function (l) {
                return l !== void 0 || l !== null
            }, zS = {
                parseEmsgBox: qS,
                scaleTime: $S
            }, Qu = Xu.toUnsigned, Bo = Xu.toHexString, at = rv, da = iv, ac = zS, GS = lv, WS = ov, KS = nv, XS = a.getUint64, cv, fv, pv, mv, gv, oc, vv, lc = uv, YS = $g.parseId3Frames;
            cv = function (l) {
                var d = {}
                    , m = at(l, ["moov", "trak"]);
                return m.reduce(function (p, g) {
                    var y, S, C, k, I;
                    return y = at(g, ["tkhd"])[0],
                        !y || (S = y[0],
                            C = S === 0 ? 12 : 20,
                            k = Qu(y[C] << 24 | y[C + 1] << 16 | y[C + 2] << 8 | y[C + 3]),
                            I = at(g, ["mdia", "mdhd"])[0],
                            !I) ? null : (S = I[0],
                                C = S === 0 ? 12 : 20,
                                p[k] = Qu(I[C] << 24 | I[C + 1] << 16 | I[C + 2] << 8 | I[C + 3]),
                                p)
                }, d)
            }
                ,
                fv = function (l, d) {
                    var m;
                    m = at(d, ["moof", "traf"]);
                    var p = m.reduce(function (g, y) {
                        var S = at(y, ["tfhd"])[0], C = Qu(S[4] << 24 | S[5] << 16 | S[6] << 8 | S[7]), k = l[C] || 9e4, I = at(y, ["tfdt"])[0], q = new DataView(I.buffer, I.byteOffset, I.byteLength), K;
                        I[0] === 1 ? K = XS(I.subarray(4, 12)) : K = q.getUint32(4);
                        let fe;
                        return typeof K == "bigint" ? fe = K / lc.BigInt(k) : typeof K == "number" && !isNaN(K) && (fe = K / k),
                            fe < Number.MAX_SAFE_INTEGER && (fe = Number(fe)),
                            fe < g && (g = fe),
                            g
                    }, 1 / 0);
                    return typeof p == "bigint" || isFinite(p) ? p : 0
                }
                ,
                pv = function (l, d) {
                    var m = at(d, ["moof", "traf"]), p = 0, g = 0, y;
                    if (m && m.length) {
                        var S = at(m[0], ["tfhd"])[0]
                            , C = at(m[0], ["trun"])[0]
                            , k = at(m[0], ["tfdt"])[0];
                        if (S) {
                            var I = GS(S);
                            y = I.trackId
                        }
                        if (k) {
                            var q = KS(k);
                            p = q.baseMediaDecodeTime
                        }
                        if (C) {
                            var K = WS(C);
                            K.samples && K.samples.length && (g = K.samples[0].compositionTimeOffset || 0)
                        }
                    }
                    var fe = l[y] || 9e4;
                    typeof p == "bigint" && (g = lc.BigInt(g),
                        fe = lc.BigInt(fe));
                    var Q = (p + g) / fe;
                    return typeof Q == "bigint" && Q < Number.MAX_SAFE_INTEGER && (Q = Number(Q)),
                        Q
                }
                ,
                mv = function (l) {
                    var d = at(l, ["moov", "trak"])
                        , m = [];
                    return d.forEach(function (p) {
                        var g = at(p, ["mdia", "hdlr"])
                            , y = at(p, ["tkhd"]);
                        g.forEach(function (S, C) {
                            var k = da(S.subarray(8, 12)), I = y[C], q, K, fe;
                            k === "vide" && (q = new DataView(I.buffer, I.byteOffset, I.byteLength),
                                K = q.getUint8(0),
                                fe = K === 0 ? q.getUint32(12) : q.getUint32(20),
                                m.push(fe))
                        })
                    }),
                        m
                }
                ,
                oc = function (l) {
                    var d = l[0]
                        , m = d === 0 ? 12 : 20;
                    return Qu(l[m] << 24 | l[m + 1] << 16 | l[m + 2] << 8 | l[m + 3])
                }
                ,
                gv = function (l) {
                    var d = at(l, ["moov", "trak"])
                        , m = [];
                    return d.forEach(function (p) {
                        var g = {}, y = at(p, ["tkhd"])[0], S, C;
                        y && (S = new DataView(y.buffer, y.byteOffset, y.byteLength),
                            C = S.getUint8(0),
                            g.id = C === 0 ? S.getUint32(12) : S.getUint32(20));
                        var k = at(p, ["mdia", "hdlr"])[0];
                        if (k) {
                            var I = da(k.subarray(8, 12));
                            I === "vide" ? g.type = "video" : I === "soun" ? g.type = "audio" : g.type = I
                        }
                        var q = at(p, ["mdia", "minf", "stbl", "stsd"])[0];
                        if (q) {
                            var K = q.subarray(8);
                            g.codec = da(K.subarray(4, 8));
                            var fe = at(K, [g.codec])[0], Q, Ee;
                            fe && (/^[asm]vc[1-9]$/i.test(g.codec) ? (Q = fe.subarray(78),
                                Ee = da(Q.subarray(4, 8)),
                                Ee === "avcC" && Q.length > 11 ? (g.codec += ".",
                                    g.codec += Bo(Q[9]),
                                    g.codec += Bo(Q[10]),
                                    g.codec += Bo(Q[11])) : g.codec = "avc1.4d400d") : /^mp4[a,v]$/i.test(g.codec) ? (Q = fe.subarray(28),
                                        Ee = da(Q.subarray(4, 8)),
                                        Ee === "esds" && Q.length > 20 && Q[19] !== 0 ? (g.codec += "." + Bo(Q[19]),
                                            g.codec += "." + Bo(Q[20] >>> 2 & 63).replace(/^0/, "")) : g.codec = "mp4a.40.2") : g.codec = g.codec.toLowerCase())
                        }
                        var Ae = at(p, ["mdia", "mdhd"])[0];
                        Ae && (g.timescale = oc(Ae)),
                            m.push(g)
                    }),
                        m
                }
                ,
                vv = function (l, d = 0) {
                    var m = at(l, ["emsg"]);
                    return m.map(p => {
                        var g = ac.parseEmsgBox(new Uint8Array(p))
                            , y = YS(g.message_data);
                        return {
                            cueTime: ac.scaleTime(g.presentation_time, g.timescale, g.presentation_time_delta, d),
                            duration: ac.scaleTime(g.event_duration, g.timescale),
                            frames: y
                        }
                    }
                    )
                }
                ;
            var uc = {
                findBox: at,
                parseType: da,
                timescale: cv,
                startTime: fv,
                compositionStartTime: pv,
                videoTrackIds: mv,
                tracks: gv,
                getTimescaleFromMediaHeader: oc,
                getEmsgID3: vv
            }
                , hc = Jt
                , yv = function (l) {
                    var d = l[1] & 31;
                    return d <<= 8,
                        d |= l[2],
                        d
                }
                , Ju = function (l) {
                    return !!(l[1] & 64)
                }
                , Zu = function (l) {
                    var d = 0;
                    return (l[3] & 48) >>> 4 > 1 && (d += l[4] + 1),
                        d
                }
                , QS = function (l, d) {
                    var m = yv(l);
                    return m === 0 ? "pat" : m === d ? "pmt" : d ? "pes" : null
                }
                , JS = function (l) {
                    var d = Ju(l)
                        , m = 4 + Zu(l);
                    return d && (m += l[m] + 1),
                        (l[m + 10] & 31) << 8 | l[m + 11]
                }
                , ZS = function (l) {
                    var d = {}
                        , m = Ju(l)
                        , p = 4 + Zu(l);
                    if (m && (p += l[p] + 1),
                        !!(l[p + 5] & 1)) {
                        var g, y, S;
                        g = (l[p + 1] & 15) << 8 | l[p + 2],
                            y = 3 + g - 4,
                            S = (l[p + 10] & 15) << 8 | l[p + 11];
                        for (var C = 12 + S; C < y;) {
                            var k = p + C;
                            d[(l[k + 1] & 31) << 8 | l[k + 2]] = l[k],
                                C += ((l[k + 3] & 15) << 8 | l[k + 4]) + 5
                        }
                        return d
                    }
                }
                , eC = function (l, d) {
                    var m = yv(l)
                        , p = d[m];
                    switch (p) {
                        case hc.H264_STREAM_TYPE:
                            return "video";
                        case hc.ADTS_STREAM_TYPE:
                            return "audio";
                        case hc.METADATA_STREAM_TYPE:
                            return "timed-metadata";
                        default:
                            return null
                    }
                }
                , tC = function (l) {
                    var d = Ju(l);
                    if (!d)
                        return null;
                    var m = 4 + Zu(l);
                    if (m >= l.byteLength)
                        return null;
                    var p = null, g;
                    return g = l[m + 7],
                        g & 192 && (p = {},
                            p.pts = (l[m + 9] & 14) << 27 | (l[m + 10] & 255) << 20 | (l[m + 11] & 254) << 12 | (l[m + 12] & 255) << 5 | (l[m + 13] & 254) >>> 3,
                            p.pts *= 4,
                            p.pts += (l[m + 13] & 6) >>> 1,
                            p.dts = p.pts,
                            g & 64 && (p.dts = (l[m + 14] & 14) << 27 | (l[m + 15] & 255) << 20 | (l[m + 16] & 254) << 12 | (l[m + 17] & 255) << 5 | (l[m + 18] & 254) >>> 3,
                                p.dts *= 4,
                                p.dts += (l[m + 18] & 6) >>> 1)),
                        p
                }
                , dc = function (l) {
                    switch (l) {
                        case 5:
                            return "slice_layer_without_partitioning_rbsp_idr";
                        case 6:
                            return "sei_rbsp";
                        case 7:
                            return "seq_parameter_set_rbsp";
                        case 8:
                            return "pic_parameter_set_rbsp";
                        case 9:
                            return "access_unit_delimiter_rbsp";
                        default:
                            return null
                    }
                }
                , iC = function (l) {
                    for (var d = 4 + Zu(l), m = l.subarray(d), p = 0, g = 0, y = !1, S; g < m.byteLength - 3; g++)
                        if (m[g + 2] === 1) {
                            p = g + 5;
                            break
                        }
                    for (; p < m.byteLength;)
                        switch (m[p]) {
                            case 0:
                                if (m[p - 1] !== 0) {
                                    p += 2;
                                    break
                                } else if (m[p - 2] !== 0) {
                                    p++;
                                    break
                                }
                                g + 3 !== p - 2 && (S = dc(m[g + 3] & 31),
                                    S === "slice_layer_without_partitioning_rbsp_idr" && (y = !0));
                                do
                                    p++;
                                while (m[p] !== 1 && p < m.length);
                                g = p - 2,
                                    p += 3;
                                break;
                            case 1:
                                if (m[p - 1] !== 0 || m[p - 2] !== 0) {
                                    p += 3;
                                    break
                                }
                                S = dc(m[g + 3] & 31),
                                    S === "slice_layer_without_partitioning_rbsp_idr" && (y = !0),
                                    g = p - 2,
                                    p += 3;
                                break;
                            default:
                                p += 3;
                                break
                        }
                    return m = m.subarray(g),
                        p -= g,
                        g = 0,
                        m && m.byteLength > 3 && (S = dc(m[g + 3] & 31),
                            S === "slice_layer_without_partitioning_rbsp_idr" && (y = !0)),
                        y
                }
                , sC = {
                    parseType: QS,
                    parsePat: JS,
                    parsePmt: ZS,
                    parsePayloadUnitStartIndicator: Ju,
                    parsePesType: eC,
                    parsePesTime: tC,
                    videoPacketContainsKeyFrame: iC
                }
                , _v = Jt
                , ca = Hg.handleRollover
                , Fe = {};
            Fe.ts = sC,
                Fe.aac = ic;
            var Wr = Ne.ONE_SECOND_IN_TS
                , Zt = 188
                , ys = 71
                , rC = function (l, d) {
                    for (var m = 0, p = Zt, g, y; p < l.byteLength;) {
                        if (l[m] === ys && l[p] === ys) {
                            switch (g = l.subarray(m, p),
                            y = Fe.ts.parseType(g, d.pid),
                            y) {
                                case "pat":
                                    d.pid = Fe.ts.parsePat(g);
                                    break;
                                case "pmt":
                                    var S = Fe.ts.parsePmt(g);
                                    d.table = d.table || {},
                                        Object.keys(S).forEach(function (C) {
                                            d.table[C] = S[C]
                                        });
                                    break
                            }
                            m += Zt,
                                p += Zt;
                            continue
                        }
                        m++,
                            p++
                    }
                }
                , Tv = function (l, d, m) {
                    for (var p = 0, g = Zt, y, S, C, k, I, q = !1; g <= l.byteLength;) {
                        if (l[p] === ys && (l[g] === ys || g === l.byteLength)) {
                            switch (y = l.subarray(p, g),
                            S = Fe.ts.parseType(y, d.pid),
                            S) {
                                case "pes":
                                    C = Fe.ts.parsePesType(y, d.table),
                                        k = Fe.ts.parsePayloadUnitStartIndicator(y),
                                        C === "audio" && k && (I = Fe.ts.parsePesTime(y),
                                            I && (I.type = "audio",
                                                m.audio.push(I),
                                                q = !0));
                                    break
                            }
                            if (q)
                                break;
                            p += Zt,
                                g += Zt;
                            continue
                        }
                        p++,
                            g++
                    }
                    for (g = l.byteLength,
                        p = g - Zt,
                        q = !1; p >= 0;) {
                        if (l[p] === ys && (l[g] === ys || g === l.byteLength)) {
                            switch (y = l.subarray(p, g),
                            S = Fe.ts.parseType(y, d.pid),
                            S) {
                                case "pes":
                                    C = Fe.ts.parsePesType(y, d.table),
                                        k = Fe.ts.parsePayloadUnitStartIndicator(y),
                                        C === "audio" && k && (I = Fe.ts.parsePesTime(y),
                                            I && (I.type = "audio",
                                                m.audio.push(I),
                                                q = !0));
                                    break
                            }
                            if (q)
                                break;
                            p -= Zt,
                                g -= Zt;
                            continue
                        }
                        p--,
                            g--
                    }
                }
                , nC = function (l, d, m) {
                    for (var p = 0, g = Zt, y, S, C, k, I, q, K, fe, Q = !1, Ee = {
                        data: [],
                        size: 0
                    }; g < l.byteLength;) {
                        if (l[p] === ys && l[g] === ys) {
                            switch (y = l.subarray(p, g),
                            S = Fe.ts.parseType(y, d.pid),
                            S) {
                                case "pes":
                                    if (C = Fe.ts.parsePesType(y, d.table),
                                        k = Fe.ts.parsePayloadUnitStartIndicator(y),
                                        C === "video" && (k && !Q && (I = Fe.ts.parsePesTime(y),
                                            I && (I.type = "video",
                                                m.video.push(I),
                                                Q = !0)),
                                            !m.firstKeyFrame)) {
                                        if (k && Ee.size !== 0) {
                                            for (q = new Uint8Array(Ee.size),
                                                K = 0; Ee.data.length;)
                                                fe = Ee.data.shift(),
                                                    q.set(fe, K),
                                                    K += fe.byteLength;
                                            if (Fe.ts.videoPacketContainsKeyFrame(q)) {
                                                var Ae = Fe.ts.parsePesTime(q);
                                                Ae ? (m.firstKeyFrame = Ae,
                                                    m.firstKeyFrame.type = "video") : console.warn("Failed to extract PTS/DTS from PES at first keyframe. This could be an unusual TS segment, or else mux.js did not parse your TS segment correctly. If you know your TS segments do contain PTS/DTS on keyframes please file a bug report! You can try ffprobe to double check for yourself.")
                                            }
                                            Ee.size = 0
                                        }
                                        Ee.data.push(y),
                                            Ee.size += y.byteLength
                                    }
                                    break
                            }
                            if (Q && m.firstKeyFrame)
                                break;
                            p += Zt,
                                g += Zt;
                            continue
                        }
                        p++,
                            g++
                    }
                    for (g = l.byteLength,
                        p = g - Zt,
                        Q = !1; p >= 0;) {
                        if (l[p] === ys && l[g] === ys) {
                            switch (y = l.subarray(p, g),
                            S = Fe.ts.parseType(y, d.pid),
                            S) {
                                case "pes":
                                    C = Fe.ts.parsePesType(y, d.table),
                                        k = Fe.ts.parsePayloadUnitStartIndicator(y),
                                        C === "video" && k && (I = Fe.ts.parsePesTime(y),
                                            I && (I.type = "video",
                                                m.video.push(I),
                                                Q = !0));
                                    break
                            }
                            if (Q)
                                break;
                            p -= Zt,
                                g -= Zt;
                            continue
                        }
                        p--,
                            g--
                    }
                }
                , aC = function (l, d) {
                    if (l.audio && l.audio.length) {
                        var m = d;
                        (typeof m > "u" || isNaN(m)) && (m = l.audio[0].dts),
                            l.audio.forEach(function (y) {
                                y.dts = ca(y.dts, m),
                                    y.pts = ca(y.pts, m),
                                    y.dtsTime = y.dts / Wr,
                                    y.ptsTime = y.pts / Wr
                            })
                    }
                    if (l.video && l.video.length) {
                        var p = d;
                        if ((typeof p > "u" || isNaN(p)) && (p = l.video[0].dts),
                            l.video.forEach(function (y) {
                                y.dts = ca(y.dts, p),
                                    y.pts = ca(y.pts, p),
                                    y.dtsTime = y.dts / Wr,
                                    y.ptsTime = y.pts / Wr
                            }),
                            l.firstKeyFrame) {
                            var g = l.firstKeyFrame;
                            g.dts = ca(g.dts, p),
                                g.pts = ca(g.pts, p),
                                g.dtsTime = g.dts / Wr,
                                g.ptsTime = g.pts / Wr
                        }
                    }
                }
                , oC = function (l) {
                    for (var d = !1, m = 0, p = null, g = null, y = 0, S = 0, C; l.length - S >= 3;) {
                        var k = Fe.aac.parseType(l, S);
                        switch (k) {
                            case "timed-metadata":
                                if (l.length - S < 10) {
                                    d = !0;
                                    break
                                }
                                if (y = Fe.aac.parseId3TagSize(l, S),
                                    y > l.length) {
                                    d = !0;
                                    break
                                }
                                g === null && (C = l.subarray(S, S + y),
                                    g = Fe.aac.parseAacTimestamp(C)),
                                    S += y;
                                break;
                            case "audio":
                                if (l.length - S < 7) {
                                    d = !0;
                                    break
                                }
                                if (y = Fe.aac.parseAdtsSize(l, S),
                                    y > l.length) {
                                    d = !0;
                                    break
                                }
                                p === null && (C = l.subarray(S, S + y),
                                    p = Fe.aac.parseSampleRate(C)),
                                    m++,
                                    S += y;
                                break;
                            default:
                                S++;
                                break
                        }
                        if (d)
                            return null
                    }
                    if (p === null || g === null)
                        return null;
                    var I = Wr / p
                        , q = {
                            audio: [{
                                type: "audio",
                                dts: g,
                                pts: g
                            }, {
                                type: "audio",
                                dts: g + m * 1024 * I,
                                pts: g + m * 1024 * I
                            }]
                        };
                    return q
                }
                , lC = function (l) {
                    var d = {
                        pid: null,
                        table: null
                    }
                        , m = {};
                    rC(l, d);
                    for (var p in d.table)
                        if (d.table.hasOwnProperty(p)) {
                            var g = d.table[p];
                            switch (g) {
                                case _v.H264_STREAM_TYPE:
                                    m.video = [],
                                        nC(l, d, m),
                                        m.video.length === 0 && delete m.video;
                                    break;
                                case _v.ADTS_STREAM_TYPE:
                                    m.audio = [],
                                        Tv(l, d, m),
                                        m.audio.length === 0 && delete m.audio;
                                    break
                            }
                        }
                    return m
                }
                , uC = function (l, d) {
                    var m = Fe.aac.isLikelyAacData(l), p;
                    return m ? p = oC(l) : p = lC(l),
                        !p || !p.audio && !p.video ? null : (aC(p, d),
                            p)
                }
                , hC = {
                    inspect: uC,
                    parseAudioPes_: Tv
                };
            const dC = function (l, d) {
                d.on("data", function (m) {
                    const p = m.initSegment;
                    m.initSegment = {
                        data: p.buffer,
                        byteOffset: p.byteOffset,
                        byteLength: p.byteLength
                    };
                    const g = m.data;
                    m.data = g.buffer,
                        l.postMessage({
                            action: "data",
                            segment: m,
                            byteOffset: g.byteOffset,
                            byteLength: g.byteLength
                        }, [m.data])
                }),
                    d.on("done", function (m) {
                        l.postMessage({
                            action: "done"
                        })
                    }),
                    d.on("gopInfo", function (m) {
                        l.postMessage({
                            action: "gopInfo",
                            gopInfo: m
                        })
                    }),
                    d.on("videoSegmentTimingInfo", function (m) {
                        const p = {
                            start: {
                                decode: Ne.videoTsToSeconds(m.start.dts),
                                presentation: Ne.videoTsToSeconds(m.start.pts)
                            },
                            end: {
                                decode: Ne.videoTsToSeconds(m.end.dts),
                                presentation: Ne.videoTsToSeconds(m.end.pts)
                            },
                            baseMediaDecodeTime: Ne.videoTsToSeconds(m.baseMediaDecodeTime)
                        };
                        m.prependedContentDuration && (p.prependedContentDuration = Ne.videoTsToSeconds(m.prependedContentDuration)),
                            l.postMessage({
                                action: "videoSegmentTimingInfo",
                                videoSegmentTimingInfo: p
                            })
                    }),
                    d.on("audioSegmentTimingInfo", function (m) {
                        const p = {
                            start: {
                                decode: Ne.videoTsToSeconds(m.start.dts),
                                presentation: Ne.videoTsToSeconds(m.start.pts)
                            },
                            end: {
                                decode: Ne.videoTsToSeconds(m.end.dts),
                                presentation: Ne.videoTsToSeconds(m.end.pts)
                            },
                            baseMediaDecodeTime: Ne.videoTsToSeconds(m.baseMediaDecodeTime)
                        };
                        m.prependedContentDuration && (p.prependedContentDuration = Ne.videoTsToSeconds(m.prependedContentDuration)),
                            l.postMessage({
                                action: "audioSegmentTimingInfo",
                                audioSegmentTimingInfo: p
                            })
                    }),
                    d.on("id3Frame", function (m) {
                        l.postMessage({
                            action: "id3Frame",
                            id3Frame: m
                        })
                    }),
                    d.on("caption", function (m) {
                        l.postMessage({
                            action: "caption",
                            caption: m
                        })
                    }),
                    d.on("trackinfo", function (m) {
                        l.postMessage({
                            action: "trackinfo",
                            trackInfo: m
                        })
                    }),
                    d.on("audioTimingInfo", function (m) {
                        l.postMessage({
                            action: "audioTimingInfo",
                            audioTimingInfo: {
                                start: Ne.videoTsToSeconds(m.start),
                                end: Ne.videoTsToSeconds(m.end)
                            }
                        })
                    }),
                    d.on("videoTimingInfo", function (m) {
                        l.postMessage({
                            action: "videoTimingInfo",
                            videoTimingInfo: {
                                start: Ne.videoTsToSeconds(m.start),
                                end: Ne.videoTsToSeconds(m.end)
                            }
                        })
                    }),
                    d.on("log", function (m) {
                        l.postMessage({
                            action: "log",
                            log: m
                        })
                    })
            };
            class bv {
                constructor(d, m) {
                    this.options = m || {},
                        this.self = d,
                        this.init()
                }
                init() {
                    this.transmuxer && this.transmuxer.dispose(),
                        this.transmuxer = new pS.Transmuxer(this.options),
                        dC(this.self, this.transmuxer)
                }
                pushMp4Captions(d) {
                    this.captionParser || (this.captionParser = new FS,
                        this.captionParser.init());
                    const m = new Uint8Array(d.data, d.byteOffset, d.byteLength)
                        , p = this.captionParser.parse(m, d.trackIds, d.timescales);
                    this.self.postMessage({
                        action: "mp4Captions",
                        captions: p && p.captions || [],
                        logs: p && p.logs || [],
                        data: m.buffer
                    }, [m.buffer])
                }
                probeMp4StartTime({ timescales: d, data: m }) {
                    const p = uc.startTime(d, m);
                    this.self.postMessage({
                        action: "probeMp4StartTime",
                        startTime: p,
                        data: m
                    }, [m.buffer])
                }
                probeMp4Tracks({ data: d }) {
                    const m = uc.tracks(d);
                    this.self.postMessage({
                        action: "probeMp4Tracks",
                        tracks: m,
                        data: d
                    }, [d.buffer])
                }
                probeEmsgID3({ data: d, offset: m }) {
                    const p = uc.getEmsgID3(d, m);
                    this.self.postMessage({
                        action: "probeEmsgID3",
                        id3Frames: p,
                        emsgData: d
                    }, [d.buffer])
                }
                probeTs({ data: d, baseStartTime: m }) {
                    const p = typeof m == "number" && !isNaN(m) ? m * Ne.ONE_SECOND_IN_TS : void 0
                        , g = hC.inspect(d, p);
                    let y = null;
                    g && (y = {
                        hasVideo: g.video && g.video.length === 2 || !1,
                        hasAudio: g.audio && g.audio.length === 2 || !1
                    },
                        y.hasVideo && (y.videoStart = g.video[0].ptsTime),
                        y.hasAudio && (y.audioStart = g.audio[0].ptsTime)),
                        this.self.postMessage({
                            action: "probeTs",
                            result: y,
                            data: d
                        }, [d.buffer])
                }
                clearAllMp4Captions() {
                    this.captionParser && this.captionParser.clearAllCaptions()
                }
                clearParsedMp4Captions() {
                    this.captionParser && this.captionParser.clearParsedCaptions()
                }
                push(d) {
                    const m = new Uint8Array(d.data, d.byteOffset, d.byteLength);
                    this.transmuxer.push(m)
                }
                reset() {
                    this.transmuxer.reset()
                }
                setTimestampOffset(d) {
                    const m = d.timestampOffset || 0;
                    this.transmuxer.setBaseMediaDecodeTime(Math.round(Ne.secondsToVideoTs(m)))
                }
                setAudioAppendStart(d) {
                    this.transmuxer.setAudioAppendStart(Math.ceil(Ne.secondsToVideoTs(d.appendStart)))
                }
                setRemux(d) {
                    this.transmuxer.setRemux(d.remux)
                }
                flush(d) {
                    this.transmuxer.flush(),
                        self.postMessage({
                            action: "done",
                            type: "transmuxed"
                        })
                }
                endTimeline() {
                    this.transmuxer.endTimeline(),
                        self.postMessage({
                            action: "endedtimeline",
                            type: "transmuxed"
                        })
                }
                alignGopsWith(d) {
                    this.transmuxer.alignGopsWith(d.gopsToAlignWith.slice())
                }
            }
            self.onmessage = function (l) {
                if (l.data.action === "init" && l.data.options) {
                    this.messageHandlers = new bv(self, l.data.options);
                    return
                }
                this.messageHandlers || (this.messageHandlers = new bv(self)),
                    l.data && l.data.action && l.data.action !== "init" && this.messageHandlers[l.data.action] && this.messageHandlers[l.data.action](l.data)
            }
        }))
        , H2 = bm(j2)
        , q2 = (t, e, s) => {
            const { type: r, initSegment: n, captions: a, captionStreams: o, metadata: u, videoFrameDtsTime: c, videoFramePtsTime: f } = t.data.segment;
            e.buffer.push({
                captions: a,
                captionStreams: o,
                metadata: u
            });
            const v = t.data.segment.boxes || {
                data: t.data.segment.data
            }
                , T = {
                    type: r,
                    data: new Uint8Array(v.data, v.data.byteOffset, v.data.byteLength),
                    initSegment: new Uint8Array(n.data, n.byteOffset, n.byteLength)
                };
            typeof c < "u" && (T.videoFrameDtsTime = c),
                typeof f < "u" && (T.videoFramePtsTime = f),
                s(T)
        }
        , $2 = ({ transmuxedData: t, callback: e }) => {
            t.buffer = [],
                e(t)
        }
        , V2 = (t, e) => {
            e.gopInfo = t.data.gopInfo
        }
        , Cm = t => {
            const { transmuxer: e, bytes: s, audioAppendStart: r, gopsToAlignWith: n, remux: a, onData: o, onTrackInfo: u, onAudioTimingInfo: c, onVideoTimingInfo: f, onVideoSegmentTimingInfo: v, onAudioSegmentTimingInfo: T, onId3: D, onCaptions: _, onDone: L, onEndedTimeline: M, onTransmuxerLog: N, isEndOfTimeline: x } = t
                , B = {
                    buffer: []
                };
            let z = x;
            const R = F => {
                e.currentTransmux === t && (F.data.action === "data" && q2(F, B, o),
                    F.data.action === "trackinfo" && u(F.data.trackInfo),
                    F.data.action === "gopInfo" && V2(F, B),
                    F.data.action === "audioTimingInfo" && c(F.data.audioTimingInfo),
                    F.data.action === "videoTimingInfo" && f(F.data.videoTimingInfo),
                    F.data.action === "videoSegmentTimingInfo" && v(F.data.videoSegmentTimingInfo),
                    F.data.action === "audioSegmentTimingInfo" && T(F.data.audioSegmentTimingInfo),
                    F.data.action === "id3Frame" && D([F.data.id3Frame], F.data.id3Frame.dispatchType),
                    F.data.action === "caption" && _(F.data.caption),
                    F.data.action === "endedtimeline" && (z = !1,
                        M()),
                    F.data.action === "log" && N(F.data.log),
                    F.data.type === "transmuxed" && (z || (e.onmessage = null,
                        $2({
                            transmuxedData: B,
                            callback: L
                        }),
                        Am(e))))
            }
                ;
            if (e.onmessage = R,
                r && e.postMessage({
                    action: "setAudioAppendStart",
                    appendStart: r
                }),
                Array.isArray(n) && e.postMessage({
                    action: "alignGopsWith",
                    gopsToAlignWith: n
                }),
                typeof a < "u" && e.postMessage({
                    action: "setRemux",
                    remux: a
                }),
                s.byteLength) {
                const F = s instanceof ArrayBuffer ? s : s.buffer
                    , Y = s instanceof ArrayBuffer ? 0 : s.byteOffset;
                e.postMessage({
                    action: "push",
                    data: F,
                    byteOffset: Y,
                    byteLength: s.byteLength
                }, [F])
            }
            x && e.postMessage({
                action: "endTimeline"
            }),
                e.postMessage({
                    action: "flush"
                })
        }
        , Am = t => {
            t.currentTransmux = null,
                t.transmuxQueue.length && (t.currentTransmux = t.transmuxQueue.shift(),
                    typeof t.currentTransmux == "function" ? t.currentTransmux() : Cm(t.currentTransmux))
        }
        , wm = (t, e) => {
            t.postMessage({
                action: e
            }),
                Am(t)
        }
        , Dm = (t, e) => {
            if (!e.currentTransmux) {
                e.currentTransmux = t,
                    wm(e, t);
                return
            }
            e.transmuxQueue.push(wm.bind(null, e, t))
        }
        , z2 = t => {
            Dm("reset", t)
        }
        , G2 = t => {
            Dm("endTimeline", t)
        }
        , km = t => {
            if (!t.transmuxer.currentTransmux) {
                t.transmuxer.currentTransmux = t,
                    Cm(t);
                return
            }
            t.transmuxer.transmuxQueue.push(t)
        }
        , W2 = t => {
            const e = new H2;
            e.currentTransmux = null,
                e.transmuxQueue = [];
            const s = e.terminate;
            return e.terminate = () => (e.currentTransmux = null,
                e.transmuxQueue.length = 0,
                s.call(e)),
                e.postMessage({
                    action: "init",
                    options: t
                }),
                e
        }
        , kd = {
            reset: z2,
            endTimeline: G2,
            transmux: km,
            createTransmuxer: W2
        }
        , Ra = function (t) {
            const e = t.transmuxer
                , s = t.endAction || t.action
                , r = t.callback
                , n = Pi({}, t, {
                    endAction: null,
                    transmuxer: null,
                    callback: null
                })
                , a = o => {
                    o.data.action === s && (e.removeEventListener("message", a),
                        o.data.data && (o.data.data = new Uint8Array(o.data.data, t.byteOffset || 0, t.byteLength || o.data.data.byteLength),
                            t.data && (t.data = o.data.data)),
                        r(o.data))
                }
                ;
            if (e.addEventListener("message", a),
                t.data) {
                const o = t.data instanceof ArrayBuffer;
                n.byteOffset = o ? 0 : t.data.byteOffset,
                    n.byteLength = t.data.byteLength;
                const u = [o ? t.data : t.data.buffer];
                e.postMessage(n, u)
            } else
                e.postMessage(n)
        }
        , rs = {
            FAILURE: 2,
            TIMEOUT: -101,
            ABORTED: -102
        }
        , xd = t => {
            t.forEach(e => {
                e.abort()
            }
            )
        }
        , K2 = t => ({
            bandwidth: t.bandwidth,
            bytesReceived: t.bytesReceived || 0,
            roundTripTime: t.roundTripTime || 0
        })
        , X2 = t => {
            const e = t.target
                , r = {
                    bandwidth: 1 / 0,
                    bytesReceived: 0,
                    roundTripTime: Date.now() - e.requestTime || 0
                };
            return r.bytesReceived = t.loaded,
                r.bandwidth = Math.floor(r.bytesReceived / r.roundTripTime * 8 * 1e3),
                r
        }
        , Id = (t, e) => e.timedout ? {
            status: e.status,
            message: "HLS request timed-out at URL: " + e.uri,
            code: rs.TIMEOUT,
            xhr: e
        } : e.aborted ? {
            status: e.status,
            message: "HLS request aborted at URL: " + e.uri,
            code: rs.ABORTED,
            xhr: e
        } : t ? {
            status: e.status,
            message: "HLS request errored at URL: " + e.uri,
            code: rs.FAILURE,
            xhr: e
        } : e.responseType === "arraybuffer" && e.response.byteLength === 0 ? {
            status: e.status,
            message: "Empty HLS response at URL: " + e.uri,
            code: rs.FAILURE,
            xhr: e
        } : null
        , xm = (t, e, s) => (r, n) => {
            const a = n.response
                , o = Id(r, n);
            if (o)
                return s(o, t);
            if (a.byteLength !== 16)
                return s({
                    status: n.status,
                    message: "Invalid HLS key at URL: " + n.uri,
                    code: rs.FAILURE,
                    xhr: n
                }, t);
            const u = new DataView(a)
                , c = new Uint32Array([u.getUint32(0), u.getUint32(4), u.getUint32(8), u.getUint32(12)]);
            for (let f = 0; f < e.length; f++)
                e[f].bytes = c;
            return s(null, t)
        }
        , Im = (t, e) => {
            const s = bh(t.map.bytes);
            if (s !== "mp4") {
                const r = t.map.resolvedUri || t.map.uri;
                return e({
                    internal: !0,
                    message: `Found unsupported ${s || "unknown"} container for initialization segment at URL: ${r}`,
                    code: rs.FAILURE
                })
            }
            Ra({
                action: "probeMp4Tracks",
                data: t.map.bytes,
                transmuxer: t.transmuxer,
                callback: ({ tracks: r, data: n }) => (t.map.bytes = n,
                    r.forEach(function (a) {
                        t.map.tracks = t.map.tracks || {},
                            !t.map.tracks[a.type] && (t.map.tracks[a.type] = a,
                                typeof a.id == "number" && a.timescale && (t.map.timescales = t.map.timescales || {},
                                    t.map.timescales[a.id] = a.timescale))
                    }),
                    e(null))
            })
        }
        , Y2 = ({ segment: t, finishProcessingFn: e }) => (s, r) => {
            const n = Id(s, r);
            if (n)
                return e(n, t);
            const a = new Uint8Array(r.response);
            if (t.map.key)
                return t.map.encryptedBytes = a,
                    e(null, t);
            t.map.bytes = a,
                Im(t, function (o) {
                    if (o)
                        return o.xhr = r,
                            o.status = r.status,
                            e(o, t);
                    e(null, t)
                })
        }
        , Q2 = ({ segment: t, finishProcessingFn: e, responseType: s }) => (r, n) => {
            const a = Id(r, n);
            if (a)
                return e(a, t);
            const o = s === "arraybuffer" || !n.responseText ? n.response : F2(n.responseText.substring(t.lastReachedChar || 0));
            return t.stats = K2(n),
                t.key ? t.encryptedBytes = new Uint8Array(o) : t.bytes = new Uint8Array(o),
                e(null, t)
        }
        , J2 = ({ segment: t, bytes: e, trackInfoFn: s, timingInfoFn: r, videoSegmentTimingInfoFn: n, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: u, isEndOfTimeline: c, endedTimelineFn: f, dataFn: v, doneFn: T, onTransmuxerLog: D }) => {
            const _ = t.map && t.map.tracks || {}
                , L = !!(_.audio && _.video);
            let M = r.bind(null, t, "audio", "start");
            const N = r.bind(null, t, "audio", "end");
            let x = r.bind(null, t, "video", "start");
            const B = r.bind(null, t, "video", "end")
                , z = () => km({
                    bytes: e,
                    transmuxer: t.transmuxer,
                    audioAppendStart: t.audioAppendStart,
                    gopsToAlignWith: t.gopsToAlignWith,
                    remux: L,
                    onData: R => {
                        R.type = R.type === "combined" ? "video" : R.type,
                            v(t, R)
                    }
                    ,
                    onTrackInfo: R => {
                        s && (L && (R.isMuxed = !0),
                            s(t, R))
                    }
                    ,
                    onAudioTimingInfo: R => {
                        M && typeof R.start < "u" && (M(R.start),
                            M = null),
                            N && typeof R.end < "u" && N(R.end)
                    }
                    ,
                    onVideoTimingInfo: R => {
                        x && typeof R.start < "u" && (x(R.start),
                            x = null),
                            B && typeof R.end < "u" && B(R.end)
                    }
                    ,
                    onVideoSegmentTimingInfo: R => {
                        n(R)
                    }
                    ,
                    onAudioSegmentTimingInfo: R => {
                        a(R)
                    }
                    ,
                    onId3: (R, F) => {
                        o(t, R, F)
                    }
                    ,
                    onCaptions: R => {
                        u(t, [R])
                    }
                    ,
                    isEndOfTimeline: c,
                    onEndedTimeline: () => {
                        f()
                    }
                    ,
                    onTransmuxerLog: D,
                    onDone: R => {
                        T && (R.type = R.type === "combined" ? "video" : R.type,
                            T(null, t, R))
                    }
                });
            Ra({
                action: "probeTs",
                transmuxer: t.transmuxer,
                data: e,
                baseStartTime: t.baseStartTime,
                callback: R => {
                    t.bytes = e = R.data;
                    const F = R.result;
                    F && (s(t, {
                        hasAudio: F.hasAudio,
                        hasVideo: F.hasVideo,
                        isMuxed: L
                    }),
                        s = null),
                        z()
                }
            })
        }
        , Pm = ({ segment: t, bytes: e, trackInfoFn: s, timingInfoFn: r, videoSegmentTimingInfoFn: n, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: u, isEndOfTimeline: c, endedTimelineFn: f, dataFn: v, doneFn: T, onTransmuxerLog: D }) => {
            let _ = new Uint8Array(e);
            if (C0(_)) {
                t.isFmp4 = !0;
                const { tracks: L } = t.map
                    , M = {
                        isFmp4: !0,
                        hasVideo: !!L.video,
                        hasAudio: !!L.audio
                    };
                L.audio && L.audio.codec && L.audio.codec !== "enca" && (M.audioCodec = L.audio.codec),
                    L.video && L.video.codec && L.video.codec !== "encv" && (M.videoCodec = L.video.codec),
                    L.video && L.audio && (M.isMuxed = !0),
                    s(t, M);
                const N = (x, B) => {
                    v(t, {
                        data: _,
                        type: M.hasAudio && !M.isMuxed ? "audio" : "video"
                    }),
                        B && B.length && o(t, B),
                        x && x.length && u(t, x),
                        T(null, t, {})
                }
                    ;
                Ra({
                    action: "probeMp4StartTime",
                    timescales: t.map.timescales,
                    data: _,
                    transmuxer: t.transmuxer,
                    callback: ({ data: x, startTime: B }) => {
                        e = x.buffer,
                            t.bytes = _ = x,
                            M.hasAudio && !M.isMuxed && r(t, "audio", "start", B),
                            M.hasVideo && r(t, "video", "start", B),
                            Ra({
                                action: "probeEmsgID3",
                                data: _,
                                transmuxer: t.transmuxer,
                                offset: B,
                                callback: ({ emsgData: z, id3Frames: R }) => {
                                    if (e = z.buffer,
                                        t.bytes = _ = z,
                                        !L.video || !z.byteLength || !t.transmuxer) {
                                        N(void 0, R);
                                        return
                                    }
                                    Ra({
                                        action: "pushMp4Captions",
                                        endAction: "mp4Captions",
                                        transmuxer: t.transmuxer,
                                        data: _,
                                        timescales: t.map.timescales,
                                        trackIds: [L.video.id],
                                        callback: F => {
                                            e = F.data.buffer,
                                                t.bytes = _ = F.data,
                                                F.logs.forEach(function (Y) {
                                                    D(Re(Y, {
                                                        stream: "mp4CaptionParser"
                                                    }))
                                                }),
                                                N(F.captions, R)
                                        }
                                    })
                                }
                            })
                    }
                });
                return
            }
            if (!t.transmuxer) {
                T(null, t, {});
                return
            }
            if (typeof t.container > "u" && (t.container = bh(_)),
                t.container !== "ts" && t.container !== "aac") {
                s(t, {
                    hasAudio: !1,
                    hasVideo: !1
                }),
                    T(null, t, {});
                return
            }
            J2({
                segment: t,
                bytes: e,
                trackInfoFn: s,
                timingInfoFn: r,
                videoSegmentTimingInfoFn: n,
                audioSegmentTimingInfoFn: a,
                id3Fn: o,
                captionsFn: u,
                isEndOfTimeline: c,
                endedTimelineFn: f,
                dataFn: v,
                doneFn: T,
                onTransmuxerLog: D
            })
        }
        , Lm = function ({ id: t, key: e, encryptedBytes: s, decryptionWorker: r }, n) {
            const a = u => {
                if (u.data.source === t) {
                    r.removeEventListener("message", a);
                    const c = u.data.decrypted;
                    n(new Uint8Array(c.bytes, c.byteOffset, c.byteLength))
                }
            }
                ;
            r.addEventListener("message", a);
            let o;
            e.bytes.slice ? o = e.bytes.slice() : o = new Uint32Array(Array.prototype.slice.call(e.bytes)),
                r.postMessage(fm({
                    source: t,
                    encrypted: s,
                    key: o,
                    iv: e.iv
                }), [s.buffer, o.buffer])
        }
        , Z2 = ({ decryptionWorker: t, segment: e, trackInfoFn: s, timingInfoFn: r, videoSegmentTimingInfoFn: n, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: u, isEndOfTimeline: c, endedTimelineFn: f, dataFn: v, doneFn: T, onTransmuxerLog: D }) => {
            Lm({
                id: e.requestId,
                key: e.key,
                encryptedBytes: e.encryptedBytes,
                decryptionWorker: t
            }, _ => {
                e.bytes = _,
                    Pm({
                        segment: e,
                        bytes: e.bytes,
                        trackInfoFn: s,
                        timingInfoFn: r,
                        videoSegmentTimingInfoFn: n,
                        audioSegmentTimingInfoFn: a,
                        id3Fn: o,
                        captionsFn: u,
                        isEndOfTimeline: c,
                        endedTimelineFn: f,
                        dataFn: v,
                        doneFn: T,
                        onTransmuxerLog: D
                    })
            }
            )
        }
        , e1 = ({ activeXhrs: t, decryptionWorker: e, trackInfoFn: s, timingInfoFn: r, videoSegmentTimingInfoFn: n, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: u, isEndOfTimeline: c, endedTimelineFn: f, dataFn: v, doneFn: T, onTransmuxerLog: D }) => {
            let _ = 0
                , L = !1;
            return (M, N) => {
                if (!L) {
                    if (M)
                        return L = !0,
                            xd(t),
                            T(M, N);
                    if (_ += 1,
                        _ === t.length) {
                        const x = function () {
                            if (N.encryptedBytes)
                                return Z2({
                                    decryptionWorker: e,
                                    segment: N,
                                    trackInfoFn: s,
                                    timingInfoFn: r,
                                    videoSegmentTimingInfoFn: n,
                                    audioSegmentTimingInfoFn: a,
                                    id3Fn: o,
                                    captionsFn: u,
                                    isEndOfTimeline: c,
                                    endedTimelineFn: f,
                                    dataFn: v,
                                    doneFn: T,
                                    onTransmuxerLog: D
                                });
                            Pm({
                                segment: N,
                                bytes: N.bytes,
                                trackInfoFn: s,
                                timingInfoFn: r,
                                videoSegmentTimingInfoFn: n,
                                audioSegmentTimingInfoFn: a,
                                id3Fn: o,
                                captionsFn: u,
                                isEndOfTimeline: c,
                                endedTimelineFn: f,
                                dataFn: v,
                                doneFn: T,
                                onTransmuxerLog: D
                            })
                        };
                        if (N.endOfAllRequests = Date.now(),
                            N.map && N.map.encryptedBytes && !N.map.bytes)
                            return Lm({
                                decryptionWorker: e,
                                id: N.requestId + "-init",
                                encryptedBytes: N.map.encryptedBytes,
                                key: N.map.key
                            }, B => {
                                N.map.bytes = B,
                                    Im(N, z => {
                                        if (z)
                                            return xd(t),
                                                T(z, N);
                                        x()
                                    }
                                    )
                            }
                            );
                        x()
                    }
                }
            }
        }
        , t1 = ({ loadendState: t, abortFn: e }) => s => {
            s.target.aborted && e && !t.calledAbortFn && (e(),
                t.calledAbortFn = !0)
        }
        , i1 = ({ segment: t, progressFn: e, trackInfoFn: s, timingInfoFn: r, videoSegmentTimingInfoFn: n, audioSegmentTimingInfoFn: a, id3Fn: o, captionsFn: u, isEndOfTimeline: c, endedTimelineFn: f, dataFn: v }) => T => {
            if (!T.target.aborted)
                return t.stats = Re(t.stats, X2(T)),
                    !t.stats.firstBytesReceivedAt && t.stats.bytesReceived && (t.stats.firstBytesReceivedAt = Date.now()),
                    e(T, t)
        }
        , s1 = ({ xhr: t, xhrOptions: e, decryptionWorker: s, segment: r, abortFn: n, progressFn: a, trackInfoFn: o, timingInfoFn: u, videoSegmentTimingInfoFn: c, audioSegmentTimingInfoFn: f, id3Fn: v, captionsFn: T, isEndOfTimeline: D, endedTimelineFn: _, dataFn: L, doneFn: M, onTransmuxerLog: N }) => {
            const x = []
                , B = e1({
                    activeXhrs: x,
                    decryptionWorker: s,
                    trackInfoFn: o,
                    timingInfoFn: u,
                    videoSegmentTimingInfoFn: c,
                    audioSegmentTimingInfoFn: f,
                    id3Fn: v,
                    captionsFn: T,
                    isEndOfTimeline: D,
                    endedTimelineFn: _,
                    dataFn: L,
                    doneFn: M,
                    onTransmuxerLog: N
                });
            if (r.key && !r.key.bytes) {
                const ue = [r.key];
                r.map && !r.map.bytes && r.map.key && r.map.key.resolvedUri === r.key.resolvedUri && ue.push(r.map.key);
                const de = Re(e, {
                    uri: r.key.resolvedUri,
                    responseType: "arraybuffer"
                })
                    , ee = xm(r, ue, B)
                    , G = t(de, ee);
                x.push(G)
            }
            if (r.map && !r.map.bytes) {
                if (r.map.key && (!r.key || r.key.resolvedUri !== r.map.key.resolvedUri)) {
                    const A = Re(e, {
                        uri: r.map.key.resolvedUri,
                        responseType: "arraybuffer"
                    })
                        , w = xm(r, [r.map.key], B)
                        , H = t(A, w);
                    x.push(H)
                }
                const de = Re(e, {
                    uri: r.map.resolvedUri,
                    responseType: "arraybuffer",
                    headers: Ad(r.map)
                })
                    , ee = Y2({
                        segment: r,
                        finishProcessingFn: B
                    })
                    , G = t(de, ee);
                x.push(G)
            }
            const z = Re(e, {
                uri: r.part && r.part.resolvedUri || r.resolvedUri,
                responseType: "arraybuffer",
                headers: Ad(r)
            })
                , R = Q2({
                    segment: r,
                    finishProcessingFn: B,
                    responseType: z.responseType
                })
                , F = t(z, R);
            F.addEventListener("progress", i1({
                segment: r,
                progressFn: a,
                trackInfoFn: o,
                timingInfoFn: u,
                videoSegmentTimingInfoFn: c,
                audioSegmentTimingInfoFn: f,
                id3Fn: v,
                captionsFn: T,
                isEndOfTimeline: D,
                endedTimelineFn: _,
                dataFn: L
            })),
                x.push(F);
            const Y = {};
            return x.forEach(ue => {
                ue.addEventListener("loadend", t1({
                    loadendState: Y,
                    abortFn: n
                }))
            }
            ),
                () => xd(x)
        }
        , r1 = Ci("CodecUtils")
        , n1 = function (t) {
            const e = t.attributes || {};
            if (e.CODECS)
                return Xi(e.CODECS)
        }
        , Om = (t, e) => {
            const s = e.attributes || {};
            return t && t.mediaGroups && t.mediaGroups.AUDIO && s.AUDIO && t.mediaGroups.AUDIO[s.AUDIO]
        }
        , a1 = (t, e) => {
            if (!Om(t, e))
                return !0;
            const s = e.attributes || {}
                , r = t.mediaGroups.AUDIO[s.AUDIO];
            for (const n in r)
                if (!r[n].uri && !r[n].playlists)
                    return !0;
            return !1
        }
        , Dl = function (t) {
            const e = {};
            return t.forEach(({ mediaType: s, type: r, details: n }) => {
                e[s] = e[s] || [],
                    e[s].push(Oc(`${r}${n}`))
            }
            ),
                Object.keys(e).forEach(function (s) {
                    if (e[s].length > 1) {
                        r1(`multiple ${s} codecs found as attributes: ${e[s].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`),
                            e[s] = null;
                        return
                    }
                    e[s] = e[s][0]
                }),
                e
        }
        , Mm = function (t) {
            let e = 0;
            return t.audio && e++,
                t.video && e++,
                e
        }
        , Na = function (t, e) {
            const s = e.attributes || {}
                , r = Dl(n1(e) || []);
            if (Om(t, e) && !r.audio && !a1(t, e)) {
                const n = Dl(Zy(t, s.AUDIO) || []);
                n.audio && (r.audio = n.audio)
            }
            return r
        }
        , kl = Ci("PlaylistSelector")
        , Rm = function (t) {
            if (!t || !t.playlist)
                return;
            const e = t.playlist;
            return JSON.stringify({
                id: e.id,
                bandwidth: t.bandwidth,
                width: t.width,
                height: t.height,
                codecs: e.attributes && e.attributes.CODECS || ""
            })
        }
        , xl = function (t, e) {
            if (!t)
                return "";
            const s = O.default.getComputedStyle(t);
            return s ? s[e] : ""
        }
        , wn = function (t, e) {
            const s = t.slice();
            t.sort(function (r, n) {
                const a = e(r, n);
                return a === 0 ? s.indexOf(r) - s.indexOf(n) : a
            })
        }
        , Pd = function (t, e) {
            let s, r;
            return t.attributes.BANDWIDTH && (s = t.attributes.BANDWIDTH),
                s = s || O.default.Number.MAX_VALUE,
                e.attributes.BANDWIDTH && (r = e.attributes.BANDWIDTH),
                r = r || O.default.Number.MAX_VALUE,
                s - r
        }
        , o1 = function (t, e) {
            let s, r;
            return t.attributes.RESOLUTION && t.attributes.RESOLUTION.width && (s = t.attributes.RESOLUTION.width),
                s = s || O.default.Number.MAX_VALUE,
                e.attributes.RESOLUTION && e.attributes.RESOLUTION.width && (r = e.attributes.RESOLUTION.width),
                r = r || O.default.Number.MAX_VALUE,
                s === r && t.attributes.BANDWIDTH && e.attributes.BANDWIDTH ? t.attributes.BANDWIDTH - e.attributes.BANDWIDTH : s - r
        }
        , Nm = function (t, e, s, r, n, a) {
            if (!t)
                return;
            const o = {
                bandwidth: e,
                width: s,
                height: r,
                limitRenditionByPlayerDimensions: n
            };
            let u = t.playlists;
            si.isAudioOnly(t) && (u = a.getAudioTrackPlaylists_(),
                o.audioOnly = !0);
            let c = u.map(F => {
                let Y;
                const ue = F.attributes && F.attributes.RESOLUTION && F.attributes.RESOLUTION.width
                    , de = F.attributes && F.attributes.RESOLUTION && F.attributes.RESOLUTION.height;
                return Y = F.attributes && F.attributes.BANDWIDTH,
                    Y = Y || O.default.Number.MAX_VALUE,
                {
                    bandwidth: Y,
                    width: ue,
                    height: de,
                    playlist: F
                }
            }
            );
            wn(c, (F, Y) => F.bandwidth - Y.bandwidth),
                c = c.filter(F => !si.isIncompatible(F.playlist));
            let f = c.filter(F => si.isEnabled(F.playlist));
            f.length || (f = c.filter(F => !si.isDisabled(F.playlist)));
            const v = f.filter(F => F.bandwidth * mt.BANDWIDTH_VARIANCE < e);
            let T = v[v.length - 1];
            const D = v.filter(F => F.bandwidth === T.bandwidth)[0];
            if (n === !1) {
                const F = D || f[0] || c[0];
                if (F && F.playlist) {
                    let Y = "sortedPlaylistReps";
                    return D && (Y = "bandwidthBestRep"),
                        f[0] && (Y = "enabledPlaylistReps"),
                        kl(`choosing ${Rm(F)} using ${Y} with options`, o),
                        F.playlist
                }
                return kl("could not choose a playlist with options", o),
                    null
            }
            const _ = v.filter(F => F.width && F.height);
            wn(_, (F, Y) => F.width - Y.width);
            const L = _.filter(F => F.width === s && F.height === r);
            T = L[L.length - 1];
            const M = L.filter(F => F.bandwidth === T.bandwidth)[0];
            let N, x, B;
            M || (N = _.filter(F => F.width > s || F.height > r),
                x = N.filter(F => F.width === N[0].width && F.height === N[0].height),
                T = x[x.length - 1],
                B = x.filter(F => F.bandwidth === T.bandwidth)[0]);
            let z;
            if (a.leastPixelDiffSelector) {
                const F = _.map(Y => (Y.pixelDiff = Math.abs(Y.width - s) + Math.abs(Y.height - r),
                    Y));
                wn(F, (Y, ue) => Y.pixelDiff === ue.pixelDiff ? ue.bandwidth - Y.bandwidth : Y.pixelDiff - ue.pixelDiff),
                    z = F[0]
            }
            const R = z || B || M || D || f[0] || c[0];
            if (R && R.playlist) {
                let F = "sortedPlaylistReps";
                return z ? F = "leastPixelDiffRep" : B ? F = "resolutionPlusOneRep" : M ? F = "resolutionBestRep" : D ? F = "bandwidthBestRep" : f[0] && (F = "enabledPlaylistReps"),
                    kl(`choosing ${Rm(R)} using ${F} with options`, o),
                    R.playlist
            }
            return kl("could not choose a playlist with options", o),
                null
        }
        , Bm = function () {
            const t = this.useDevicePixelRatio && O.default.devicePixelRatio || 1;
            return Nm(this.playlists.main, this.systemBandwidth, parseInt(xl(this.tech_.el(), "width"), 10) * t, parseInt(xl(this.tech_.el(), "height"), 10) * t, this.limitRenditionByPlayerDimensions, this.playlistController_)
        }
        , l1 = function (t) {
            let e = -1
                , s = -1;
            if (t < 0 || t > 1)
                throw new Error("Moving average bandwidth decay must be between 0 and 1.");
            return function () {
                const r = this.useDevicePixelRatio && O.default.devicePixelRatio || 1;
                return e < 0 && (e = this.systemBandwidth,
                    s = this.systemBandwidth),
                    this.systemBandwidth > 0 && this.systemBandwidth !== s && (e = t * this.systemBandwidth + (1 - t) * e,
                        s = this.systemBandwidth),
                    Nm(this.playlists.main, e, parseInt(xl(this.tech_.el(), "width"), 10) * r, parseInt(xl(this.tech_.el(), "height"), 10) * r, this.limitRenditionByPlayerDimensions, this.playlistController_)
            }
        }
        , u1 = function (t) {
            const { main: e, currentTime: s, bandwidth: r, duration: n, segmentDuration: a, timeUntilRebuffer: o, currentTimeline: u, syncController: c } = t
                , f = e.playlists.filter(L => !si.isIncompatible(L));
            let v = f.filter(si.isEnabled);
            v.length || (v = f.filter(L => !si.isDisabled(L)));
            const D = v.filter(si.hasAttribute.bind(null, "BANDWIDTH")).map(L => {
                const N = c.getSyncPoint(L, n, u, s) ? 1 : 2
                    , B = si.estimateSegmentRequestTime(a, r, L) * N - o;
                return {
                    playlist: L,
                    rebufferingImpact: B
                }
            }
            )
                , _ = D.filter(L => L.rebufferingImpact <= 0);
            return wn(_, (L, M) => Pd(M.playlist, L.playlist)),
                _.length ? _[0] : (wn(D, (L, M) => L.rebufferingImpact - M.rebufferingImpact),
                    D[0] || null)
        }
        , h1 = function () {
            const t = this.playlists.main.playlists.filter(si.isEnabled);
            return wn(t, (s, r) => Pd(s, r)),
                t.filter(s => !!Na(this.playlists.main, s).video)[0] || null
        }
        , d1 = t => {
            let e = 0, s;
            return t.bytes && (s = new Uint8Array(t.bytes),
                t.segments.forEach(r => {
                    s.set(r, e),
                        e += r.byteLength
                }
                )),
                s
        }
        , c1 = function (t, e, s) {
            if (!t[s]) {
                e.trigger({
                    type: "usage",
                    name: "vhs-608"
                });
                let r = s;
                /^cc708_/.test(s) && (r = "SERVICE" + s.split("_")[1]);
                const n = e.textTracks().getTrackById(r);
                if (n)
                    t[s] = n;
                else {
                    const a = e.options_.vhs && e.options_.vhs.captionServices || {};
                    let o = s
                        , u = s
                        , c = !1;
                    const f = a[r];
                    f && (o = f.label,
                        u = f.language,
                        c = f.default),
                        t[s] = e.addRemoteTextTrack({
                            kind: "captions",
                            id: r,
                            default: c,
                            label: o,
                            language: u
                        }, !1).track
                }
            }
        }
        , f1 = function ({ inbandTextTracks: t, captionArray: e, timestampOffset: s }) {
            if (!e)
                return;
            const r = O.default.WebKitDataCue || O.default.VTTCue;
            e.forEach(n => {
                const a = n.stream;
                n.content ? n.content.forEach(o => {
                    const u = new r(n.startTime + s, n.endTime + s, o.text);
                    u.line = o.line,
                        u.align = "left",
                        u.position = o.position,
                        u.positionAlign = "line-left",
                        t[a].addCue(u)
                }
                ) : t[a].addCue(new r(n.startTime + s, n.endTime + s, n.text))
            }
            )
        }
        , p1 = function (t) {
            Object.defineProperties(t.frame, {
                id: {
                    get() {
                        return U.log.warn("cue.frame.id is deprecated. Use cue.value.key instead."),
                            t.value.key
                    }
                },
                value: {
                    get() {
                        return U.log.warn("cue.frame.value is deprecated. Use cue.value.data instead."),
                            t.value.data
                    }
                },
                privateData: {
                    get() {
                        return U.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead."),
                            t.value.data
                    }
                }
            })
        }
        , m1 = ({ inbandTextTracks: t, metadataArray: e, timestampOffset: s, videoDuration: r }) => {
            if (!e)
                return;
            const n = O.default.WebKitDataCue || O.default.VTTCue
                , a = t.metadataTrack_;
            if (!a || (e.forEach(v => {
                const T = v.cueTime + s;
                typeof T != "number" || O.default.isNaN(T) || T < 0 || !(T < 1 / 0) || !v.frames || !v.frames.length || v.frames.forEach(D => {
                    const _ = new n(T, T, D.value || D.url || D.data || "");
                    _.frame = D,
                        _.value = D,
                        p1(_),
                        a.addCue(_)
                }
                )
            }
            ),
                !a.cues || !a.cues.length))
                return;
            const o = a.cues
                , u = [];
            for (let v = 0; v < o.length; v++)
                o[v] && u.push(o[v]);
            const c = u.reduce((v, T) => {
                const D = v[T.startTime] || [];
                return D.push(T),
                    v[T.startTime] = D,
                    v
            }
                , {})
                , f = Object.keys(c).sort((v, T) => Number(v) - Number(T));
            f.forEach((v, T) => {
                const D = c[v]
                    , _ = isFinite(r) ? r : v
                    , L = Number(f[T + 1]) || _;
                D.forEach(M => {
                    M.endTime = L
                }
                )
            }
            )
        }
        , g1 = {
            id: "ID",
            class: "CLASS",
            startDate: "START-DATE",
            duration: "DURATION",
            endDate: "END-DATE",
            endOnNext: "END-ON-NEXT",
            plannedDuration: "PLANNED-DURATION",
            scte35Out: "SCTE35-OUT",
            scte35In: "SCTE35-IN"
        }
        , v1 = new Set(["id", "class", "startDate", "duration", "endDate", "endOnNext", "startTime", "endTime", "processDateRange"])
        , y1 = ({ inbandTextTracks: t, dateRanges: e }) => {
            const s = t.metadataTrack_;
            if (!s)
                return;
            const r = O.default.WebKitDataCue || O.default.VTTCue;
            e.forEach(n => {
                for (const a of Object.keys(n)) {
                    if (v1.has(a))
                        continue;
                    const o = new r(n.startTime, n.endTime, "");
                    o.id = n.id,
                        o.type = "com.apple.quicktime.HLS",
                        o.value = {
                            key: g1[a],
                            data: n[a]
                        },
                        (a === "scte35Out" || a === "scte35In") && (o.value.data = new Uint8Array(o.value.data.match(/[\da-f]{2}/gi)).buffer),
                        s.addCue(o)
                }
                n.processDateRange()
            }
            )
        }
        , Fm = (t, e, s) => {
            t.metadataTrack_ || (t.metadataTrack_ = s.addRemoteTextTrack({
                kind: "metadata",
                label: "Timed Metadata"
            }, !1).track,
                U.browser.IS_ANY_SAFARI || (t.metadataTrack_.inBandMetadataTrackDispatchType = e))
        }
        , Ba = function (t, e, s) {
            let r, n;
            if (s && s.cues)
                for (r = s.cues.length; r--;)
                    n = s.cues[r],
                        n.startTime >= t && n.endTime <= e && s.removeCue(n)
        }
        , _1 = function (t) {
            const e = t.cues;
            if (!e)
                return;
            const s = {};
            for (let r = e.length - 1; r >= 0; r--) {
                const n = e[r]
                    , a = `${n.startTime}-${n.endTime}-${n.text}`;
                s[a] ? t.removeCue(n) : s[a] = n
            }
        }
        , T1 = (t, e, s) => {
            if (typeof e > "u" || e === null || !t.length)
                return [];
            const r = Math.ceil((e - s + 3) * Go.ONE_SECOND_IN_TS);
            let n;
            for (n = 0; n < t.length && !(t[n].pts > r); n++)
                ;
            return t.slice(n)
        }
        , b1 = (t, e, s) => {
            if (!e.length)
                return t;
            if (s)
                return e.slice();
            const r = e[0].pts;
            let n = 0;
            for (n; n < t.length && !(t[n].pts >= r); n++)
                ;
            return t.slice(0, n).concat(e)
        }
        , E1 = (t, e, s, r) => {
            const n = Math.ceil((e - r) * Go.ONE_SECOND_IN_TS)
                , a = Math.ceil((s - r) * Go.ONE_SECOND_IN_TS)
                , o = t.slice();
            let u = t.length;
            for (; u-- && !(t[u].pts <= a);)
                ;
            if (u === -1)
                return o;
            let c = u + 1;
            for (; c-- && !(t[c].pts <= n);)
                ;
            return c = Math.max(c, 0),
                o.splice(c, u - c + 1),
                o
        }
        , S1 = function (t, e) {
            if (!t && !e || !t && e || t && !e)
                return !1;
            if (t === e)
                return !0;
            const s = Object.keys(t).sort()
                , r = Object.keys(e).sort();
            if (s.length !== r.length)
                return !1;
            for (let n = 0; n < s.length; n++) {
                const a = s[n];
                if (a !== r[n] || t[a] !== e[a])
                    return !1
            }
            return !0
        }
        , Um = 22
        , C1 = function (t, e, s) {
            e = e || [];
            const r = [];
            let n = 0;
            for (let a = 0; a < e.length; a++) {
                const o = e[a];
                if (t === o.timeline && (r.push(a),
                    n += o.duration,
                    n > s))
                    return a
            }
            return r.length === 0 ? 0 : r[r.length - 1]
        }
        , Fa = 1
        , A1 = 500
        , jm = t => typeof t == "number" && isFinite(t)
        , Il = 1 / 60
        , w1 = (t, e, s) => t !== "main" || !e || !s ? null : !s.hasAudio && !s.hasVideo ? "Neither audio nor video found in segment." : e.hasVideo && !s.hasVideo ? "Only audio found in segment when we expected video. We can't switch to audio only from a stream that had video. To get rid of this message, please add codec information to the manifest." : !e.hasVideo && s.hasVideo ? "Video found in segment when we expected only audio. We can't switch to a stream with video from an audio only stream. To get rid of this message, please add codec information to the manifest." : null
        , D1 = (t, e, s) => {
            let r = e - mt.BACK_BUFFER_LENGTH;
            t.length && (r = Math.max(r, t.start(0)));
            const n = e - s;
            return Math.min(n, r)
        }
        , Dn = t => {
            const { startOfSegment: e, duration: s, segment: r, part: n, playlist: { mediaSequence: a, id: o, segments: u = [] }, mediaIndex: c, partIndex: f, timeline: v } = t
                , T = u.length - 1;
            let D = "mediaIndex/partIndex increment";
            t.getMediaInfoForTime ? D = `getMediaInfoForTime (${t.getMediaInfoForTime})` : t.isSyncRequest && (D = "getSyncSegmentCandidate (isSyncRequest)"),
                t.independent && (D += ` with independent ${t.independent}`);
            const _ = typeof f == "number"
                , L = t.segment.uri ? "segment" : "pre-segment"
                , M = _ ? Yp({
                    preloadSegment: r
                }) - 1 : 0;
            return `${L} [${a + c}/${a + T}]` + (_ ? ` part [${f}/${M}]` : "") + ` segment start/end [${r.start} => ${r.end}]` + (_ ? ` part start/end [${n.start} => ${n.end}]` : "") + ` startOfSegment [${e}] duration [${s}] timeline [${v}] selected by [${D}] playlist [${o}]`
        }
        , Hm = t => `${t}TimingInfo`
        , k1 = ({ segmentTimeline: t, currentTimeline: e, startOfSegment: s, buffered: r, overrideCheck: n }) => !n && t === e ? null : t < e ? s : r.length ? r.end(r.length - 1) : s
        , qm = ({ timelineChangeController: t, currentTimeline: e, segmentTimeline: s, loaderType: r, audioDisabled: n }) => {
            if (e === s)
                return !1;
            if (r === "audio") {
                const a = t.lastTimelineChange({
                    type: "main"
                });
                return !a || a.to !== s
            }
            if (r === "main" && n) {
                const a = t.pendingTimelineChange({
                    type: "audio"
                });
                return !(a && a.to === s)
            }
            return !1
        }
        , x1 = t => {
            let e = 0;
            return ["video", "audio"].forEach(function (s) {
                const r = t[`${s}TimingInfo`];
                if (!r)
                    return;
                const { start: n, end: a } = r;
                let o;
                typeof n == "bigint" || typeof a == "bigint" ? o = O.default.BigInt(a) - O.default.BigInt(n) : typeof n == "number" && typeof a == "number" && (o = a - n),
                    typeof o < "u" && o > e && (e = o)
            }),
                typeof e == "bigint" && e < Number.MAX_SAFE_INTEGER && (e = Number(e)),
                e
        }
        , $m = ({ segmentDuration: t, maxDuration: e }) => t ? Math.round(t) > e + Ks : !1
        , I1 = (t, e) => {
            if (e !== "hls")
                return null;
            const s = x1({
                audioTimingInfo: t.audioTimingInfo,
                videoTimingInfo: t.videoTimingInfo
            });
            if (!s)
                return null;
            const r = t.playlist.targetDuration
                , n = $m({
                    segmentDuration: s,
                    maxDuration: r * 2
                })
                , a = $m({
                    segmentDuration: s,
                    maxDuration: r
                })
                , o = `Segment with index ${t.mediaIndex} from playlist ${t.playlist.id} has a duration of ${s} when the reported duration is ${t.duration} and the target duration is ${r}. For HLS content, a duration in excess of the target duration may result in playback issues. See the HLS specification section on EXT-X-TARGETDURATION for more details: https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1`;
            return n || a ? {
                severity: n ? "warn" : "info",
                message: o
            } : null
        }
        , Ld = class extends U.EventTarget {
            constructor(t, e = {}) {
                if (super(),
                    !t)
                    throw new TypeError("Initialization settings are required");
                if (typeof t.currentTime != "function")
                    throw new TypeError("No currentTime getter specified");
                if (!t.mediaSource)
                    throw new TypeError("No MediaSource specified");
                this.bandwidth = t.bandwidth,
                    this.throughput = {
                        rate: 0,
                        count: 0
                    },
                    this.roundTrip = NaN,
                    this.resetStats_(),
                    this.mediaIndex = null,
                    this.partIndex = null,
                    this.hasPlayed_ = t.hasPlayed,
                    this.currentTime_ = t.currentTime,
                    this.seekable_ = t.seekable,
                    this.seeking_ = t.seeking,
                    this.duration_ = t.duration,
                    this.mediaSource_ = t.mediaSource,
                    this.vhs_ = t.vhs,
                    this.loaderType_ = t.loaderType,
                    this.currentMediaInfo_ = void 0,
                    this.startingMediaInfo_ = void 0,
                    this.segmentMetadataTrack_ = t.segmentMetadataTrack,
                    this.goalBufferLength_ = t.goalBufferLength,
                    this.sourceType_ = t.sourceType,
                    this.sourceUpdater_ = t.sourceUpdater,
                    this.inbandTextTracks_ = t.inbandTextTracks,
                    this.state_ = "INIT",
                    this.timelineChangeController_ = t.timelineChangeController,
                    this.shouldSaveSegmentTimingInfo_ = !0,
                    this.parse708captions_ = t.parse708captions,
                    this.useDtsForTimestampOffset_ = t.useDtsForTimestampOffset,
                    this.captionServices_ = t.captionServices,
                    this.exactManifestTimings = t.exactManifestTimings,
                    this.addMetadataToTextTrack = t.addMetadataToTextTrack,
                    this.checkBufferTimeout_ = null,
                    this.error_ = void 0,
                    this.currentTimeline_ = -1,
                    this.shouldForceTimestampOffsetAfterResync_ = !1,
                    this.pendingSegment_ = null,
                    this.xhrOptions_ = null,
                    this.pendingSegments_ = [],
                    this.audioDisabled_ = !1,
                    this.isPendingTimestampOffset_ = !1,
                    this.gopBuffer_ = [],
                    this.timeMapping_ = 0,
                    this.safeAppend_ = !1,
                    this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    },
                    this.playlistOfLastInitSegment_ = {
                        audio: null,
                        video: null
                    },
                    this.callQueue_ = [],
                    this.loadQueue_ = [],
                    this.metadataQueue_ = {
                        id3: [],
                        caption: []
                    },
                    this.waitingOnRemove_ = !1,
                    this.quotaExceededErrorRetryTimeout_ = null,
                    this.activeInitSegmentId_ = null,
                    this.initSegments_ = {},
                    this.cacheEncryptionKeys_ = t.cacheEncryptionKeys,
                    this.keyCache_ = {},
                    this.decrypter_ = t.decrypter,
                    this.syncController_ = t.syncController,
                    this.syncPoint_ = {
                        segmentIndex: 0,
                        time: 0
                    },
                    this.transmuxer_ = this.createTransmuxer_(),
                    this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate"),
                    this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_),
                    this.mediaSource_.addEventListener("sourceopen", () => {
                        this.isEndOfStream_() || (this.ended_ = !1)
                    }
                    ),
                    this.fetchAtBuffer_ = !1,
                    this.logger_ = Ci(`SegmentLoader[${this.loaderType_}]`),
                    Object.defineProperty(this, "state", {
                        get() {
                            return this.state_
                        },
                        set(s) {
                            s !== this.state_ && (this.logger_(`${this.state_} -> ${s}`),
                                this.state_ = s,
                                this.trigger("statechange"))
                        }
                    }),
                    this.sourceUpdater_.on("ready", () => {
                        this.hasEnoughInfoToAppend_() && this.processCallQueue_()
                    }
                    ),
                    this.loaderType_ === "main" && this.timelineChangeController_.on("pendingtimelinechange", () => {
                        this.hasEnoughInfoToAppend_() && this.processCallQueue_()
                    }
                    ),
                    this.loaderType_ === "audio" && this.timelineChangeController_.on("timelinechange", () => {
                        this.hasEnoughInfoToLoad_() && this.processLoadQueue_(),
                            this.hasEnoughInfoToAppend_() && this.processCallQueue_()
                    }
                    )
            }
            createTransmuxer_() {
                return kd.createTransmuxer({
                    remux: !1,
                    alignGopsAtEnd: this.safeAppend_,
                    keepOriginalTimestamps: !0,
                    parse708captions: this.parse708captions_,
                    captionServices: this.captionServices_
                })
            }
            resetStats_() {
                this.mediaBytesTransferred = 0,
                    this.mediaRequests = 0,
                    this.mediaRequestsAborted = 0,
                    this.mediaRequestsTimedout = 0,
                    this.mediaRequestsErrored = 0,
                    this.mediaTransferDuration = 0,
                    this.mediaSecondsLoaded = 0,
                    this.mediaAppends = 0
            }
            dispose() {
                this.trigger("dispose"),
                    this.state = "DISPOSED",
                    this.pause(),
                    this.abort_(),
                    this.transmuxer_ && this.transmuxer_.terminate(),
                    this.resetStats_(),
                    this.checkBufferTimeout_ && O.default.clearTimeout(this.checkBufferTimeout_),
                    this.syncController_ && this.triggerSyncInfoUpdate_ && this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_),
                    this.off()
            }
            setAudio(t) {
                this.audioDisabled_ = !t,
                    t ? this.appendInitSegment_.audio = !0 : this.sourceUpdater_.removeAudio(0, this.duration_())
            }
            abort() {
                if (this.state !== "WAITING") {
                    this.pendingSegment_ && (this.pendingSegment_ = null);
                    return
                }
                this.abort_(),
                    this.state = "READY",
                    this.paused() || this.monitorBuffer_()
            }
            abort_() {
                this.pendingSegment_ && this.pendingSegment_.abortRequests && this.pendingSegment_.abortRequests(),
                    this.pendingSegment_ = null,
                    this.callQueue_ = [],
                    this.loadQueue_ = [],
                    this.metadataQueue_.id3 = [],
                    this.metadataQueue_.caption = [],
                    this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_),
                    this.waitingOnRemove_ = !1,
                    O.default.clearTimeout(this.quotaExceededErrorRetryTimeout_),
                    this.quotaExceededErrorRetryTimeout_ = null
            }
            checkForAbort_(t) {
                return this.state === "APPENDING" && !this.pendingSegment_ ? (this.state = "READY",
                    !0) : !this.pendingSegment_ || this.pendingSegment_.requestId !== t
            }
            error(t) {
                return typeof t < "u" && (this.logger_("error occurred:", t),
                    this.error_ = t),
                    this.pendingSegment_ = null,
                    this.error_
            }
            endOfStream() {
                this.ended_ = !0,
                    this.transmuxer_ && kd.reset(this.transmuxer_),
                    this.gopBuffer_.length = 0,
                    this.pause(),
                    this.trigger("ended")
            }
            buffered_() {
                const t = this.getMediaInfo_();
                if (!this.sourceUpdater_ || !t)
                    return xt();
                if (this.loaderType_ === "main") {
                    const { hasAudio: e, hasVideo: s, isMuxed: r } = t;
                    if (s && e && !this.audioDisabled_ && !r)
                        return this.sourceUpdater_.buffered();
                    if (s)
                        return this.sourceUpdater_.videoBuffered()
                }
                return this.sourceUpdater_.audioBuffered()
            }
            initSegmentForMap(t, e = !1) {
                if (!t)
                    return null;
                const s = wl(t);
                let r = this.initSegments_[s];
                return e && !r && t.bytes && (this.initSegments_[s] = r = {
                    resolvedUri: t.resolvedUri,
                    byterange: t.byterange,
                    bytes: t.bytes,
                    tracks: t.tracks,
                    timescales: t.timescales
                }),
                    r || t
            }
            segmentKey(t, e = !1) {
                if (!t)
                    return null;
                const s = pm(t);
                let r = this.keyCache_[s];
                this.cacheEncryptionKeys_ && e && !r && t.bytes && (this.keyCache_[s] = r = {
                    resolvedUri: t.resolvedUri,
                    bytes: t.bytes
                });
                const n = {
                    resolvedUri: (r || t).resolvedUri
                };
                return r && (n.bytes = r.bytes),
                    n
            }
            couldBeginLoading_() {
                return this.playlist_ && !this.paused()
            }
            load() {
                if (this.monitorBuffer_(),
                    !!this.playlist_) {
                    if (this.state === "INIT" && this.couldBeginLoading_())
                        return this.init_();
                    !this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT" || (this.state = "READY")
                }
            }
            init_() {
                return this.state = "READY",
                    this.resetEverything(),
                    this.monitorBuffer_()
            }
            playlist(t, e = {}) {
                if (!t)
                    return;
                const s = this.playlist_
                    , r = this.pendingSegment_;
                this.playlist_ = t,
                    this.xhrOptions_ = e,
                    this.state === "INIT" && (t.syncInfo = {
                        mediaSequence: t.mediaSequence,
                        time: 0
                    },
                        this.loaderType_ === "main" && this.syncController_.setDateTimeMappingForStart(t));
                let n = null;
                if (s && (s.id ? n = s.id : s.uri && (n = s.uri)),
                    this.logger_(`playlist update [${n} => ${t.id || t.uri}]`),
                    this.syncController_.updateMediaSequenceMap(t, this.currentTime_(), this.loaderType_),
                    this.trigger("syncinfoupdate"),
                    this.state === "INIT" && this.couldBeginLoading_())
                    return this.init_();
                if (!s || s.uri !== t.uri) {
                    this.mediaIndex !== null && (!t.endList && typeof t.partTargetDuration == "number" ? this.resetLoader() : this.resyncLoader()),
                        this.currentMediaInfo_ = void 0,
                        this.trigger("playlistupdate");
                    return
                }
                const a = t.mediaSequence - s.mediaSequence;
                if (this.logger_(`live window shift [${a}]`),
                    this.mediaIndex !== null)
                    if (this.mediaIndex -= a,
                        this.mediaIndex < 0)
                        this.mediaIndex = null,
                            this.partIndex = null;
                    else {
                        const o = this.playlist_.segments[this.mediaIndex];
                        if (this.partIndex && (!o.parts || !o.parts.length || !o.parts[this.partIndex])) {
                            const u = this.mediaIndex;
                            this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`),
                                this.resetLoader(),
                                this.mediaIndex = u
                        }
                    }
                r && (r.mediaIndex -= a,
                    r.mediaIndex < 0 ? (r.mediaIndex = null,
                        r.partIndex = null) : (r.mediaIndex >= 0 && (r.segment = t.segments[r.mediaIndex]),
                            r.partIndex >= 0 && r.segment.parts && (r.part = r.segment.parts[r.partIndex]))),
                    this.syncController_.saveExpiredSegmentInfo(s, t)
            }
            pause() {
                this.checkBufferTimeout_ && (O.default.clearTimeout(this.checkBufferTimeout_),
                    this.checkBufferTimeout_ = null)
            }
            paused() {
                return this.checkBufferTimeout_ === null
            }
            resetEverything(t) {
                this.ended_ = !1,
                    this.activeInitSegmentId_ = null,
                    this.appendInitSegment_ = {
                        audio: !0,
                        video: !0
                    },
                    this.resetLoader(),
                    this.remove(0, 1 / 0, t),
                    this.transmuxer_ && (this.transmuxer_.postMessage({
                        action: "clearAllMp4Captions"
                    }),
                        this.transmuxer_.postMessage({
                            action: "reset"
                        }))
            }
            resetLoader() {
                this.fetchAtBuffer_ = !1,
                    this.resyncLoader()
            }
            resyncLoader() {
                this.transmuxer_ && kd.reset(this.transmuxer_),
                    this.mediaIndex = null,
                    this.partIndex = null,
                    this.syncPoint_ = null,
                    this.isPendingTimestampOffset_ = !1,
                    this.shouldForceTimestampOffsetAfterResync_ = !0,
                    this.callQueue_ = [],
                    this.loadQueue_ = [],
                    this.metadataQueue_.id3 = [],
                    this.metadataQueue_.caption = [],
                    this.abort(),
                    this.transmuxer_ && this.transmuxer_.postMessage({
                        action: "clearParsedMp4Captions"
                    })
            }
            remove(t, e, s = () => { }
                , r = !1) {
                if (e === 1 / 0 && (e = this.duration_()),
                    e <= t) {
                    this.logger_("skipping remove because end ${end} is <= start ${start}");
                    return
                }
                if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
                    this.logger_("skipping remove because no source updater or starting media info");
                    return
                }
                let n = 1;
                const a = () => {
                    n--,
                        n === 0 && s()
                }
                    ;
                (r || !this.audioDisabled_) && (n++,
                    this.sourceUpdater_.removeAudio(t, e, a)),
                    (r || this.loaderType_ === "main") && (this.gopBuffer_ = E1(this.gopBuffer_, t, e, this.timeMapping_),
                        n++,
                        this.sourceUpdater_.removeVideo(t, e, a));
                for (const o in this.inbandTextTracks_)
                    Ba(t, e, this.inbandTextTracks_[o]);
                Ba(t, e, this.segmentMetadataTrack_),
                    a()
            }
            monitorBuffer_() {
                this.checkBufferTimeout_ && O.default.clearTimeout(this.checkBufferTimeout_),
                    this.checkBufferTimeout_ = O.default.setTimeout(this.monitorBufferTick_.bind(this), 1)
            }
            monitorBufferTick_() {
                this.state === "READY" && this.fillBuffer_(),
                    this.checkBufferTimeout_ && O.default.clearTimeout(this.checkBufferTimeout_),
                    this.checkBufferTimeout_ = O.default.setTimeout(this.monitorBufferTick_.bind(this), A1)
            }
            fillBuffer_() {
                if (this.sourceUpdater_.updating())
                    return;
                const t = this.chooseNextRequest_();
                t && (typeof t.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !1,
                    this.timelineChangeController_.pendingTimelineChange({
                        type: this.loaderType_,
                        from: this.currentTimeline_,
                        to: t.timeline
                    })),
                    this.loadSegment_(t))
            }
            isEndOfStream_(t = this.mediaIndex, e = this.playlist_, s = this.partIndex) {
                if (!e || !this.mediaSource_)
                    return !1;
                const r = typeof t == "number" && e.segments[t]
                    , n = t + 1 === e.segments.length
                    , a = !r || !r.parts || s + 1 === r.parts.length;
                return e.endList && this.mediaSource_.readyState === "open" && n && a
            }
            chooseNextRequest_() {
                const t = this.buffered_()
                    , e = Kp(t) || 0
                    , s = gd(t, this.currentTime_())
                    , r = !this.hasPlayed_() && s >= 1
                    , n = s >= this.goalBufferLength_()
                    , a = this.playlist_.segments;
                if (!a.length || r || n)
                    return null;
                this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_(), this.loaderType_);
                const o = {
                    partIndex: null,
                    mediaIndex: null,
                    startOfSegment: null,
                    playlist: this.playlist_,
                    isSyncRequest: !this.syncPoint_
                };
                if (o.isSyncRequest)
                    o.mediaIndex = C1(this.currentTimeline_, a, e),
                        this.logger_(`choose next request. Can not find sync point. Fallback to media Index: ${o.mediaIndex}`);
                else if (this.mediaIndex !== null) {
                    const T = a[this.mediaIndex]
                        , D = typeof this.partIndex == "number" ? this.partIndex : -1;
                    o.startOfSegment = T.end ? T.end : e,
                        T.parts && T.parts[D + 1] ? (o.mediaIndex = this.mediaIndex,
                            o.partIndex = D + 1) : o.mediaIndex = this.mediaIndex + 1
                } else {
                    const { segmentIndex: T, startTime: D, partIndex: _ } = si.getMediaInfoForTime({
                        exactManifestTimings: this.exactManifestTimings,
                        playlist: this.playlist_,
                        currentTime: this.fetchAtBuffer_ ? e : this.currentTime_(),
                        startingPartIndex: this.syncPoint_.partIndex,
                        startingSegmentIndex: this.syncPoint_.segmentIndex,
                        startTime: this.syncPoint_.time
                    });
                    o.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${e}` : `currentTime ${this.currentTime_()}`,
                        o.mediaIndex = T,
                        o.startOfSegment = D,
                        o.partIndex = _,
                        this.logger_(`choose next request. Playlist switched and we have a sync point. Media Index: ${o.mediaIndex} `)
                }
                const u = a[o.mediaIndex];
                let c = u && typeof o.partIndex == "number" && u.parts && u.parts[o.partIndex];
                if (!u || typeof o.partIndex == "number" && !c)
                    return null;
                typeof o.partIndex != "number" && u.parts && (o.partIndex = 0,
                    c = u.parts[0]);
                const f = this.vhs_.playlists && this.vhs_.playlists.main && this.vhs_.playlists.main.independentSegments || this.playlist_.independentSegments;
                if (!s && c && !f && !c.independent)
                    if (o.partIndex === 0) {
                        const T = a[o.mediaIndex - 1]
                            , D = T.parts && T.parts.length && T.parts[T.parts.length - 1];
                        D && D.independent && (o.mediaIndex -= 1,
                            o.partIndex = T.parts.length - 1,
                            o.independent = "previous segment")
                    } else
                        u.parts[o.partIndex - 1].independent && (o.partIndex -= 1,
                            o.independent = "previous part");
                const v = this.mediaSource_ && this.mediaSource_.readyState === "ended";
                return o.mediaIndex >= a.length - 1 && v && !this.seeking_() ? null : (this.shouldForceTimestampOffsetAfterResync_ && (this.shouldForceTimestampOffsetAfterResync_ = !1,
                    o.forceTimestampOffset = !0,
                    this.logger_("choose next request. Force timestamp offset after loader resync")),
                    this.generateSegmentInfo_(o))
            }
            generateSegmentInfo_(t) {
                const { independent: e, playlist: s, mediaIndex: r, startOfSegment: n, isSyncRequest: a, partIndex: o, forceTimestampOffset: u, getMediaInfoForTime: c } = t
                    , f = s.segments[r]
                    , v = typeof o == "number" && f.parts[o]
                    , T = {
                        requestId: "segment-loader-" + Math.random(),
                        uri: v && v.resolvedUri || f.resolvedUri,
                        mediaIndex: r,
                        partIndex: v ? o : null,
                        isSyncRequest: a,
                        startOfSegment: n,
                        playlist: s,
                        bytes: null,
                        encryptedBytes: null,
                        timestampOffset: null,
                        timeline: f.timeline,
                        duration: v && v.duration || f.duration,
                        segment: f,
                        part: v,
                        byteLength: 0,
                        transmuxer: this.transmuxer_,
                        getMediaInfoForTime: c,
                        independent: e
                    }
                    , D = typeof u < "u" ? u : this.isPendingTimestampOffset_;
                T.timestampOffset = this.timestampOffsetForSegment_({
                    segmentTimeline: f.timeline,
                    currentTimeline: this.currentTimeline_,
                    startOfSegment: n,
                    buffered: this.buffered_(),
                    overrideCheck: D
                });
                const _ = Kp(this.sourceUpdater_.audioBuffered());
                return typeof _ == "number" && (T.audioAppendStart = _ - this.sourceUpdater_.audioTimestampOffset()),
                    this.sourceUpdater_.videoBuffered().length && (T.gopsToAlignWith = T1(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_)),
                    T
            }
            timestampOffsetForSegment_(t) {
                return k1(t)
            }
            earlyAbortWhenNeeded_(t) {
                if (this.vhs_.tech_.paused() || !this.xhrOptions_.timeout || !this.playlist_.attributes.BANDWIDTH || Date.now() - (t.firstBytesReceivedAt || Date.now()) < 1e3)
                    return;
                const e = this.currentTime_()
                    , s = t.bandwidth
                    , r = this.pendingSegment_.duration
                    , n = si.estimateSegmentRequestTime(r, s, this.playlist_, t.bytesReceived)
                    , a = YT(this.buffered_(), e, this.vhs_.tech_.playbackRate()) - 1;
                if (n <= a)
                    return;
                const o = u1({
                    main: this.vhs_.playlists.main,
                    currentTime: e,
                    bandwidth: s,
                    duration: this.duration_(),
                    segmentDuration: r,
                    timeUntilRebuffer: a,
                    currentTimeline: this.currentTimeline_,
                    syncController: this.syncController_
                });
                if (!o)
                    return;
                const c = n - a - o.rebufferingImpact;
                let f = .5;
                a <= Ks && (f = 1),
                    !(!o.playlist || o.playlist.uri === this.playlist_.uri || c < f) && (this.bandwidth = o.playlist.attributes.BANDWIDTH * mt.BANDWIDTH_VARIANCE + 1,
                        this.trigger("earlyabort"))
            }
            handleAbort_(t) {
                this.logger_(`Aborting ${Dn(t)}`),
                    this.mediaRequestsAborted += 1
            }
            handleProgress_(t, e) {
                this.earlyAbortWhenNeeded_(e.stats),
                    !this.checkForAbort_(e.requestId) && this.trigger("progress")
            }
            handleTrackInfo_(t, e) {
                this.earlyAbortWhenNeeded_(t.stats),
                    !this.checkForAbort_(t.requestId) && (this.checkForIllegalMediaSwitch(e) || (e = e || {},
                        S1(this.currentMediaInfo_, e) || (this.appendInitSegment_ = {
                            audio: !0,
                            video: !0
                        },
                            this.startingMediaInfo_ = e,
                            this.currentMediaInfo_ = e,
                            this.logger_("trackinfo update", e),
                            this.trigger("trackinfo")),
                        !this.checkForAbort_(t.requestId) && (this.pendingSegment_.trackInfo = e,
                            this.hasEnoughInfoToAppend_() && this.processCallQueue_())))
            }
            handleTimingInfo_(t, e, s, r) {
                if (this.earlyAbortWhenNeeded_(t.stats),
                    this.checkForAbort_(t.requestId))
                    return;
                const n = this.pendingSegment_
                    , a = Hm(e);
                n[a] = n[a] || {},
                    n[a][s] = r,
                    this.logger_(`timinginfo: ${e} - ${s} - ${r}`),
                    this.hasEnoughInfoToAppend_() && this.processCallQueue_()
            }
            handleCaptions_(t, e) {
                if (this.earlyAbortWhenNeeded_(t.stats),
                    this.checkForAbort_(t.requestId))
                    return;
                if (e.length === 0) {
                    this.logger_("SegmentLoader received no captions from a caption event");
                    return
                }
                if (!this.pendingSegment_.hasAppendedData_) {
                    this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, t, e));
                    return
                }
                const r = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset()
                    , n = {};
                e.forEach(a => {
                    n[a.stream] = n[a.stream] || {
                        startTime: 1 / 0,
                        captions: [],
                        endTime: 0
                    };
                    const o = n[a.stream];
                    o.startTime = Math.min(o.startTime, a.startTime + r),
                        o.endTime = Math.max(o.endTime, a.endTime + r),
                        o.captions.push(a)
                }
                ),
                    Object.keys(n).forEach(a => {
                        const { startTime: o, endTime: u, captions: c } = n[a]
                            , f = this.inbandTextTracks_;
                        this.logger_(`adding cues from ${o} -> ${u} for ${a}`),
                            c1(f, this.vhs_.tech_, a),
                            Ba(o, u, f[a]),
                            f1({
                                captionArray: c,
                                inbandTextTracks: f,
                                timestampOffset: r
                            })
                    }
                    ),
                    this.transmuxer_ && this.transmuxer_.postMessage({
                        action: "clearParsedMp4Captions"
                    })
            }
            handleId3_(t, e, s) {
                if (this.earlyAbortWhenNeeded_(t.stats),
                    this.checkForAbort_(t.requestId))
                    return;
                if (!this.pendingSegment_.hasAppendedData_) {
                    this.metadataQueue_.id3.push(this.handleId3_.bind(this, t, e, s));
                    return
                }
                this.addMetadataToTextTrack(s, e, this.duration_())
            }
            processMetadataQueue_() {
                this.metadataQueue_.id3.forEach(t => t()),
                    this.metadataQueue_.caption.forEach(t => t()),
                    this.metadataQueue_.id3 = [],
                    this.metadataQueue_.caption = []
            }
            processCallQueue_() {
                const t = this.callQueue_;
                this.callQueue_ = [],
                    t.forEach(e => e())
            }
            processLoadQueue_() {
                const t = this.loadQueue_;
                this.loadQueue_ = [],
                    t.forEach(e => e())
            }
            hasEnoughInfoToLoad_() {
                if (this.loaderType_ !== "audio")
                    return !0;
                const t = this.pendingSegment_;
                return t ? this.getCurrentMediaInfo_() ? !qm({
                    timelineChangeController: this.timelineChangeController_,
                    currentTimeline: this.currentTimeline_,
                    segmentTimeline: t.timeline,
                    loaderType: this.loaderType_,
                    audioDisabled: this.audioDisabled_
                }) : !0 : !1
            }
            getCurrentMediaInfo_(t = this.pendingSegment_) {
                return t && t.trackInfo || this.currentMediaInfo_
            }
            getMediaInfo_(t = this.pendingSegment_) {
                return this.getCurrentMediaInfo_(t) || this.startingMediaInfo_
            }
            getPendingSegmentPlaylist() {
                return this.pendingSegment_ ? this.pendingSegment_.playlist : null
            }
            hasEnoughInfoToAppend_() {
                if (!this.sourceUpdater_.ready() || this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_)
                    return !1;
                const t = this.pendingSegment_
                    , e = this.getCurrentMediaInfo_();
                if (!t || !e)
                    return !1;
                const { hasAudio: s, hasVideo: r, isMuxed: n } = e;
                return !(r && !t.videoTimingInfo || s && !this.audioDisabled_ && !n && !t.audioTimingInfo || qm({
                    timelineChangeController: this.timelineChangeController_,
                    currentTimeline: this.currentTimeline_,
                    segmentTimeline: t.timeline,
                    loaderType: this.loaderType_,
                    audioDisabled: this.audioDisabled_
                }))
            }
            handleData_(t, e) {
                if (this.earlyAbortWhenNeeded_(t.stats),
                    this.checkForAbort_(t.requestId))
                    return;
                if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
                    this.callQueue_.push(this.handleData_.bind(this, t, e));
                    return
                }
                const s = this.pendingSegment_;
                if (this.setTimeMapping_(s.timeline),
                    this.updateMediaSecondsLoaded_(s.part || s.segment),
                    this.mediaSource_.readyState !== "closed") {
                    if (t.map && (t.map = this.initSegmentForMap(t.map, !0),
                        s.segment.map = t.map),
                        t.key && this.segmentKey(t.key, !0),
                        s.isFmp4 = t.isFmp4,
                        s.timingInfo = s.timingInfo || {},
                        s.isFmp4)
                        this.trigger("fmp4"),
                            s.timingInfo.start = s[Hm(e.type)].start;
                    else {
                        const r = this.getCurrentMediaInfo_()
                            , n = this.loaderType_ === "main" && r && r.hasVideo;
                        let a;
                        n && (a = s.videoTimingInfo.start),
                            s.timingInfo.start = this.trueSegmentStart_({
                                currentStart: s.timingInfo.start,
                                playlist: s.playlist,
                                mediaIndex: s.mediaIndex,
                                currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
                                useVideoTimingInfo: n,
                                firstVideoFrameTimeForData: a,
                                videoTimingInfo: s.videoTimingInfo,
                                audioTimingInfo: s.audioTimingInfo
                            })
                    }
                    if (this.updateAppendInitSegmentStatus(s, e.type),
                        this.updateSourceBufferTimestampOffset_(s),
                        s.isSyncRequest) {
                        this.updateTimingInfoEnd_(s),
                            this.syncController_.saveSegmentTimingInfo({
                                segmentInfo: s,
                                shouldSaveTimelineMapping: this.loaderType_ === "main"
                            });
                        const r = this.chooseNextRequest_();
                        if (r.mediaIndex !== s.mediaIndex || r.partIndex !== s.partIndex) {
                            this.logger_("sync segment was incorrect, not appending");
                            return
                        }
                        this.logger_("sync segment was correct, appending")
                    }
                    s.hasAppendedData_ = !0,
                        this.processMetadataQueue_(),
                        this.appendData_(s, e)
                }
            }
            updateAppendInitSegmentStatus(t, e) {
                this.loaderType_ === "main" && typeof t.timestampOffset == "number" && !t.changedTimestampOffset && (this.appendInitSegment_ = {
                    audio: !0,
                    video: !0
                }),
                    this.playlistOfLastInitSegment_[e] !== t.playlist && (this.appendInitSegment_[e] = !0)
            }
            getInitSegmentAndUpdateState_({ type: t, initSegment: e, map: s, playlist: r }) {
                if (s) {
                    const n = wl(s);
                    if (this.activeInitSegmentId_ === n)
                        return null;
                    e = this.initSegmentForMap(s, !0).bytes,
                        this.activeInitSegmentId_ = n
                }
                return e && this.appendInitSegment_[t] ? (this.playlistOfLastInitSegment_[t] = r,
                    this.appendInitSegment_[t] = !1,
                    this.activeInitSegmentId_ = null,
                    e) : null
            }
            handleQuotaExceededError_({ segmentInfo: t, type: e, bytes: s }, r) {
                const n = this.sourceUpdater_.audioBuffered()
                    , a = this.sourceUpdater_.videoBuffered();
                n.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + Sr(n).join(", ")),
                    a.length > 1 && this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + Sr(a).join(", "));
                const o = n.length ? n.start(0) : 0
                    , u = n.length ? n.end(n.length - 1) : 0
                    , c = a.length ? a.start(0) : 0
                    , f = a.length ? a.end(a.length - 1) : 0;
                if (u - o <= Fa && f - c <= Fa) {
                    this.logger_(`On QUOTA_EXCEEDED_ERR, single segment too large to append to buffer, triggering an error. Appended byte length: ${s.byteLength}, audio buffer: ${Sr(n).join(", ")}, video buffer: ${Sr(a).join(", ")}, `),
                        this.error({
                            message: "Quota exceeded error with append of a single segment of content",
                            excludeUntil: 1 / 0
                        }),
                        this.trigger("error");
                    return
                }
                this.waitingOnRemove_ = !0,
                    this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
                        segmentInfo: t,
                        type: e,
                        bytes: s
                    }));
                const T = this.currentTime_() - Fa;
                this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${T}`),
                    this.remove(0, T, () => {
                        this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${Fa}s`),
                            this.waitingOnRemove_ = !1,
                            this.quotaExceededErrorRetryTimeout_ = O.default.setTimeout(() => {
                                this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue"),
                                    this.quotaExceededErrorRetryTimeout_ = null,
                                    this.processCallQueue_()
                            }
                                , Fa * 1e3)
                    }
                        , !0)
            }
            handleAppendError_({ segmentInfo: t, type: e, bytes: s }, r) {
                if (r) {
                    if (r.code === Um) {
                        this.handleQuotaExceededError_({
                            segmentInfo: t,
                            type: e,
                            bytes: s
                        });
                        return
                    }
                    this.logger_("Received non QUOTA_EXCEEDED_ERR on append", r),
                        this.error(`${e} append of ${s.length}b failed for segment #${t.mediaIndex} in playlist ${t.playlist.id}`),
                        this.trigger("appenderror")
                }
            }
            appendToSourceBuffer_({ segmentInfo: t, type: e, initSegment: s, data: r, bytes: n }) {
                if (!n) {
                    const a = [r];
                    let o = r.byteLength;
                    s && (a.unshift(s),
                        o += s.byteLength),
                        n = d1({
                            bytes: o,
                            segments: a
                        })
                }
                this.sourceUpdater_.appendBuffer({
                    segmentInfo: t,
                    type: e,
                    bytes: n
                }, this.handleAppendError_.bind(this, {
                    segmentInfo: t,
                    type: e,
                    bytes: n
                }))
            }
            handleSegmentTimingInfo_(t, e, s) {
                if (!this.pendingSegment_ || e !== this.pendingSegment_.requestId)
                    return;
                const r = this.pendingSegment_.segment
                    , n = `${t}TimingInfo`;
                r[n] || (r[n] = {}),
                    r[n].transmuxerPrependedSeconds = s.prependedContentDuration || 0,
                    r[n].transmuxedPresentationStart = s.start.presentation,
                    r[n].transmuxedDecodeStart = s.start.decode,
                    r[n].transmuxedPresentationEnd = s.end.presentation,
                    r[n].transmuxedDecodeEnd = s.end.decode,
                    r[n].baseMediaDecodeTime = s.baseMediaDecodeTime
            }
            appendData_(t, e) {
                const { type: s, data: r } = e;
                if (!r || !r.byteLength || s === "audio" && this.audioDisabled_)
                    return;
                const n = this.getInitSegmentAndUpdateState_({
                    type: s,
                    initSegment: e.initSegment,
                    playlist: t.playlist,
                    map: t.isFmp4 ? t.segment.map : null
                });
                this.appendToSourceBuffer_({
                    segmentInfo: t,
                    type: s,
                    initSegment: n,
                    data: r
                })
            }
            loadSegment_(t) {
                if (this.state = "WAITING",
                    this.pendingSegment_ = t,
                    this.trimBackBuffer_(t),
                    typeof t.timestampOffset == "number" && this.transmuxer_ && this.transmuxer_.postMessage({
                        action: "clearAllMp4Captions"
                    }),
                    !this.hasEnoughInfoToLoad_()) {
                    this.loadQueue_.push(() => {
                        const e = Pi({}, t, {
                            forceTimestampOffset: !0
                        });
                        Pi(t, this.generateSegmentInfo_(e)),
                            this.isPendingTimestampOffset_ = !1,
                            this.updateTransmuxerAndRequestSegment_(t)
                    }
                    );
                    return
                }
                this.updateTransmuxerAndRequestSegment_(t)
            }
            updateTransmuxerAndRequestSegment_(t) {
                this.shouldUpdateTransmuxerTimestampOffset_(t.timestampOffset) && (this.gopBuffer_.length = 0,
                    t.gopsToAlignWith = [],
                    this.timeMapping_ = 0,
                    this.transmuxer_.postMessage({
                        action: "reset"
                    }),
                    this.transmuxer_.postMessage({
                        action: "setTimestampOffset",
                        timestampOffset: t.timestampOffset
                    }));
                const e = this.createSimplifiedSegmentObj_(t)
                    , s = this.isEndOfStream_(t.mediaIndex, t.playlist, t.partIndex)
                    , r = this.mediaIndex !== null
                    , n = t.timeline !== this.currentTimeline_ && t.timeline > 0
                    , a = s || r && n;
                this.logger_(`Requesting ${Dn(t)}`),
                    e.map && !e.map.bytes && (this.logger_("going to request init segment."),
                        this.appendInitSegment_ = {
                            video: !0,
                            audio: !0
                        }),
                    t.abortRequests = s1({
                        xhr: this.vhs_.xhr,
                        xhrOptions: this.xhrOptions_,
                        decryptionWorker: this.decrypter_,
                        segment: e,
                        abortFn: this.handleAbort_.bind(this, t),
                        progressFn: this.handleProgress_.bind(this),
                        trackInfoFn: this.handleTrackInfo_.bind(this),
                        timingInfoFn: this.handleTimingInfo_.bind(this),
                        videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", t.requestId),
                        audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", t.requestId),
                        captionsFn: this.handleCaptions_.bind(this),
                        isEndOfTimeline: a,
                        endedTimelineFn: () => {
                            this.logger_("received endedtimeline callback")
                        }
                        ,
                        id3Fn: this.handleId3_.bind(this),
                        dataFn: this.handleData_.bind(this),
                        doneFn: this.segmentRequestFinished_.bind(this),
                        onTransmuxerLog: ({ message: o, level: u, stream: c }) => {
                            this.logger_(`${Dn(t)} logged from transmuxer stream ${c} as a ${u}: ${o}`)
                        }
                    })
            }
            trimBackBuffer_(t) {
                const e = D1(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
                e > 0 && this.remove(0, e)
            }
            createSimplifiedSegmentObj_(t) {
                const e = t.segment
                    , s = t.part
                    , r = {
                        resolvedUri: s ? s.resolvedUri : e.resolvedUri,
                        byterange: s ? s.byterange : e.byterange,
                        requestId: t.requestId,
                        transmuxer: t.transmuxer,
                        audioAppendStart: t.audioAppendStart,
                        gopsToAlignWith: t.gopsToAlignWith,
                        part: t.part
                    }
                    , n = t.playlist.segments[t.mediaIndex - 1];
                if (n && n.timeline === e.timeline && (n.videoTimingInfo ? r.baseStartTime = n.videoTimingInfo.transmuxedDecodeEnd : n.audioTimingInfo && (r.baseStartTime = n.audioTimingInfo.transmuxedDecodeEnd)),
                    e.key) {
                    const a = e.key.iv || new Uint32Array([0, 0, 0, t.mediaIndex + t.playlist.mediaSequence]);
                    r.key = this.segmentKey(e.key),
                        r.key.iv = a
                }
                return e.map && (r.map = this.initSegmentForMap(e.map)),
                    r
            }
            saveTransferStats_(t) {
                this.mediaRequests += 1,
                    t && (this.mediaBytesTransferred += t.bytesReceived,
                        this.mediaTransferDuration += t.roundTripTime)
            }
            saveBandwidthRelatedStats_(t, e) {
                if (this.pendingSegment_.byteLength = e.bytesReceived,
                    t < Il) {
                    this.logger_(`Ignoring segment's bandwidth because its duration of ${t} is less than the min to record ${Il}`);
                    return
                }
                this.bandwidth = e.bandwidth,
                    this.roundTrip = e.roundTripTime
            }
            handleTimeout_() {
                this.mediaRequestsTimedout += 1,
                    this.bandwidth = 1,
                    this.roundTrip = NaN,
                    this.trigger("bandwidthupdate"),
                    this.trigger("timeout")
            }
            segmentRequestFinished_(t, e, s) {
                if (this.callQueue_.length) {
                    this.callQueue_.push(this.segmentRequestFinished_.bind(this, t, e, s));
                    return
                }
                if (this.saveTransferStats_(e.stats),
                    !this.pendingSegment_ || e.requestId !== this.pendingSegment_.requestId)
                    return;
                if (t) {
                    if (this.pendingSegment_ = null,
                        this.state = "READY",
                        t.code === rs.ABORTED)
                        return;
                    if (this.pause(),
                        t.code === rs.TIMEOUT) {
                        this.handleTimeout_();
                        return
                    }
                    this.mediaRequestsErrored += 1,
                        this.error(t),
                        this.trigger("error");
                    return
                }
                const r = this.pendingSegment_;
                this.saveBandwidthRelatedStats_(r.duration, e.stats),
                    r.endOfAllRequests = e.endOfAllRequests,
                    s.gopInfo && (this.gopBuffer_ = b1(this.gopBuffer_, s.gopInfo, this.safeAppend_)),
                    this.state = "APPENDING",
                    this.trigger("appending"),
                    this.waitForAppendsToComplete_(r)
            }
            setTimeMapping_(t) {
                const e = this.syncController_.mappingForTimeline(t);
                e !== null && (this.timeMapping_ = e)
            }
            updateMediaSecondsLoaded_(t) {
                typeof t.start == "number" && typeof t.end == "number" ? this.mediaSecondsLoaded += t.end - t.start : this.mediaSecondsLoaded += t.duration
            }
            shouldUpdateTransmuxerTimestampOffset_(t) {
                return t === null ? !1 : this.loaderType_ === "main" && t !== this.sourceUpdater_.videoTimestampOffset() || !this.audioDisabled_ && t !== this.sourceUpdater_.audioTimestampOffset()
            }
            trueSegmentStart_({ currentStart: t, playlist: e, mediaIndex: s, firstVideoFrameTimeForData: r, currentVideoTimestampOffset: n, useVideoTimingInfo: a, videoTimingInfo: o, audioTimingInfo: u }) {
                if (typeof t < "u")
                    return t;
                if (!a)
                    return u.start;
                const c = e.segments[s - 1];
                return s === 0 || !c || typeof c.start > "u" || c.end !== r + n ? r : o.start
            }
            waitForAppendsToComplete_(t) {
                const e = this.getCurrentMediaInfo_(t);
                if (!e) {
                    this.error({
                        message: "No starting media returned, likely due to an unsupported media format.",
                        playlistExclusionDuration: 1 / 0
                    }),
                        this.trigger("error");
                    return
                }
                const { hasAudio: s, hasVideo: r, isMuxed: n } = e
                    , a = this.loaderType_ === "main" && r
                    , o = !this.audioDisabled_ && s && !n;
                if (t.waitingOnAppends = 0,
                    !t.hasAppendedData_) {
                    !t.timingInfo && typeof t.timestampOffset == "number" && (this.isPendingTimestampOffset_ = !0),
                        t.timingInfo = {
                            start: 0
                        },
                        t.waitingOnAppends++,
                        this.isPendingTimestampOffset_ || (this.updateSourceBufferTimestampOffset_(t),
                            this.processMetadataQueue_()),
                        this.checkAppendsDone_(t);
                    return
                }
                a && t.waitingOnAppends++,
                    o && t.waitingOnAppends++,
                    a && this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, t)),
                    o && this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, t))
            }
            checkAppendsDone_(t) {
                this.checkForAbort_(t.requestId) || (t.waitingOnAppends--,
                    t.waitingOnAppends === 0 && this.handleAppendsDone_())
            }
            checkForIllegalMediaSwitch(t) {
                const e = w1(this.loaderType_, this.getCurrentMediaInfo_(), t);
                return e ? (this.error({
                    message: e,
                    playlistExclusionDuration: 1 / 0
                }),
                    this.trigger("error"),
                    !0) : !1
            }
            updateSourceBufferTimestampOffset_(t) {
                if (t.timestampOffset === null || typeof t.timingInfo.start != "number" || t.changedTimestampOffset || this.loaderType_ !== "main")
                    return;
                let e = !1;
                t.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
                    videoTimingInfo: t.segment.videoTimingInfo,
                    audioTimingInfo: t.segment.audioTimingInfo,
                    timingInfo: t.timingInfo
                }),
                    t.changedTimestampOffset = !0,
                    t.timestampOffset !== this.sourceUpdater_.videoTimestampOffset() && (this.sourceUpdater_.videoTimestampOffset(t.timestampOffset),
                        e = !0),
                    t.timestampOffset !== this.sourceUpdater_.audioTimestampOffset() && (this.sourceUpdater_.audioTimestampOffset(t.timestampOffset),
                        e = !0),
                    e && this.trigger("timestampoffset")
            }
            getSegmentStartTimeForTimestampOffsetCalculation_({ videoTimingInfo: t, audioTimingInfo: e, timingInfo: s }) {
                return this.useDtsForTimestampOffset_ ? t && typeof t.transmuxedDecodeStart == "number" ? t.transmuxedDecodeStart : e && typeof e.transmuxedDecodeStart == "number" ? e.transmuxedDecodeStart : s.start : s.start
            }
            updateTimingInfoEnd_(t) {
                t.timingInfo = t.timingInfo || {};
                const e = this.getMediaInfo_()
                    , r = this.loaderType_ === "main" && e && e.hasVideo && t.videoTimingInfo ? t.videoTimingInfo : t.audioTimingInfo;
                r && (t.timingInfo.end = typeof r.end == "number" ? r.end : r.start + t.duration)
            }
            handleAppendsDone_() {
                if (this.pendingSegment_ && this.trigger("appendsdone"),
                    !this.pendingSegment_) {
                    this.state = "READY",
                        this.paused() || this.monitorBuffer_();
                    return
                }
                const t = this.pendingSegment_;
                this.updateTimingInfoEnd_(t),
                    this.shouldSaveSegmentTimingInfo_ && this.syncController_.saveSegmentTimingInfo({
                        segmentInfo: t,
                        shouldSaveTimelineMapping: this.loaderType_ === "main"
                    });
                const e = I1(t, this.sourceType_);
                if (e && (e.severity === "warn" ? U.log.warn(e.message) : this.logger_(e.message)),
                    this.recordThroughput_(t),
                    this.pendingSegment_ = null,
                    this.state = "READY",
                    t.isSyncRequest && (this.trigger("syncinfoupdate"),
                        !t.hasAppendedData_)) {
                    this.logger_(`Throwing away un-appended sync request ${Dn(t)}`);
                    return
                }
                this.logger_(`Appended ${Dn(t)}`),
                    this.addSegmentMetadataCue_(t),
                    this.fetchAtBuffer_ = !0,
                    this.currentTimeline_ !== t.timeline && (this.timelineChangeController_.lastTimelineChange({
                        type: this.loaderType_,
                        from: this.currentTimeline_,
                        to: t.timeline
                    }),
                        this.loaderType_ === "main" && !this.audioDisabled_ && this.timelineChangeController_.lastTimelineChange({
                            type: "audio",
                            from: this.currentTimeline_,
                            to: t.timeline
                        })),
                    this.currentTimeline_ = t.timeline,
                    this.trigger("syncinfoupdate");
                const s = t.segment
                    , r = t.part
                    , n = s.end && this.currentTime_() - s.end > t.playlist.targetDuration * 3
                    , a = r && r.end && this.currentTime_() - r.end > t.playlist.partTargetDuration * 3;
                if (n || a) {
                    this.logger_(`bad ${n ? "segment" : "part"} ${Dn(t)}`),
                        this.resetEverything();
                    return
                }
                this.mediaIndex !== null && this.trigger("bandwidthupdate"),
                    this.trigger("progress"),
                    this.mediaIndex = t.mediaIndex,
                    this.partIndex = t.partIndex,
                    this.isEndOfStream_(t.mediaIndex, t.playlist, t.partIndex) && this.endOfStream(),
                    this.trigger("appended"),
                    t.hasAppendedData_ && this.mediaAppends++,
                    this.paused() || this.monitorBuffer_()
            }
            recordThroughput_(t) {
                if (t.duration < Il) {
                    this.logger_(`Ignoring segment's throughput because its duration of ${t.duration} is less than the min to record ${Il}`);
                    return
                }
                const e = this.throughput.rate
                    , s = Date.now() - t.endOfAllRequests + 1
                    , r = Math.floor(t.byteLength / s * 8 * 1e3);
                this.throughput.rate += (r - e) / ++this.throughput.count
            }
            addSegmentMetadataCue_(t) {
                if (!this.segmentMetadataTrack_)
                    return;
                const e = t.segment
                    , s = e.start
                    , r = e.end;
                if (!jm(s) || !jm(r))
                    return;
                Ba(s, r, this.segmentMetadataTrack_);
                const n = O.default.WebKitDataCue || O.default.VTTCue
                    , a = {
                        custom: e.custom,
                        dateTimeObject: e.dateTimeObject,
                        dateTimeString: e.dateTimeString,
                        programDateTime: e.programDateTime,
                        bandwidth: t.playlist.attributes.BANDWIDTH,
                        resolution: t.playlist.attributes.RESOLUTION,
                        codecs: t.playlist.attributes.CODECS,
                        byteLength: t.byteLength,
                        uri: t.uri,
                        timeline: t.timeline,
                        playlist: t.playlist.id,
                        start: s,
                        end: r
                    }
                    , o = JSON.stringify(a)
                    , u = new n(s, r, o);
                u.value = a,
                    this.segmentMetadataTrack_.addCue(u)
            }
        }
        ;
    function bs() { }
    var Vm = function (t) {
        return typeof t != "string" ? t : t.replace(/./, e => e.toUpperCase())
    }, P1 = ["video", "audio"], Od = (t, e) => {
        const s = e[`${t}Buffer`];
        return s && s.updating || e.queuePending[t]
    }
        , L1 = (t, e) => {
            for (let s = 0; s < e.length; s++) {
                const r = e[s];
                if (r.type === "mediaSource")
                    return null;
                if (r.type === t)
                    return s
            }
            return null
        }
        , kn = (t, e) => {
            if (e.queue.length === 0)
                return;
            let s = 0
                , r = e.queue[s];
            if (r.type === "mediaSource") {
                !e.updating() && e.mediaSource.readyState !== "closed" && (e.queue.shift(),
                    r.action(e),
                    r.doneFn && r.doneFn(),
                    kn("audio", e),
                    kn("video", e));
                return
            }
            if (t !== "mediaSource" && !(!e.ready() || e.mediaSource.readyState === "closed" || Od(t, e))) {
                if (r.type !== t) {
                    if (s = L1(t, e.queue),
                        s === null)
                        return;
                    r = e.queue[s]
                }
                if (e.queue.splice(s, 1),
                    e.queuePending[t] = r,
                    r.action(t, e),
                    !r.doneFn) {
                    e.queuePending[t] = null,
                        kn(t, e);
                    return
                }
            }
        }
        , zm = (t, e) => {
            const s = e[`${t}Buffer`]
                , r = Vm(t);
            s && (s.removeEventListener("updateend", e[`on${r}UpdateEnd_`]),
                s.removeEventListener("error", e[`on${r}Error_`]),
                e.codecs[t] = null,
                e[`${t}Buffer`] = null)
        }
        , ns = (t, e) => t && e && Array.prototype.indexOf.call(t.sourceBuffers, e) !== -1, di = {
            appendBuffer: (t, e, s) => (r, n) => {
                const a = n[`${r}Buffer`];
                if (ns(n.mediaSource, a)) {
                    n.logger_(`Appending segment ${e.mediaIndex}'s ${t.length} bytes to ${r}Buffer`);
                    try {
                        a.appendBuffer(t)
                    } catch (o) {
                        n.logger_(`Error with code ${o.code} ` + (o.code === Um ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${e.mediaIndex} to ${r}Buffer`),
                            n.queuePending[r] = null,
                            s(o)
                    }
                }
            }
            ,
            remove: (t, e) => (s, r) => {
                const n = r[`${s}Buffer`];
                if (ns(r.mediaSource, n)) {
                    r.logger_(`Removing ${t} to ${e} from ${s}Buffer`);
                    try {
                        n.remove(t, e)
                    } catch (a) {
                        r.logger_(`Remove ${t} to ${e} from ${s}Buffer failed`)
                    }
                }
            }
            ,
            timestampOffset: t => (e, s) => {
                const r = s[`${e}Buffer`];
                ns(s.mediaSource, r) && (s.logger_(`Setting ${e}timestampOffset to ${t}`),
                    r.timestampOffset = t)
            }
            ,
            callback: t => (e, s) => {
                t()
            }
            ,
            endOfStream: t => e => {
                if (e.mediaSource.readyState === "open") {
                    e.logger_(`Calling mediaSource endOfStream(${t || ""})`);
                    try {
                        e.mediaSource.endOfStream(t)
                    } catch (s) {
                        U.log.warn("Failed to call media source endOfStream", s)
                    }
                }
            }
            ,
            duration: t => e => {
                e.logger_(`Setting mediaSource duration to ${t}`);
                try {
                    e.mediaSource.duration = t
                } catch (s) {
                    U.log.warn("Failed to set media source duration", s)
                }
            }
            ,
            abort: () => (t, e) => {
                if (e.mediaSource.readyState !== "open")
                    return;
                const s = e[`${t}Buffer`];
                if (ns(e.mediaSource, s)) {
                    e.logger_(`calling abort on ${t}Buffer`);
                    try {
                        s.abort()
                    } catch (r) {
                        U.log.warn(`Failed to abort on ${t}Buffer`, r)
                    }
                }
            }
            ,
            addSourceBuffer: (t, e) => s => {
                const r = Vm(t)
                    , n = ma(e);
                s.logger_(`Adding ${t}Buffer with codec ${e} to mediaSource`);
                const a = s.mediaSource.addSourceBuffer(n);
                a.addEventListener("updateend", s[`on${r}UpdateEnd_`]),
                    a.addEventListener("error", s[`on${r}Error_`]),
                    s.codecs[t] = e,
                    s[`${t}Buffer`] = a
            }
            ,
            removeSourceBuffer: t => e => {
                const s = e[`${t}Buffer`];
                if (zm(t, e),
                    !!ns(e.mediaSource, s)) {
                    e.logger_(`Removing ${t}Buffer with codec ${e.codecs[t]} from mediaSource`);
                    try {
                        e.mediaSource.removeSourceBuffer(s)
                    } catch (r) {
                        U.log.warn(`Failed to removeSourceBuffer ${t}Buffer`, r)
                    }
                }
            }
            ,
            changeType: t => (e, s) => {
                const r = s[`${e}Buffer`]
                    , n = ma(t);
                ns(s.mediaSource, r) && s.codecs[e] !== t && (s.logger_(`changing ${e}Buffer codec from ${s.codecs[e]} to ${t}`),
                    r.changeType(n),
                    s.codecs[e] = t)
            }
        }, ci = ({ type: t, sourceUpdater: e, action: s, doneFn: r, name: n }) => {
            e.queue.push({
                type: t,
                action: s,
                doneFn: r,
                name: n
            }),
                kn(t, e)
        }
        , Gm = (t, e) => s => {
            if (e.queuePending[t]) {
                const r = e.queuePending[t].doneFn;
                e.queuePending[t] = null,
                    r && r(e[`${t}Error_`])
            }
            kn(t, e)
        }
        , Wm = class extends U.EventTarget {
            constructor(t) {
                super(),
                    this.mediaSource = t,
                    this.sourceopenListener_ = () => kn("mediaSource", this),
                    this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_),
                    this.logger_ = Ci("SourceUpdater"),
                    this.audioTimestampOffset_ = 0,
                    this.videoTimestampOffset_ = 0,
                    this.queue = [],
                    this.queuePending = {
                        audio: null,
                        video: null
                    },
                    this.delayedAudioAppendQueue_ = [],
                    this.videoAppendQueued_ = !1,
                    this.codecs = {},
                    this.onVideoUpdateEnd_ = Gm("video", this),
                    this.onAudioUpdateEnd_ = Gm("audio", this),
                    this.onVideoError_ = e => {
                        this.videoError_ = e
                    }
                    ,
                    this.onAudioError_ = e => {
                        this.audioError_ = e
                    }
                    ,
                    this.createdSourceBuffers_ = !1,
                    this.initializedEme_ = !1,
                    this.triggeredReady_ = !1
            }
            initializedEme() {
                this.initializedEme_ = !0,
                    this.triggerReady()
            }
            hasCreatedSourceBuffers() {
                return this.createdSourceBuffers_
            }
            hasInitializedAnyEme() {
                return this.initializedEme_
            }
            ready() {
                return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme()
            }
            createSourceBuffers(t) {
                this.hasCreatedSourceBuffers() || (this.addOrChangeSourceBuffers(t),
                    this.createdSourceBuffers_ = !0,
                    this.trigger("createdsourcebuffers"),
                    this.triggerReady())
            }
            triggerReady() {
                this.ready() && !this.triggeredReady_ && (this.triggeredReady_ = !0,
                    this.trigger("ready"))
            }
            addSourceBuffer(t, e) {
                ci({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: di.addSourceBuffer(t, e),
                    name: "addSourceBuffer"
                })
            }
            abort(t) {
                ci({
                    type: t,
                    sourceUpdater: this,
                    action: di.abort(t),
                    name: "abort"
                })
            }
            removeSourceBuffer(t) {
                if (!this.canRemoveSourceBuffer()) {
                    U.log.error("removeSourceBuffer is not supported!");
                    return
                }
                ci({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: di.removeSourceBuffer(t),
                    name: "removeSourceBuffer"
                })
            }
            canRemoveSourceBuffer() {
                return !U.browser.IS_FIREFOX && O.default.MediaSource && O.default.MediaSource.prototype && typeof O.default.MediaSource.prototype.removeSourceBuffer == "function"
            }
            static canChangeType() {
                return O.default.SourceBuffer && O.default.SourceBuffer.prototype && typeof O.default.SourceBuffer.prototype.changeType == "function"
            }
            canChangeType() {
                return this.constructor.canChangeType()
            }
            changeType(t, e) {
                if (!this.canChangeType()) {
                    U.log.error("changeType is not supported!");
                    return
                }
                ci({
                    type: t,
                    sourceUpdater: this,
                    action: di.changeType(e),
                    name: "changeType"
                })
            }
            addOrChangeSourceBuffers(t) {
                if (!t || typeof t != "object" || Object.keys(t).length === 0)
                    throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
                Object.keys(t).forEach(e => {
                    const s = t[e];
                    if (!this.hasCreatedSourceBuffers())
                        return this.addSourceBuffer(e, s);
                    this.canChangeType() && this.changeType(e, s)
                }
                )
            }
            appendBuffer(t, e) {
                const { segmentInfo: s, type: r, bytes: n } = t;
                if (this.processedAppend_ = !0,
                    r === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
                    this.delayedAudioAppendQueue_.push([t, e]),
                        this.logger_(`delayed audio append of ${n.length} until video append`);
                    return
                }
                const a = e;
                if (ci({
                    type: r,
                    sourceUpdater: this,
                    action: di.appendBuffer(n, s || {
                        mediaIndex: -1
                    }, a),
                    doneFn: e,
                    name: "appendBuffer"
                }),
                    r === "video") {
                    if (this.videoAppendQueued_ = !0,
                        !this.delayedAudioAppendQueue_.length)
                        return;
                    const o = this.delayedAudioAppendQueue_.slice();
                    this.logger_(`queuing delayed audio ${o.length} appendBuffers`),
                        this.delayedAudioAppendQueue_.length = 0,
                        o.forEach(u => {
                            this.appendBuffer.apply(this, u)
                        }
                        )
                }
            }
            audioBuffered() {
                return ns(this.mediaSource, this.audioBuffer) && this.audioBuffer.buffered ? this.audioBuffer.buffered : xt()
            }
            videoBuffered() {
                return ns(this.mediaSource, this.videoBuffer) && this.videoBuffer.buffered ? this.videoBuffer.buffered : xt()
            }
            buffered() {
                const t = ns(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null
                    , e = ns(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
                return e && !t ? this.audioBuffered() : t && !e ? this.videoBuffered() : XT(this.audioBuffered(), this.videoBuffered())
            }
            setDuration(t, e = bs) {
                ci({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: di.duration(t),
                    name: "duration",
                    doneFn: e
                })
            }
            endOfStream(t = null, e = bs) {
                typeof t != "string" && (t = void 0),
                    ci({
                        type: "mediaSource",
                        sourceUpdater: this,
                        action: di.endOfStream(t),
                        name: "endOfStream",
                        doneFn: e
                    })
            }
            removeAudio(t, e, s = bs) {
                if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
                    s();
                    return
                }
                ci({
                    type: "audio",
                    sourceUpdater: this,
                    action: di.remove(t, e),
                    doneFn: s,
                    name: "remove"
                })
            }
            removeVideo(t, e, s = bs) {
                if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
                    s();
                    return
                }
                ci({
                    type: "video",
                    sourceUpdater: this,
                    action: di.remove(t, e),
                    doneFn: s,
                    name: "remove"
                })
            }
            updating() {
                return !!(Od("audio", this) || Od("video", this))
            }
            audioTimestampOffset(t) {
                return typeof t < "u" && this.audioBuffer && this.audioTimestampOffset_ !== t && (ci({
                    type: "audio",
                    sourceUpdater: this,
                    action: di.timestampOffset(t),
                    name: "timestampOffset"
                }),
                    this.audioTimestampOffset_ = t),
                    this.audioTimestampOffset_
            }
            videoTimestampOffset(t) {
                return typeof t < "u" && this.videoBuffer && this.videoTimestampOffset !== t && (ci({
                    type: "video",
                    sourceUpdater: this,
                    action: di.timestampOffset(t),
                    name: "timestampOffset"
                }),
                    this.videoTimestampOffset_ = t),
                    this.videoTimestampOffset_
            }
            audioQueueCallback(t) {
                this.audioBuffer && ci({
                    type: "audio",
                    sourceUpdater: this,
                    action: di.callback(t),
                    name: "callback"
                })
            }
            videoQueueCallback(t) {
                this.videoBuffer && ci({
                    type: "video",
                    sourceUpdater: this,
                    action: di.callback(t),
                    name: "callback"
                })
            }
            dispose() {
                this.trigger("dispose"),
                    P1.forEach(t => {
                        this.abort(t),
                            this.canRemoveSourceBuffer() ? this.removeSourceBuffer(t) : this[`${t}QueueCallback`](() => zm(t, this))
                    }
                    ),
                    this.videoAppendQueued_ = !1,
                    this.delayedAudioAppendQueue_.length = 0,
                    this.sourceopenListener_ && this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_),
                    this.off()
            }
        }
        , Km = t => decodeURIComponent(escape(String.fromCharCode.apply(null, t))), O1 = t => {
            const e = new Uint8Array(t);
            return Array.from(e).map(s => s.toString(16).padStart(2, "0")).join("")
        }
        , Xm = new Uint8Array(`

`.split("").map(t => t.charCodeAt(0))), M1 = class extends Error {
            constructor() {
                super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.")
            }
        }
        , R1 = class extends Ld {
            constructor(t, e = {}) {
                super(t, e),
                    this.mediaSource_ = null,
                    this.subtitlesTrack_ = null,
                    this.loaderType_ = "subtitle",
                    this.featuresNativeTextTracks_ = t.featuresNativeTextTracks,
                    this.loadVttJs = t.loadVttJs,
                    this.shouldSaveSegmentTimingInfo_ = !1
            }
            createTransmuxer_() {
                return null
            }
            buffered_() {
                if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length)
                    return xt();
                const t = this.subtitlesTrack_.cues
                    , e = t[0].startTime
                    , s = t[t.length - 1].startTime;
                return xt([[e, s]])
            }
            initSegmentForMap(t, e = !1) {
                if (!t)
                    return null;
                const s = wl(t);
                let r = this.initSegments_[s];
                if (e && !r && t.bytes) {
                    const n = Xm.byteLength + t.bytes.byteLength
                        , a = new Uint8Array(n);
                    a.set(t.bytes),
                        a.set(Xm, t.bytes.byteLength),
                        this.initSegments_[s] = r = {
                            resolvedUri: t.resolvedUri,
                            byterange: t.byterange,
                            bytes: a
                        }
                }
                return r || t
            }
            couldBeginLoading_() {
                return this.playlist_ && this.subtitlesTrack_ && !this.paused()
            }
            init_() {
                return this.state = "READY",
                    this.resetEverything(),
                    this.monitorBuffer_()
            }
            track(t) {
                return typeof t > "u" ? this.subtitlesTrack_ : (this.subtitlesTrack_ = t,
                    this.state === "INIT" && this.couldBeginLoading_() && this.init_(),
                    this.subtitlesTrack_)
            }
            remove(t, e) {
                Ba(t, e, this.subtitlesTrack_)
            }
            fillBuffer_() {
                const t = this.chooseNextRequest_();
                if (t) {
                    if (this.syncController_.timestampOffsetForTimeline(t.timeline) === null) {
                        const e = () => {
                            this.state = "READY",
                                this.paused() || this.monitorBuffer_()
                        }
                            ;
                        this.syncController_.one("timestampoffset", e),
                            this.state = "WAITING_ON_TIMELINE";
                        return
                    }
                    this.loadSegment_(t)
                }
            }
            timestampOffsetForSegment_() {
                return null
            }
            chooseNextRequest_() {
                return this.skipEmptySegments_(super.chooseNextRequest_())
            }
            skipEmptySegments_(t) {
                for (; t && t.segment.empty;) {
                    if (t.mediaIndex + 1 >= t.playlist.segments.length) {
                        t = null;
                        break
                    }
                    t = this.generateSegmentInfo_({
                        playlist: t.playlist,
                        mediaIndex: t.mediaIndex + 1,
                        startOfSegment: t.startOfSegment + t.duration,
                        isSyncRequest: t.isSyncRequest
                    })
                }
                return t
            }
            stopForError(t) {
                this.error(t),
                    this.state = "READY",
                    this.pause(),
                    this.trigger("error")
            }
            segmentRequestFinished_(t, e, s) {
                if (!this.subtitlesTrack_) {
                    this.state = "READY";
                    return
                }
                if (this.saveTransferStats_(e.stats),
                    !this.pendingSegment_) {
                    this.state = "READY",
                        this.mediaRequestsAborted += 1;
                    return
                }
                if (t) {
                    t.code === rs.TIMEOUT && this.handleTimeout_(),
                        t.code === rs.ABORTED ? this.mediaRequestsAborted += 1 : this.mediaRequestsErrored += 1,
                        this.stopForError(t);
                    return
                }
                const r = this.pendingSegment_;
                this.saveBandwidthRelatedStats_(r.duration, e.stats),
                    e.key && this.segmentKey(e.key, !0),
                    this.state = "APPENDING",
                    this.trigger("appending");
                const n = r.segment;
                if (n.map && (n.map.bytes = e.map.bytes),
                    r.bytes = e.bytes,
                    typeof O.default.WebVTT != "function" && typeof this.loadVttJs == "function") {
                    this.state = "WAITING_ON_VTTJS",
                        this.loadVttJs().then(() => this.segmentRequestFinished_(t, e, s), () => this.stopForError({
                            message: "Error loading vtt.js"
                        }));
                    return
                }
                n.requested = !0;
                try {
                    this.parseVTTCues_(r)
                } catch (a) {
                    this.stopForError({
                        message: a.message
                    });
                    return
                }
                if (this.updateTimeMapping_(r, this.syncController_.timelines[r.timeline], this.playlist_),
                    r.cues.length ? r.timingInfo = {
                        start: r.cues[0].startTime,
                        end: r.cues[r.cues.length - 1].endTime
                    } : r.timingInfo = {
                        start: r.startOfSegment,
                        end: r.startOfSegment + r.duration
                    },
                    r.isSyncRequest) {
                    this.trigger("syncinfoupdate"),
                        this.pendingSegment_ = null,
                        this.state = "READY";
                    return
                }
                r.byteLength = r.bytes.byteLength,
                    this.mediaSecondsLoaded += n.duration,
                    r.cues.forEach(a => {
                        this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new O.default.VTTCue(a.startTime, a.endTime, a.text) : a)
                    }
                    ),
                    _1(this.subtitlesTrack_),
                    this.handleAppendsDone_()
            }
            handleData_() { }
            updateTimingInfoEnd_() { }
            parseVTTCues_(t) {
                let e, s = !1;
                if (typeof O.default.WebVTT != "function")
                    throw new M1;
                typeof O.default.TextDecoder == "function" ? e = new O.default.TextDecoder("utf8") : (e = O.default.WebVTT.StringDecoder(),
                    s = !0);
                const r = new O.default.WebVTT.Parser(O.default, O.default.vttjs, e);
                if (t.cues = [],
                    t.timestampmap = {
                        MPEGTS: 0,
                        LOCAL: 0
                    },
                    r.oncue = t.cues.push.bind(t.cues),
                    r.ontimestampmap = a => {
                        t.timestampmap = a
                    }
                    ,
                    r.onparsingerror = a => {
                        U.log.warn("Error encountered when parsing cues: " + a.message)
                    }
                    ,
                    t.segment.map) {
                    let a = t.segment.map.bytes;
                    s && (a = Km(a)),
                        r.parse(a)
                }
                let n = t.bytes;
                s && (n = Km(n)),
                    r.parse(n),
                    r.flush()
            }
            updateTimeMapping_(t, e, s) {
                const r = t.segment;
                if (!e)
                    return;
                if (!t.cues.length) {
                    r.empty = !0;
                    return
                }
                const n = t.timestampmap
                    , a = n.MPEGTS / Go.ONE_SECOND_IN_TS - n.LOCAL + e.mapping;
                if (t.cues.forEach(o => {
                    o.startTime += a,
                        o.endTime += a
                }
                ),
                    !s.syncInfo) {
                    const o = t.cues[0].startTime
                        , u = t.cues[t.cues.length - 1].startTime;
                    s.syncInfo = {
                        mediaSequence: s.mediaSequence + t.mediaIndex,
                        time: Math.min(o, u - r.duration)
                    }
                }
            }
        }
        , N1 = function (t, e) {
            const s = t.cues;
            for (let r = 0; r < s.length; r++) {
                const n = s[r];
                if (e >= n.adStartTime && e <= n.adEndTime)
                    return n
            }
            return null
        }, B1 = function (t, e, s = 0) {
            if (!t.segments)
                return;
            let r = s, n;
            for (let a = 0; a < t.segments.length; a++) {
                const o = t.segments[a];
                if (n || (n = N1(e, r + o.duration / 2)),
                    n) {
                    if ("cueIn" in o) {
                        n.endTime = r,
                            n.adEndTime = r,
                            r += o.duration,
                            n = null;
                        continue
                    }
                    if (r < n.endTime) {
                        r += o.duration;
                        continue
                    }
                    n.endTime += o.duration
                } else if ("cueOut" in o && (n = new O.default.VTTCue(r, r + o.duration, o.cueOut),
                    n.adStartTime = r,
                    n.adEndTime = r + parseFloat(o.cueOut),
                    e.addCue(n)),
                    "cueOutCont" in o) {
                    const [u, c] = o.cueOutCont.split("/").map(parseFloat);
                    n = new O.default.VTTCue(r, r + o.duration, ""),
                        n.adStartTime = r - u,
                        n.adEndTime = n.adStartTime + c,
                        e.addCue(n)
                }
                r += o.duration
            }
        }, F1 = 86400, Md = [{
            name: "VOD",
            run: (t, e, s, r, n) => s !== 1 / 0 ? {
                time: 0,
                segmentIndex: 0,
                partIndex: null
            } : null
        }, {
            name: "MediaSequence",
            run: (t, e, s, r, n, a) => {
                if (!a)
                    return null;
                const o = t.getMediaSequenceMap(a);
                if (!o || o.size === 0 || e.mediaSequence === void 0 || !Array.isArray(e.segments) || !e.segments.length)
                    return null;
                let u = e.mediaSequence
                    , c = 0;
                for (const f of e.segments) {
                    const v = o.get(u);
                    if (!v)
                        break;
                    if (n >= v.start && n < v.end) {
                        if (Array.isArray(f.parts) && f.parts.length) {
                            let T = v.start
                                , D = 0;
                            for (const _ of f.parts) {
                                const L = T
                                    , M = L + _.duration;
                                if (n >= L && n < M)
                                    return {
                                        time: v.start,
                                        segmentIndex: c,
                                        partIndex: D
                                    };
                                D++,
                                    T = M
                            }
                        }
                        return {
                            time: v.start,
                            segmentIndex: c,
                            partIndex: null
                        }
                    }
                    c++,
                        u++
                }
                return null
            }
        }, {
            name: "ProgramDateTime",
            run: (t, e, s, r, n) => {
                if (!Object.keys(t.timelineToDatetimeMappings).length)
                    return null;
                let a = null
                    , o = null;
                const u = yd(e);
                n = n || 0;
                for (let c = 0; c < u.length; c++) {
                    const f = e.endList || n === 0 ? c : u.length - (c + 1)
                        , v = u[f]
                        , T = v.segment
                        , D = t.timelineToDatetimeMappings[T.timeline];
                    if (!D || !T.dateTimeObject)
                        continue;
                    let L = T.dateTimeObject.getTime() / 1e3 + D;
                    if (T.parts && typeof v.partIndex == "number")
                        for (let N = 0; N < v.partIndex; N++)
                            L += T.parts[N].duration;
                    const M = Math.abs(n - L);
                    if (o !== null && (M === 0 || o < M))
                        break;
                    o = M,
                        a = {
                            time: L,
                            segmentIndex: v.segmentIndex,
                            partIndex: v.partIndex
                        }
                }
                return a
            }
        }, {
            name: "Segment",
            run: (t, e, s, r, n) => {
                let a = null
                    , o = null;
                n = n || 0;
                const u = yd(e);
                for (let c = 0; c < u.length; c++) {
                    const f = e.endList || n === 0 ? c : u.length - (c + 1)
                        , v = u[f]
                        , T = v.segment
                        , D = v.part && v.part.start || T && T.start;
                    if (T.timeline === r && typeof D < "u") {
                        const _ = Math.abs(n - D);
                        if (o !== null && o < _)
                            break;
                        (!a || o === null || o >= _) && (o = _,
                            a = {
                                time: D,
                                segmentIndex: v.segmentIndex,
                                partIndex: v.partIndex
                            })
                    }
                }
                return a
            }
        }, {
            name: "Discontinuity",
            run: (t, e, s, r, n) => {
                let a = null;
                if (n = n || 0,
                    e.discontinuityStarts && e.discontinuityStarts.length) {
                    let o = null;
                    for (let u = 0; u < e.discontinuityStarts.length; u++) {
                        const c = e.discontinuityStarts[u]
                            , f = e.discontinuitySequence + u + 1
                            , v = t.discontinuities[f];
                        if (v) {
                            const T = Math.abs(n - v.time);
                            if (o !== null && o < T)
                                break;
                            (!a || o === null || o >= T) && (o = T,
                                a = {
                                    time: v.time,
                                    segmentIndex: c,
                                    partIndex: null
                                })
                        }
                    }
                }
                return a
            }
        }, {
            name: "Playlist",
            run: (t, e, s, r, n) => e.syncInfo ? {
                time: e.syncInfo.time,
                segmentIndex: e.syncInfo.mediaSequence - e.mediaSequence,
                partIndex: null
            } : null
        }], U1 = class extends U.EventTarget {
            constructor(t = {}) {
                super(),
                    this.timelines = [],
                    this.discontinuities = [],
                    this.timelineToDatetimeMappings = {},
                    this.mediaSequenceStorage_ = new Map,
                    this.logger_ = Ci("SyncController")
            }
            getMediaSequenceMap(t) {
                return this.mediaSequenceStorage_.get(t)
            }
            updateMediaSequenceMap(t, e, s) {
                if (t.mediaSequence === void 0 || !Array.isArray(t.segments) || !t.segments.length)
                    return;
                const r = this.getMediaSequenceMap(s)
                    , n = new Map;
                let a = t.mediaSequence, o;
                r ? r.has(t.mediaSequence) ? o = r.get(t.mediaSequence).start : (this.logger_(`MediaSequence sync for ${s} segment loader - received a gap between playlists.
Fallback base time to: ${e}.
Received media sequence: ${a}.
Current map: `, r),
                    o = e) : o = 0,
                    this.logger_(`MediaSequence sync for ${s} segment loader.
Received media sequence: ${a}.
base time is ${o}
Current map: `, r),
                    t.segments.forEach(u => {
                        const c = o
                            , f = c + u.duration
                            , v = {
                                start: c,
                                end: f
                            };
                        n.set(a, v),
                            a++,
                            o = f
                    }
                    ),
                    this.mediaSequenceStorage_.set(s, n)
            }
            getSyncPoint(t, e, s, r, n) {
                if (e !== 1 / 0)
                    return Md.find(({ name: u }) => u === "VOD").run(this, t, e);
                const a = this.runStrategies_(t, e, s, r, n);
                if (!a.length)
                    return null;
                for (const o of a) {
                    const { syncPoint: u, strategy: c } = o
                        , { segmentIndex: f, time: v } = u;
                    if (f < 0)
                        continue;
                    const T = t.segments[f]
                        , D = v
                        , _ = D + T.duration;
                    if (this.logger_(`Strategy: ${c}. Current time: ${r}. selected segment: ${f}. Time: [${D} -> ${_}]}`),
                        r >= D && r < _)
                        return this.logger_("Found sync point with exact match: ", u),
                            u
                }
                return this.selectSyncPoint_(a, {
                    key: "time",
                    value: r
                })
            }
            getExpiredTime(t, e) {
                if (!t || !t.segments)
                    return null;
                const s = this.runStrategies_(t, e, t.discontinuitySequence, 0, "main");
                if (!s.length)
                    return null;
                const r = this.selectSyncPoint_(s, {
                    key: "segmentIndex",
                    value: 0
                });
                return r.segmentIndex > 0 && (r.time *= -1),
                    Math.abs(r.time + Oa({
                        defaultDuration: t.targetDuration,
                        durationList: t.segments,
                        startIndex: r.segmentIndex,
                        endIndex: 0
                    }))
            }
            runStrategies_(t, e, s, r, n) {
                const a = [];
                for (let o = 0; o < Md.length; o++) {
                    const u = Md[o]
                        , c = u.run(this, t, e, s, r, n);
                    c && (c.strategy = u.name,
                        a.push({
                            strategy: u.name,
                            syncPoint: c
                        }))
                }
                return a
            }
            selectSyncPoint_(t, e) {
                let s = t[0].syncPoint
                    , r = Math.abs(t[0].syncPoint[e.key] - e.value)
                    , n = t[0].strategy;
                for (let a = 1; a < t.length; a++) {
                    const o = Math.abs(t[a].syncPoint[e.key] - e.value);
                    o < r && (r = o,
                        s = t[a].syncPoint,
                        n = t[a].strategy)
                }
                return this.logger_(`syncPoint for [${e.key}: ${e.value}] chosen with strategy [${n}]: [time:${s.time}, segmentIndex:${s.segmentIndex}` + (typeof s.partIndex == "number" ? `,partIndex:${s.partIndex}` : "") + "]"),
                    s
            }
            saveExpiredSegmentInfo(t, e) {
                const s = e.mediaSequence - t.mediaSequence;
                if (s > F1) {
                    U.log.warn(`Not saving expired segment info. Media sequence gap ${s} is too large.`);
                    return
                }
                for (let r = s - 1; r >= 0; r--) {
                    const n = t.segments[r];
                    if (n && typeof n.start < "u") {
                        e.syncInfo = {
                            mediaSequence: t.mediaSequence + r,
                            time: n.start
                        },
                            this.logger_(`playlist refresh sync: [time:${e.syncInfo.time}, mediaSequence: ${e.syncInfo.mediaSequence}]`),
                            this.trigger("syncinfoupdate");
                        break
                    }
                }
            }
            setDateTimeMappingForStart(t) {
                if (this.timelineToDatetimeMappings = {},
                    t.segments && t.segments.length && t.segments[0].dateTimeObject) {
                    const e = t.segments[0]
                        , s = e.dateTimeObject.getTime() / 1e3;
                    this.timelineToDatetimeMappings[e.timeline] = -s
                }
            }
            saveSegmentTimingInfo({ segmentInfo: t, shouldSaveTimelineMapping: e }) {
                const s = this.calculateSegmentTimeMapping_(t, t.timingInfo, e)
                    , r = t.segment;
                s && (this.saveDiscontinuitySyncInfo_(t),
                    t.playlist.syncInfo || (t.playlist.syncInfo = {
                        mediaSequence: t.playlist.mediaSequence + t.mediaIndex,
                        time: r.start
                    }));
                const n = r.dateTimeObject;
                r.discontinuity && e && n && (this.timelineToDatetimeMappings[r.timeline] = -(n.getTime() / 1e3))
            }
            timestampOffsetForTimeline(t) {
                return typeof this.timelines[t] > "u" ? null : this.timelines[t].time
            }
            mappingForTimeline(t) {
                return typeof this.timelines[t] > "u" ? null : this.timelines[t].mapping
            }
            calculateSegmentTimeMapping_(t, e, s) {
                const r = t.segment
                    , n = t.part;
                let a = this.timelines[t.timeline], o, u;
                if (typeof t.timestampOffset == "number")
                    a = {
                        time: t.startOfSegment,
                        mapping: t.startOfSegment - e.start
                    },
                        s && (this.timelines[t.timeline] = a,
                            this.trigger("timestampoffset"),
                            this.logger_(`time mapping for timeline ${t.timeline}: [time: ${a.time}] [mapping: ${a.mapping}]`)),
                        o = t.startOfSegment,
                        u = e.end + a.mapping;
                else if (a)
                    o = e.start + a.mapping,
                        u = e.end + a.mapping;
                else
                    return !1;
                return n && (n.start = o,
                    n.end = u),
                    (!r.start || o < r.start) && (r.start = o),
                    r.end = u,
                    !0
            }
            saveDiscontinuitySyncInfo_(t) {
                const e = t.playlist
                    , s = t.segment;
                if (s.discontinuity)
                    this.discontinuities[s.timeline] = {
                        time: s.start,
                        accuracy: 0
                    };
                else if (e.discontinuityStarts && e.discontinuityStarts.length)
                    for (let r = 0; r < e.discontinuityStarts.length; r++) {
                        const n = e.discontinuityStarts[r]
                            , a = e.discontinuitySequence + r + 1
                            , o = n - t.mediaIndex
                            , u = Math.abs(o);
                        if (!this.discontinuities[a] || this.discontinuities[a].accuracy > u) {
                            let c;
                            o < 0 ? c = s.start - Oa({
                                defaultDuration: e.targetDuration,
                                durationList: e.segments,
                                startIndex: t.mediaIndex,
                                endIndex: n
                            }) : c = s.end + Oa({
                                defaultDuration: e.targetDuration,
                                durationList: e.segments,
                                startIndex: t.mediaIndex + 1,
                                endIndex: n
                            }),
                                this.discontinuities[a] = {
                                    time: c,
                                    accuracy: u
                                }
                        }
                    }
            }
            dispose() {
                this.trigger("dispose"),
                    this.off()
            }
        }
        , j1 = class extends U.EventTarget {
            constructor() {
                super(),
                    this.pendingTimelineChanges_ = {},
                    this.lastTimelineChanges_ = {}
            }
            clearPendingTimelineChange(t) {
                this.pendingTimelineChanges_[t] = null,
                    this.trigger("pendingtimelinechange")
            }
            pendingTimelineChange({ type: t, from: e, to: s }) {
                return typeof e == "number" && typeof s == "number" && (this.pendingTimelineChanges_[t] = {
                    type: t,
                    from: e,
                    to: s
                },
                    this.trigger("pendingtimelinechange")),
                    this.pendingTimelineChanges_[t]
            }
            lastTimelineChange({ type: t, from: e, to: s }) {
                return typeof e == "number" && typeof s == "number" && (this.lastTimelineChanges_[t] = {
                    type: t,
                    from: e,
                    to: s
                },
                    delete this.pendingTimelineChanges_[t],
                    this.trigger("timelinechange")),
                    this.lastTimelineChanges_[t]
            }
            dispose() {
                this.trigger("dispose"),
                    this.pendingTimelineChanges_ = {},
                    this.lastTimelineChanges_ = {},
                    this.off()
            }
        }
        , H1 = Em(Sm(function () {
            var t = function () {
                function M() {
                    this.listeners = {}
                }
                var N = M.prototype;
                return N.on = function (B, z) {
                    this.listeners[B] || (this.listeners[B] = []),
                        this.listeners[B].push(z)
                }
                    ,
                    N.off = function (B, z) {
                        if (!this.listeners[B])
                            return !1;
                        var R = this.listeners[B].indexOf(z);
                        return this.listeners[B] = this.listeners[B].slice(0),
                            this.listeners[B].splice(R, 1),
                            R > -1
                    }
                    ,
                    N.trigger = function (B) {
                        var z = this.listeners[B];
                        if (z)
                            if (arguments.length === 2)
                                for (var R = z.length, F = 0; F < R; ++F)
                                    z[F].call(this, arguments[1]);
                            else
                                for (var Y = Array.prototype.slice.call(arguments, 1), ue = z.length, de = 0; de < ue; ++de)
                                    z[de].apply(this, Y)
                    }
                    ,
                    N.dispose = function () {
                        this.listeners = {}
                    }
                    ,
                    N.pipe = function (B) {
                        this.on("data", function (z) {
                            B.push(z)
                        })
                    }
                    ,
                    M
            }();
            function e(M) {
                return M.subarray(0, M.byteLength - M[M.byteLength - 1])
            }
            const s = function () {
                const M = [[[], [], [], [], []], [[], [], [], [], []]]
                    , N = M[0]
                    , x = M[1]
                    , B = N[4]
                    , z = x[4];
                let R, F, Y;
                const ue = []
                    , de = [];
                let ee, G, A, w, H, X;
                for (R = 0; R < 256; R++)
                    de[(ue[R] = R << 1 ^ (R >> 7) * 283) ^ R] = R;
                for (F = Y = 0; !B[F]; F ^= ee || 1,
                    Y = de[Y] || 1)
                    for (w = Y ^ Y << 1 ^ Y << 2 ^ Y << 3 ^ Y << 4,
                        w = w >> 8 ^ w & 255 ^ 99,
                        B[F] = w,
                        z[w] = F,
                        A = ue[G = ue[ee = ue[F]]],
                        X = A * 16843009 ^ G * 65537 ^ ee * 257 ^ F * 16843008,
                        H = ue[w] * 257 ^ w * 16843008,
                        R = 0; R < 4; R++)
                        N[R][F] = H = H << 24 ^ H >>> 8,
                            x[R][w] = X = X << 24 ^ X >>> 8;
                for (R = 0; R < 5; R++)
                    N[R] = N[R].slice(0),
                        x[R] = x[R].slice(0);
                return M
            };
            let r = null;
            class n {
                constructor(N) {
                    r || (r = s()),
                        this._tables = [[r[0][0].slice(), r[0][1].slice(), r[0][2].slice(), r[0][3].slice(), r[0][4].slice()], [r[1][0].slice(), r[1][1].slice(), r[1][2].slice(), r[1][3].slice(), r[1][4].slice()]];
                    let x, B, z;
                    const R = this._tables[0][4]
                        , F = this._tables[1]
                        , Y = N.length;
                    let ue = 1;
                    if (Y !== 4 && Y !== 6 && Y !== 8)
                        throw new Error("Invalid aes key size");
                    const de = N.slice(0)
                        , ee = [];
                    for (this._key = [de, ee],
                        x = Y; x < 4 * Y + 28; x++)
                        z = de[x - 1],
                            (x % Y === 0 || Y === 8 && x % Y === 4) && (z = R[z >>> 24] << 24 ^ R[z >> 16 & 255] << 16 ^ R[z >> 8 & 255] << 8 ^ R[z & 255],
                                x % Y === 0 && (z = z << 8 ^ z >>> 24 ^ ue << 24,
                                    ue = ue << 1 ^ (ue >> 7) * 283)),
                            de[x] = de[x - Y] ^ z;
                    for (B = 0; x; B++,
                        x--)
                        z = de[B & 3 ? x : x - 4],
                            x <= 4 || B < 4 ? ee[B] = z : ee[B] = F[0][R[z >>> 24]] ^ F[1][R[z >> 16 & 255]] ^ F[2][R[z >> 8 & 255]] ^ F[3][R[z & 255]]
                }
                decrypt(N, x, B, z, R, F) {
                    const Y = this._key[1];
                    let ue = N ^ Y[0], de = z ^ Y[1], ee = B ^ Y[2], G = x ^ Y[3], A, w, H;
                    const X = Y.length / 4 - 2;
                    let Z, re = 4;
                    const he = this._tables[1]
                        , oe = he[0]
                        , ie = he[1]
                        , ae = he[2]
                        , ce = he[3]
                        , se = he[4];
                    for (Z = 0; Z < X; Z++)
                        A = oe[ue >>> 24] ^ ie[de >> 16 & 255] ^ ae[ee >> 8 & 255] ^ ce[G & 255] ^ Y[re],
                            w = oe[de >>> 24] ^ ie[ee >> 16 & 255] ^ ae[G >> 8 & 255] ^ ce[ue & 255] ^ Y[re + 1],
                            H = oe[ee >>> 24] ^ ie[G >> 16 & 255] ^ ae[ue >> 8 & 255] ^ ce[de & 255] ^ Y[re + 2],
                            G = oe[G >>> 24] ^ ie[ue >> 16 & 255] ^ ae[de >> 8 & 255] ^ ce[ee & 255] ^ Y[re + 3],
                            re += 4,
                            ue = A,
                            de = w,
                            ee = H;
                    for (Z = 0; Z < 4; Z++)
                        R[(3 & -Z) + F] = se[ue >>> 24] << 24 ^ se[de >> 16 & 255] << 16 ^ se[ee >> 8 & 255] << 8 ^ se[G & 255] ^ Y[re++],
                            A = ue,
                            ue = de,
                            de = ee,
                            ee = G,
                            G = A
                }
            }
            class a extends t {
                constructor() {
                    super(t),
                        this.jobs = [],
                        this.delay = 1,
                        this.timeout_ = null
                }
                processJob_() {
                    this.jobs.shift()(),
                        this.jobs.length ? this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay) : this.timeout_ = null
                }
                push(N) {
                    this.jobs.push(N),
                        this.timeout_ || (this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay))
                }
            }
            const o = function (M) {
                return M << 24 | (M & 65280) << 8 | (M & 16711680) >> 8 | M >>> 24
            }
                , u = function (M, N, x) {
                    const B = new Int32Array(M.buffer, M.byteOffset, M.byteLength >> 2)
                        , z = new n(Array.prototype.slice.call(N))
                        , R = new Uint8Array(M.byteLength)
                        , F = new Int32Array(R.buffer);
                    let Y, ue, de, ee, G, A, w, H, X;
                    for (Y = x[0],
                        ue = x[1],
                        de = x[2],
                        ee = x[3],
                        X = 0; X < B.length; X += 4)
                        G = o(B[X]),
                            A = o(B[X + 1]),
                            w = o(B[X + 2]),
                            H = o(B[X + 3]),
                            z.decrypt(G, A, w, H, F, X),
                            F[X] = o(F[X] ^ Y),
                            F[X + 1] = o(F[X + 1] ^ ue),
                            F[X + 2] = o(F[X + 2] ^ de),
                            F[X + 3] = o(F[X + 3] ^ ee),
                            Y = G,
                            ue = A,
                            de = w,
                            ee = H;
                    return R
                };
            class c {
                constructor(N, x, B, z) {
                    const R = c.STEP
                        , F = new Int32Array(N.buffer)
                        , Y = new Uint8Array(N.byteLength);
                    let ue = 0;
                    for (this.asyncStream_ = new a,
                        this.asyncStream_.push(this.decryptChunk_(F.subarray(ue, ue + R), x, B, Y)),
                        ue = R; ue < F.length; ue += R)
                        B = new Uint32Array([o(F[ue - 4]), o(F[ue - 3]), o(F[ue - 2]), o(F[ue - 1])]),
                            this.asyncStream_.push(this.decryptChunk_(F.subarray(ue, ue + R), x, B, Y));
                    this.asyncStream_.push(function () {
                        z(null, e(Y))
                    })
                }
                static get STEP() {
                    return 32e3
                }
                decryptChunk_(N, x, B, z) {
                    return function () {
                        const R = u(N, x, B);
                        z.set(R, N.byteOffset)
                    }
                }
            }
            var f = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, v;
            typeof window < "u" ? v = window : typeof f < "u" ? v = f : typeof self < "u" ? v = self : v = {};
            var T = v
                , D = function (N) {
                    return ArrayBuffer.isView === "function" ? ArrayBuffer.isView(N) : N && N.buffer instanceof ArrayBuffer
                }
                , _ = T.BigInt || Number;
            _("0x1"),
                _("0x100"),
                _("0x10000"),
                _("0x1000000"),
                _("0x100000000"),
                _("0x10000000000"),
                _("0x1000000000000"),
                _("0x100000000000000"),
                _("0x10000000000000000"),
                function () {
                    var M = new Uint16Array([65484])
                        , N = new Uint8Array(M.buffer, M.byteOffset, M.byteLength);
                    return N[0] === 255 ? "big" : N[0] === 204 ? "little" : "unknown"
                }();
            const L = function (M) {
                const N = {};
                return Object.keys(M).forEach(x => {
                    const B = M[x];
                    D(B) ? N[x] = {
                        bytes: B.buffer,
                        byteOffset: B.byteOffset,
                        byteLength: B.byteLength
                    } : N[x] = B
                }
                ),
                    N
            };
            self.onmessage = function (M) {
                const N = M.data
                    , x = new Uint8Array(N.encrypted.bytes, N.encrypted.byteOffset, N.encrypted.byteLength)
                    , B = new Uint32Array(N.key.bytes, N.key.byteOffset, N.key.byteLength / 4)
                    , z = new Uint32Array(N.iv.bytes, N.iv.byteOffset, N.iv.byteLength / 4);
                new c(x, B, z, function (R, F) {
                    self.postMessage(L({
                        source: N.source,
                        decrypted: F
                    }), [F.buffer])
                }
                )
            }
        })), q1 = bm(H1), $1 = t => {
            let e = t.default ? "main" : "alternative";
            return t.characteristics && t.characteristics.indexOf("public.accessibility.describes-video") >= 0 && (e = "main-desc"),
                e
        }
        , Ym = (t, e) => {
            t.abort(),
                t.pause(),
                e && e.activePlaylistLoader && (e.activePlaylistLoader.pause(),
                    e.activePlaylistLoader = null)
        }
        , Rd = (t, e) => {
            e.activePlaylistLoader = t,
                t.load()
        }
        , V1 = (t, e) => () => {
            const { segmentLoaders: { [t]: s, main: r }, mediaTypes: { [t]: n } } = e
                , a = n.activeTrack()
                , o = n.getActiveGroup()
                , u = n.activePlaylistLoader
                , c = n.lastGroup_;
            if (!(o && c && o.id === c.id) && (n.lastGroup_ = o,
                n.lastTrack_ = a,
                Ym(s, n),
                !(!o || o.isMainPlaylist))) {
                if (!o.playlistLoader) {
                    u && r.resetEverything();
                    return
                }
                s.resyncLoader(),
                    Rd(o.playlistLoader, n)
            }
        }
        , z1 = (t, e) => () => {
            const { segmentLoaders: { [t]: s }, mediaTypes: { [t]: r } } = e;
            r.lastGroup_ = null,
                s.abort(),
                s.pause()
        }
        , G1 = (t, e) => () => {
            const { mainPlaylistLoader: s, segmentLoaders: { [t]: r, main: n }, mediaTypes: { [t]: a } } = e
                , o = a.activeTrack()
                , u = a.getActiveGroup()
                , c = a.activePlaylistLoader
                , f = a.lastTrack_;
            if (!(f && o && f.id === o.id) && (a.lastGroup_ = u,
                a.lastTrack_ = o,
                Ym(r, a),
                !!u)) {
                if (u.isMainPlaylist) {
                    if (!o || !f || o.id === f.id)
                        return;
                    const v = e.vhs.playlistController_
                        , T = v.selectPlaylist();
                    if (v.media() === T)
                        return;
                    a.logger_(`track change. Switching main audio from ${f.id} to ${o.id}`),
                        s.pause(),
                        n.resetEverything(),
                        v.fastQualityChange_(T);
                    return
                }
                if (t === "AUDIO") {
                    if (!u.playlistLoader) {
                        n.setAudio(!0),
                            n.resetEverything();
                        return
                    }
                    r.setAudio(!0),
                        n.setAudio(!1)
                }
                if (c === u.playlistLoader) {
                    Rd(u.playlistLoader, a);
                    return
                }
                r.track && r.track(o),
                    r.resetEverything(),
                    Rd(u.playlistLoader, a)
            }
        }
        , Pl = {
            AUDIO: (t, e) => () => {
                const { mediaTypes: { [t]: s }, excludePlaylist: r } = e
                    , n = s.activeTrack()
                    , a = s.activeGroup()
                    , o = (a.filter(c => c.default)[0] || a[0]).id
                    , u = s.tracks[o];
                if (n === u) {
                    r({
                        error: {
                            message: "Problem encountered loading the default audio track."
                        }
                    });
                    return
                }
                U.log.warn("Problem encountered loading the alternate audio track.Switching back to default.");
                for (const c in s.tracks)
                    s.tracks[c].enabled = s.tracks[c] === u;
                s.onTrackChanged()
            }
            ,
            SUBTITLES: (t, e) => () => {
                const { mediaTypes: { [t]: s } } = e;
                U.log.warn("Problem encountered loading the subtitle track.Disabling subtitle track.");
                const r = s.activeTrack();
                r && (r.mode = "disabled"),
                    s.onTrackChanged()
            }
        }, Qm = {
            AUDIO: (t, e, s) => {
                if (!e)
                    return;
                const { tech: r, requestOptions: n, segmentLoaders: { [t]: a } } = s;
                e.on("loadedmetadata", () => {
                    const o = e.media();
                    a.playlist(o, n),
                        (!r.paused() || o.endList && r.preload() !== "none") && a.load()
                }
                ),
                    e.on("loadedplaylist", () => {
                        a.playlist(e.media(), n),
                            r.paused() || a.load()
                    }
                    ),
                    e.on("error", Pl[t](t, s))
            }
            ,
            SUBTITLES: (t, e, s) => {
                const { tech: r, requestOptions: n, segmentLoaders: { [t]: a }, mediaTypes: { [t]: o } } = s;
                e.on("loadedmetadata", () => {
                    const u = e.media();
                    a.playlist(u, n),
                        a.track(o.activeTrack()),
                        (!r.paused() || u.endList && r.preload() !== "none") && a.load()
                }
                ),
                    e.on("loadedplaylist", () => {
                        a.playlist(e.media(), n),
                            r.paused() || a.load()
                    }
                    ),
                    e.on("error", Pl[t](t, s))
            }
        }, W1 = {
            AUDIO: (t, e) => {
                const { vhs: s, sourceType: r, segmentLoaders: { [t]: n }, requestOptions: a, main: { mediaGroups: o }, mediaTypes: { [t]: { groups: u, tracks: c, logger_: f } }, mainPlaylistLoader: v } = e
                    , T = Ma(v.main);
                (!o[t] || Object.keys(o[t]).length === 0) && (o[t] = {
                    main: {
                        default: {
                            default: !0
                        }
                    }
                },
                    T && (o[t].main.default.playlists = v.main.playlists));
                for (const D in o[t]) {
                    u[D] || (u[D] = []);
                    for (const _ in o[t][D]) {
                        let L = o[t][D][_], M;
                        if (T ? (f(`AUDIO group '${D}' label '${_}' is a main playlist`),
                            L.isMainPlaylist = !0,
                            M = null) : r === "vhs-json" && L.playlists ? M = new An(L.playlists[0], s, a) : L.resolvedUri ? M = new An(L.resolvedUri, s, a) : L.playlists && r === "dash" ? M = new Dd(L.playlists[0], s, a, v) : M = null,
                            L = Re({
                                id: _,
                                playlistLoader: M
                            }, L),
                            Qm[t](t, L.playlistLoader, e),
                            u[D].push(L),
                            typeof c[_] > "u") {
                            const N = new U.AudioTrack({
                                id: _,
                                kind: $1(L),
                                enabled: !1,
                                language: L.language,
                                default: L.default,
                                label: _
                            });
                            c[_] = N
                        }
                    }
                }
                n.on("error", Pl[t](t, e))
            }
            ,
            SUBTITLES: (t, e) => {
                const { tech: s, vhs: r, sourceType: n, segmentLoaders: { [t]: a }, requestOptions: o, main: { mediaGroups: u }, mediaTypes: { [t]: { groups: c, tracks: f } }, mainPlaylistLoader: v } = e;
                for (const T in u[t]) {
                    c[T] || (c[T] = []);
                    for (const D in u[t][T]) {
                        if (!r.options_.useForcedSubtitles && u[t][T][D].forced)
                            continue;
                        let _ = u[t][T][D], L;
                        if (n === "hls")
                            L = new An(_.resolvedUri, r, o);
                        else if (n === "dash") {
                            if (!_.playlists.filter(N => N.excludeUntil !== 1 / 0).length)
                                return;
                            L = new Dd(_.playlists[0], r, o, v)
                        } else
                            n === "vhs-json" && (L = new An(_.playlists ? _.playlists[0] : _.resolvedUri, r, o));
                        if (_ = Re({
                            id: D,
                            playlistLoader: L
                        }, _),
                            Qm[t](t, _.playlistLoader, e),
                            c[T].push(_),
                            typeof f[D] > "u") {
                            const M = s.addRemoteTextTrack({
                                id: D,
                                kind: "subtitles",
                                default: _.default && _.autoselect,
                                language: _.language,
                                label: D
                            }, !1).track;
                            f[D] = M
                        }
                    }
                }
                a.on("error", Pl[t](t, e))
            }
            ,
            "CLOSED-CAPTIONS": (t, e) => {
                const { tech: s, main: { mediaGroups: r }, mediaTypes: { [t]: { groups: n, tracks: a } } } = e;
                for (const o in r[t]) {
                    n[o] || (n[o] = []);
                    for (const u in r[t][o]) {
                        const c = r[t][o][u];
                        if (!/^(?:CC|SERVICE)/.test(c.instreamId))
                            continue;
                        const f = s.options_.vhs && s.options_.vhs.captionServices || {};
                        let v = {
                            label: u,
                            language: c.language,
                            instreamId: c.instreamId,
                            default: c.default && c.autoselect
                        };
                        if (f[v.instreamId] && (v = Re(v, f[v.instreamId])),
                            v.default === void 0 && delete v.default,
                            n[o].push(Re({
                                id: u
                            }, c)),
                            typeof a[u] > "u") {
                            const T = s.addRemoteTextTrack({
                                id: v.instreamId,
                                kind: "captions",
                                default: v.default,
                                language: v.language,
                                label: v.label
                            }, !1).track;
                            a[u] = T
                        }
                    }
                }
            }
        }, Jm = (t, e) => {
            for (let s = 0; s < t.length; s++)
                if (bd(e, t[s]) || t[s].playlists && Jm(t[s].playlists, e))
                    return !0;
            return !1
        }
        , K1 = (t, e) => s => {
            const { mainPlaylistLoader: r, mediaTypes: { [t]: { groups: n } } } = e
                , a = r.media();
            if (!a)
                return null;
            let o = null;
            a.attributes[t] && (o = n[a.attributes[t]]);
            const u = Object.keys(n);
            if (!o)
                if (t === "AUDIO" && u.length > 1 && Ma(e.main))
                    for (let c = 0; c < u.length; c++) {
                        const f = n[u[c]];
                        if (Jm(f, a)) {
                            o = f;
                            break
                        }
                    }
                else
                    n.main ? o = n.main : u.length === 1 && (o = n[u[0]]);
            return typeof s > "u" ? o : s === null || !o ? null : o.filter(c => c.id === s.id)[0] || null
        }
        , X1 = {
            AUDIO: (t, e) => () => {
                const { mediaTypes: { [t]: { tracks: s } } } = e;
                for (const r in s)
                    if (s[r].enabled)
                        return s[r];
                return null
            }
            ,
            SUBTITLES: (t, e) => () => {
                const { mediaTypes: { [t]: { tracks: s } } } = e;
                for (const r in s)
                    if (s[r].mode === "showing" || s[r].mode === "hidden")
                        return s[r];
                return null
            }
        }, Y1 = (t, { mediaTypes: e }) => () => {
            const s = e[t].activeTrack();
            return s ? e[t].activeGroup(s) : null
        }
        , Q1 = t => {
            ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(f => {
                W1[f](f, t)
            }
            );
            const { mediaTypes: e, mainPlaylistLoader: s, tech: r, vhs: n, segmentLoaders: { ["AUDIO"]: a, main: o } } = t;
            ["AUDIO", "SUBTITLES"].forEach(f => {
                e[f].activeGroup = K1(f, t),
                    e[f].activeTrack = X1[f](f, t),
                    e[f].onGroupChanged = V1(f, t),
                    e[f].onGroupChanging = z1(f, t),
                    e[f].onTrackChanged = G1(f, t),
                    e[f].getActiveGroup = Y1(f, t)
            }
            );
            const u = e.AUDIO.activeGroup();
            if (u) {
                const f = (u.filter(T => T.default)[0] || u[0]).id;
                e.AUDIO.tracks[f].enabled = !0,
                    e.AUDIO.onGroupChanged(),
                    e.AUDIO.onTrackChanged(),
                    e.AUDIO.getActiveGroup().playlistLoader ? (o.setAudio(!1),
                        a.setAudio(!0)) : o.setAudio(!0)
            }
            s.on("mediachange", () => {
                ["AUDIO", "SUBTITLES"].forEach(f => e[f].onGroupChanged())
            }
            ),
                s.on("mediachanging", () => {
                    ["AUDIO", "SUBTITLES"].forEach(f => e[f].onGroupChanging())
                }
                );
            const c = () => {
                e.AUDIO.onTrackChanged(),
                    r.trigger({
                        type: "usage",
                        name: "vhs-audio-change"
                    })
            }
                ;
            r.audioTracks().addEventListener("change", c),
                r.remoteTextTracks().addEventListener("change", e.SUBTITLES.onTrackChanged),
                n.on("dispose", () => {
                    r.audioTracks().removeEventListener("change", c),
                        r.remoteTextTracks().removeEventListener("change", e.SUBTITLES.onTrackChanged)
                }
                ),
                r.clearTracks("audio");
            for (const f in e.AUDIO.tracks)
                r.audioTracks().addTrack(e.AUDIO.tracks[f])
        }
        , J1 = () => {
            const t = {};
            return ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(e => {
                t[e] = {
                    groups: {},
                    tracks: {},
                    activePlaylistLoader: null,
                    activeGroup: bs,
                    activeTrack: bs,
                    getActiveGroup: bs,
                    onGroupChanged: bs,
                    onTrackChanged: bs,
                    lastTrack_: null,
                    logger_: Ci(`MediaGroups[${e}]`)
                }
            }
            ),
                t
        }
        , Zm = class {
            constructor() {
                this.priority_ = [],
                    this.pathwayClones_ = new Map
            }
            set version(t) {
                t === 1 && (this.version_ = t)
            }
            set ttl(t) {
                this.ttl_ = t || 300
            }
            set reloadUri(t) {
                t && (this.reloadUri_ = ii(this.reloadUri_, t))
            }
            set priority(t) {
                t && t.length && (this.priority_ = t)
            }
            set pathwayClones(t) {
                t && t.length && (this.pathwayClones_ = new Map(t.map(e => [e.ID, e])))
            }
            get version() {
                return this.version_
            }
            get ttl() {
                return this.ttl_
            }
            get reloadUri() {
                return this.reloadUri_
            }
            get priority() {
                return this.priority_
            }
            get pathwayClones() {
                return this.pathwayClones_
            }
        }
        , Z1 = class extends U.EventTarget {
            constructor(t, e) {
                super(),
                    this.currentPathway = null,
                    this.defaultPathway = null,
                    this.queryBeforeStart = !1,
                    this.availablePathways_ = new Set,
                    this.steeringManifest = new Zm,
                    this.proxyServerUrl_ = null,
                    this.manifestType_ = null,
                    this.ttlTimeout_ = null,
                    this.request_ = null,
                    this.currentPathwayClones = new Map,
                    this.nextPathwayClones = new Map,
                    this.excludedSteeringManifestURLs = new Set,
                    this.logger_ = Ci("Content Steering"),
                    this.xhr_ = t,
                    this.getBandwidth_ = e
            }
            assignTagProperties(t, e) {
                this.manifestType_ = e.serverUri ? "HLS" : "DASH";
                const s = e.serverUri || e.serverURL;
                if (!s) {
                    this.logger_(`steering manifest URL is ${s}, cannot request steering manifest.`),
                        this.trigger("error");
                    return
                }
                if (s.startsWith("data:")) {
                    this.decodeDataUriManifest_(s.substring(s.indexOf(",") + 1));
                    return
                }
                this.steeringManifest.reloadUri = ii(t, s),
                    this.defaultPathway = e.pathwayId || e.defaultServiceLocation,
                    this.queryBeforeStart = e.queryBeforeStart,
                    this.proxyServerUrl_ = e.proxyServerURL,
                    this.defaultPathway && !this.queryBeforeStart && this.trigger("content-steering")
            }
            requestSteeringManifest(t) {
                const e = this.steeringManifest.reloadUri;
                if (!e)
                    return;
                const s = t ? e : this.getRequestURI(e);
                if (!s) {
                    this.logger_("No valid content steering manifest URIs. Stopping content steering."),
                        this.trigger("error"),
                        this.dispose();
                    return
                }
                this.request_ = this.xhr_({
                    uri: s
                }, (r, n) => {
                    if (r) {
                        if (n.status === 410) {
                            this.logger_(`manifest request 410 ${r}.`),
                                this.logger_(`There will be no more content steering requests to ${s} this session.`),
                                this.excludedSteeringManifestURLs.add(s);
                            return
                        }
                        if (n.status === 429) {
                            const o = n.responseHeaders["retry-after"];
                            this.logger_(`manifest request 429 ${r}.`),
                                this.logger_(`content steering will retry in ${o} seconds.`),
                                this.startTTLTimeout_(parseInt(o, 10));
                            return
                        }
                        this.logger_(`manifest failed to load ${r}.`),
                            this.startTTLTimeout_();
                        return
                    }
                    const a = JSON.parse(this.request_.responseText);
                    this.assignSteeringProperties_(a),
                        this.startTTLTimeout_()
                }
                )
            }
            setProxyServerUrl_(t) {
                const e = new O.default.URL(t)
                    , s = new O.default.URL(this.proxyServerUrl_);
                return s.searchParams.set("url", encodeURI(e.toString())),
                    this.setSteeringParams_(s.toString())
            }
            decodeDataUriManifest_(t) {
                const e = JSON.parse(O.default.atob(t));
                this.assignSteeringProperties_(e)
            }
            setSteeringParams_(t) {
                const e = new O.default.URL(t)
                    , s = this.getPathway()
                    , r = this.getBandwidth_();
                if (s) {
                    const n = `_${this.manifestType_}_pathway`;
                    e.searchParams.set(n, s)
                }
                if (r) {
                    const n = `_${this.manifestType_}_throughput`;
                    e.searchParams.set(n, r)
                }
                return e.toString()
            }
            assignSteeringProperties_(t) {
                if (this.steeringManifest.version = t.VERSION,
                    !this.steeringManifest.version) {
                    this.logger_(`manifest version is ${t.VERSION}, which is not supported.`),
                        this.trigger("error");
                    return
                }
                this.steeringManifest.ttl = t.TTL,
                    this.steeringManifest.reloadUri = t["RELOAD-URI"],
                    this.steeringManifest.priority = t["PATHWAY-PRIORITY"] || t["SERVICE-LOCATION-PRIORITY"],
                    this.steeringManifest.pathwayClones = t["PATHWAY-CLONES"],
                    this.nextPathwayClones = this.steeringManifest.pathwayClones,
                    this.availablePathways_.size || (this.logger_("There are no available pathways for content steering. Ending content steering."),
                        this.trigger("error"),
                        this.dispose());
                const s = (r => {
                    for (const n of r)
                        if (this.availablePathways_.has(n))
                            return n;
                    return [...this.availablePathways_][0]
                }
                )(this.steeringManifest.priority);
                this.currentPathway !== s && (this.currentPathway = s,
                    this.trigger("content-steering"))
            }
            getPathway() {
                return this.currentPathway || this.defaultPathway
            }
            getRequestURI(t) {
                if (!t)
                    return null;
                const e = r => this.excludedSteeringManifestURLs.has(r);
                if (this.proxyServerUrl_) {
                    const r = this.setProxyServerUrl_(t);
                    if (!e(r))
                        return r
                }
                const s = this.setSteeringParams_(t);
                return e(s) ? null : s
            }
            startTTLTimeout_(t = this.steeringManifest.ttl) {
                const e = t * 1e3;
                this.ttlTimeout_ = O.default.setTimeout(() => {
                    this.requestSteeringManifest()
                }
                    , e)
            }
            clearTTLTimeout_() {
                O.default.clearTimeout(this.ttlTimeout_),
                    this.ttlTimeout_ = null
            }
            abort() {
                this.request_ && this.request_.abort(),
                    this.request_ = null
            }
            dispose() {
                this.off("content-steering"),
                    this.off("error"),
                    this.abort(),
                    this.clearTTLTimeout_(),
                    this.currentPathway = null,
                    this.defaultPathway = null,
                    this.queryBeforeStart = null,
                    this.proxyServerUrl_ = null,
                    this.manifestType_ = null,
                    this.ttlTimeout_ = null,
                    this.request_ = null,
                    this.excludedSteeringManifestURLs = new Set,
                    this.availablePathways_ = new Set,
                    this.steeringManifest = new Zm
            }
            addAvailablePathway(t) {
                t && this.availablePathways_.add(t)
            }
            clearAvailablePathways() {
                this.availablePathways_.clear()
            }
            excludePathway(t) {
                return this.availablePathways_.delete(t)
            }
            didDASHTagChange(t, e) {
                return !e && this.steeringManifest.reloadUri || e && (ii(t, e.serverURL) !== this.steeringManifest.reloadUri || e.defaultServiceLocation !== this.defaultPathway || e.queryBeforeStart !== this.queryBeforeStart || e.proxyServerURL !== this.proxyServerUrl_)
            }
            getAvailablePathways() {
                return this.availablePathways_
            }
        }
        , eb = 10, Es, tb = ["mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends"], ib = function (t) {
            return this.audioSegmentLoader_[t] + this.mainSegmentLoader_[t]
        }, sb = function ({ currentPlaylist: t, buffered: e, currentTime: s, nextPlaylist: r, bufferLowWaterLine: n, bufferHighWaterLine: a, duration: o, bufferBasedABR: u, log: c }) {
            if (!r)
                return U.log.warn("We received no playlist to switch to. Please check your stream."),
                    !1;
            const f = `allowing switch ${t && t.id || "null"} -> ${r.id}`;
            if (!t)
                return c(`${f} as current playlist is not set`),
                    !0;
            if (r.id === t.id)
                return !1;
            const v = !!En(e, s).length;
            if (!t.endList)
                return !v && typeof t.partTargetDuration == "number" ? (c(`not ${f} as current playlist is live llhls, but currentTime isn't in buffered.`),
                    !1) : (c(`${f} as current playlist is live`),
                        !0);
            const T = gd(e, s)
                , D = u ? mt.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : mt.MAX_BUFFER_LOW_WATER_LINE;
            if (o < D)
                return c(`${f} as duration < max low water line (${o} < ${D})`),
                    !0;
            const _ = r.attributes.BANDWIDTH
                , L = t.attributes.BANDWIDTH;
            if (_ < L && (!u || T < a)) {
                let M = `${f} as next bandwidth < current bandwidth (${_} < ${L})`;
                return u && (M += ` and forwardBuffer < bufferHighWaterLine (${T} < ${a})`),
                    c(M),
                    !0
            }
            if ((!u || _ > L) && T >= n) {
                let M = `${f} as forwardBuffer >= bufferLowWaterLine (${T} >= ${n})`;
                return u && (M += ` and next bandwidth > current bandwidth (${_} > ${L})`),
                    c(M),
                    !0
            }
            return c(`not ${f} as no switching criteria met`),
                !1
        }, rb = class extends U.EventTarget {
            constructor(t) {
                super();
                const { src: e, withCredentials: s, tech: r, bandwidth: n, externVhs: a, useCueTags: o, playlistExclusionDuration: u, enableLowInitialPlaylist: c, sourceType: f, cacheEncryptionKeys: v, bufferBasedABR: T, leastPixelDiffSelector: D, captionServices: _ } = t;
                if (!e)
                    throw new Error("A non-empty playlist URL or JSON manifest string is required");
                let { maxPlaylistRetries: L } = t;
                (L === null || typeof L > "u") && (L = 1 / 0),
                    Es = a,
                    this.bufferBasedABR = !!T,
                    this.leastPixelDiffSelector = !!D,
                    this.withCredentials = s,
                    this.tech_ = r,
                    this.vhs_ = r.vhs,
                    this.sourceType_ = f,
                    this.useCueTags_ = o,
                    this.playlistExclusionDuration = u,
                    this.maxPlaylistRetries = L,
                    this.enableLowInitialPlaylist = c,
                    this.useCueTags_ && (this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues"),
                        this.cueTagsTrack_.inBandMetadataTrackDispatchType = ""),
                    this.requestOptions_ = {
                        withCredentials: s,
                        maxPlaylistRetries: L,
                        timeout: null
                    },
                    this.on("error", this.pauseLoading),
                    this.mediaTypes_ = J1(),
                    this.mediaSource = new O.default.MediaSource,
                    this.handleDurationChange_ = this.handleDurationChange_.bind(this),
                    this.handleSourceOpen_ = this.handleSourceOpen_.bind(this),
                    this.handleSourceEnded_ = this.handleSourceEnded_.bind(this),
                    this.mediaSource.addEventListener("durationchange", this.handleDurationChange_),
                    this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_),
                    this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_),
                    this.seekable_ = xt(),
                    this.hasPlayed_ = !1,
                    this.syncController_ = new U1(t),
                    this.segmentMetadataTrack_ = r.addRemoteTextTrack({
                        kind: "metadata",
                        label: "segment-metadata"
                    }, !1).track,
                    this.decrypter_ = new q1,
                    this.sourceUpdater_ = new Wm(this.mediaSource),
                    this.inbandTextTracks_ = {},
                    this.timelineChangeController_ = new j1,
                    this.keyStatusMap_ = new Map;
                const M = {
                    vhs: this.vhs_,
                    parse708captions: t.parse708captions,
                    useDtsForTimestampOffset: t.useDtsForTimestampOffset,
                    captionServices: _,
                    mediaSource: this.mediaSource,
                    currentTime: this.tech_.currentTime.bind(this.tech_),
                    seekable: () => this.seekable(),
                    seeking: () => this.tech_.seeking(),
                    duration: () => this.duration(),
                    hasPlayed: () => this.hasPlayed_,
                    goalBufferLength: () => this.goalBufferLength(),
                    bandwidth: n,
                    syncController: this.syncController_,
                    decrypter: this.decrypter_,
                    sourceType: this.sourceType_,
                    inbandTextTracks: this.inbandTextTracks_,
                    cacheEncryptionKeys: v,
                    sourceUpdater: this.sourceUpdater_,
                    timelineChangeController: this.timelineChangeController_,
                    exactManifestTimings: t.exactManifestTimings,
                    addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
                };
                this.mainPlaylistLoader_ = this.sourceType_ === "dash" ? new Dd(e, this.vhs_, Re(this.requestOptions_, {
                    addMetadataToTextTrack: this.addMetadataToTextTrack.bind(this)
                })) : new An(e, this.vhs_, Re(this.requestOptions_, {
                    addDateRangesToTextTrack: this.addDateRangesToTextTrack_.bind(this)
                })),
                    this.setupMainPlaylistLoaderListeners_(),
                    this.mainSegmentLoader_ = new Ld(Re(M, {
                        segmentMetadataTrack: this.segmentMetadataTrack_,
                        loaderType: "main"
                    }), t),
                    this.audioSegmentLoader_ = new Ld(Re(M, {
                        loaderType: "audio"
                    }), t),
                    this.subtitleSegmentLoader_ = new R1(Re(M, {
                        loaderType: "vtt",
                        featuresNativeTextTracks: this.tech_.featuresNativeTextTracks,
                        loadVttJs: () => new Promise((B, z) => {
                            function R() {
                                r.off("vttjserror", F),
                                    B()
                            }
                            function F() {
                                r.off("vttjsloaded", R),
                                    z()
                            }
                            r.one("vttjsloaded", R),
                                r.one("vttjserror", F),
                                r.addWebVttScript_()
                        }
                        )
                    }), t);
                const N = () => this.mainSegmentLoader_.bandwidth;
                this.contentSteeringController_ = new Z1(this.vhs_.xhr, N),
                    this.setupSegmentLoaderListeners_(),
                    this.bufferBasedABR && (this.mainPlaylistLoader_.one("loadedplaylist", () => this.startABRTimer_()),
                        this.tech_.on("pause", () => this.stopABRTimer_()),
                        this.tech_.on("play", () => this.startABRTimer_())),
                    tb.forEach(B => {
                        this[B + "_"] = ib.bind(this, B)
                    }
                    ),
                    this.logger_ = Ci("pc"),
                    this.triggeredFmp4Usage = !1,
                    this.tech_.preload() === "none" ? (this.loadOnPlay_ = () => {
                        this.loadOnPlay_ = null,
                            this.mainPlaylistLoader_.load()
                    }
                        ,
                        this.tech_.one("play", this.loadOnPlay_)) : this.mainPlaylistLoader_.load(),
                    this.timeToLoadedData__ = -1,
                    this.mainAppendsToLoadedData__ = -1,
                    this.audioAppendsToLoadedData__ = -1;
                const x = this.tech_.preload() === "none" ? "play" : "loadstart";
                this.tech_.one(x, () => {
                    const B = Date.now();
                    this.tech_.one("loadeddata", () => {
                        this.timeToLoadedData__ = Date.now() - B,
                            this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends,
                            this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends
                    }
                    )
                }
                )
            }
            mainAppendsToLoadedData_() {
                return this.mainAppendsToLoadedData__
            }
            audioAppendsToLoadedData_() {
                return this.audioAppendsToLoadedData__
            }
            appendsToLoadedData_() {
                const t = this.mainAppendsToLoadedData_()
                    , e = this.audioAppendsToLoadedData_();
                return t === -1 || e === -1 ? -1 : t + e
            }
            timeToLoadedData_() {
                return this.timeToLoadedData__
            }
            checkABR_(t = "abr") {
                const e = this.selectPlaylist();
                e && this.shouldSwitchToMedia_(e) && this.switchMedia_(e, t)
            }
            switchMedia_(t, e, s) {
                const r = this.media()
                    , n = r && (r.id || r.uri)
                    , a = t && (t.id || t.uri);
                n && n !== a && (this.logger_(`switch media ${n} -> ${a} from ${e}`),
                    this.tech_.trigger({
                        type: "usage",
                        name: `vhs-rendition-change-${e}`
                    })),
                    this.mainPlaylistLoader_.media(t, s)
            }
            switchMediaForDASHContentSteering_() {
                ["AUDIO", "SUBTITLES", "CLOSED-CAPTIONS"].forEach(t => {
                    const e = this.mediaTypes_[t]
                        , s = e ? e.activeGroup() : null
                        , r = this.contentSteeringController_.getPathway();
                    if (s && r) {
                        const a = (s.length ? s[0].playlists : s.playlists).filter(o => o.attributes.serviceLocation === r);
                        a.length && this.mediaTypes_[t].activePlaylistLoader.media(a[0])
                    }
                }
                )
            }
            startABRTimer_() {
                this.stopABRTimer_(),
                    this.abrTimer_ = O.default.setInterval(() => this.checkABR_(), 250)
            }
            stopABRTimer_() {
                this.tech_.scrubbing && this.tech_.scrubbing() || (O.default.clearInterval(this.abrTimer_),
                    this.abrTimer_ = null)
            }
            getAudioTrackPlaylists_() {
                const t = this.main()
                    , e = t && t.playlists || [];
                if (!t || !t.mediaGroups || !t.mediaGroups.AUDIO)
                    return e;
                const s = t.mediaGroups.AUDIO
                    , r = Object.keys(s);
                let n;
                if (Object.keys(this.mediaTypes_.AUDIO.groups).length)
                    n = this.mediaTypes_.AUDIO.activeTrack();
                else {
                    const o = s.main || r.length && s[r[0]];
                    for (const u in o)
                        if (o[u].default) {
                            n = {
                                label: u
                            };
                            break
                        }
                }
                if (!n)
                    return e;
                const a = [];
                for (const o in s)
                    if (s[o][n.label]) {
                        const u = s[o][n.label];
                        if (u.playlists && u.playlists.length)
                            a.push.apply(a, u.playlists);
                        else if (u.uri)
                            a.push(u);
                        else if (t.playlists.length)
                            for (let c = 0; c < t.playlists.length; c++) {
                                const f = t.playlists[c];
                                f.attributes && f.attributes.AUDIO && f.attributes.AUDIO === o && a.push(f)
                            }
                    }
                return a.length ? a : e
            }
            setupMainPlaylistLoaderListeners_() {
                this.mainPlaylistLoader_.on("loadedmetadata", () => {
                    const t = this.mainPlaylistLoader_.media()
                        , e = t.targetDuration * 1.5 * 1e3;
                    Td(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = e,
                        t.endList && this.tech_.preload() !== "none" && (this.mainSegmentLoader_.playlist(t, this.requestOptions_),
                            this.mainSegmentLoader_.load()),
                        Q1({
                            sourceType: this.sourceType_,
                            segmentLoaders: {
                                AUDIO: this.audioSegmentLoader_,
                                SUBTITLES: this.subtitleSegmentLoader_,
                                main: this.mainSegmentLoader_
                            },
                            tech: this.tech_,
                            requestOptions: this.requestOptions_,
                            mainPlaylistLoader: this.mainPlaylistLoader_,
                            vhs: this.vhs_,
                            main: this.main(),
                            mediaTypes: this.mediaTypes_,
                            excludePlaylist: this.excludePlaylist.bind(this)
                        }),
                        this.triggerPresenceUsage_(this.main(), t),
                        this.setupFirstPlay(),
                        !this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media() ? this.trigger("selectedinitialmedia") : this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", () => {
                            this.trigger("selectedinitialmedia")
                        }
                        )
                }
                ),
                    this.mainPlaylistLoader_.on("loadedplaylist", () => {
                        this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_);
                        let t = this.mainPlaylistLoader_.media();
                        if (!t) {
                            this.attachContentSteeringListeners_(),
                                this.initContentSteeringController_(),
                                this.excludeUnsupportedVariants_();
                            let e;
                            if (this.enableLowInitialPlaylist && (e = this.selectInitialPlaylist()),
                                e || (e = this.selectPlaylist()),
                                !e || !this.shouldSwitchToMedia_(e) || (this.initialMedia_ = e,
                                    this.switchMedia_(this.initialMedia_, "initial"),
                                    !(this.sourceType_ === "vhs-json" && this.initialMedia_.segments)))
                                return;
                            t = this.initialMedia_
                        }
                        this.handleUpdatedMediaPlaylist(t)
                    }
                    ),
                    this.mainPlaylistLoader_.on("error", () => {
                        const t = this.mainPlaylistLoader_.error;
                        this.excludePlaylist({
                            playlistToExclude: t.playlist,
                            error: t
                        })
                    }
                    ),
                    this.mainPlaylistLoader_.on("mediachanging", () => {
                        this.mainSegmentLoader_.abort(),
                            this.mainSegmentLoader_.pause()
                    }
                    ),
                    this.mainPlaylistLoader_.on("mediachange", () => {
                        const t = this.mainPlaylistLoader_.media()
                            , e = t.targetDuration * 1.5 * 1e3;
                        Td(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media()) ? this.requestOptions_.timeout = 0 : this.requestOptions_.timeout = e,
                            this.sourceType_ === "dash" && this.mainPlaylistLoader_.load(),
                            this.mainSegmentLoader_.pause(),
                            this.mainSegmentLoader_.playlist(t, this.requestOptions_),
                            this.waitingForFastQualityPlaylistReceived_ ? this.runFastQualitySwitch_() : this.mainSegmentLoader_.load(),
                            this.tech_.trigger({
                                type: "mediachange",
                                bubbles: !0
                            })
                    }
                    ),
                    this.mainPlaylistLoader_.on("playlistunchanged", () => {
                        const t = this.mainPlaylistLoader_.media();
                        if (t.lastExcludeReason_ === "playlist-unchanged")
                            return;
                        this.stuckAtPlaylistEnd_(t) && (this.excludePlaylist({
                            error: {
                                message: "Playlist no longer updating.",
                                reason: "playlist-unchanged"
                            }
                        }),
                            this.tech_.trigger("playliststuck"))
                    }
                    ),
                    this.mainPlaylistLoader_.on("renditiondisabled", () => {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-rendition-disabled"
                        })
                    }
                    ),
                    this.mainPlaylistLoader_.on("renditionenabled", () => {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-rendition-enabled"
                        })
                    }
                    )
            }
            handleUpdatedMediaPlaylist(t) {
                this.useCueTags_ && this.updateAdCues_(t),
                    this.mainSegmentLoader_.pause(),
                    this.mainSegmentLoader_.playlist(t, this.requestOptions_),
                    this.waitingForFastQualityPlaylistReceived_ && this.runFastQualitySwitch_(),
                    this.updateDuration(!t.endList),
                    this.tech_.paused() || (this.mainSegmentLoader_.load(),
                        this.audioSegmentLoader_ && this.audioSegmentLoader_.load())
            }
            triggerPresenceUsage_(t, e) {
                const s = t.mediaGroups || {};
                let r = !0;
                const n = Object.keys(s.AUDIO);
                for (const a in s.AUDIO)
                    for (const o in s.AUDIO[a])
                        s.AUDIO[a][o].uri || (r = !1);
                r && this.tech_.trigger({
                    type: "usage",
                    name: "vhs-demuxed"
                }),
                    Object.keys(s.SUBTITLES).length && this.tech_.trigger({
                        type: "usage",
                        name: "vhs-webvtt"
                    }),
                    Es.Playlist.isAes(e) && this.tech_.trigger({
                        type: "usage",
                        name: "vhs-aes"
                    }),
                    n.length && Object.keys(s.AUDIO[n[0]]).length > 1 && this.tech_.trigger({
                        type: "usage",
                        name: "vhs-alternate-audio"
                    }),
                    this.useCueTags_ && this.tech_.trigger({
                        type: "usage",
                        name: "vhs-playlist-cue-tags"
                    })
            }
            shouldSwitchToMedia_(t) {
                const e = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_
                    , s = this.tech_.currentTime()
                    , r = this.bufferLowWaterLine()
                    , n = this.bufferHighWaterLine()
                    , a = this.tech_.buffered();
                return sb({
                    buffered: a,
                    currentTime: s,
                    currentPlaylist: e,
                    nextPlaylist: t,
                    bufferLowWaterLine: r,
                    bufferHighWaterLine: n,
                    duration: this.duration(),
                    bufferBasedABR: this.bufferBasedABR,
                    log: this.logger_
                })
            }
            setupSegmentLoaderListeners_() {
                this.mainSegmentLoader_.on("bandwidthupdate", () => {
                    this.checkABR_("bandwidthupdate"),
                        this.tech_.trigger("bandwidthupdate")
                }
                ),
                    this.mainSegmentLoader_.on("timeout", () => {
                        this.bufferBasedABR && this.mainSegmentLoader_.load()
                    }
                    ),
                    this.bufferBasedABR || this.mainSegmentLoader_.on("progress", () => {
                        this.trigger("progress")
                    }
                    ),
                    this.mainSegmentLoader_.on("error", () => {
                        const e = this.mainSegmentLoader_.error();
                        this.excludePlaylist({
                            playlistToExclude: e.playlist,
                            error: e
                        })
                    }
                    ),
                    this.mainSegmentLoader_.on("appenderror", () => {
                        this.error = this.mainSegmentLoader_.error_,
                            this.trigger("error")
                    }
                    ),
                    this.mainSegmentLoader_.on("syncinfoupdate", () => {
                        this.onSyncInfoUpdate_()
                    }
                    ),
                    this.mainSegmentLoader_.on("timestampoffset", () => {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-timestamp-offset"
                        })
                    }
                    ),
                    this.audioSegmentLoader_.on("syncinfoupdate", () => {
                        this.onSyncInfoUpdate_()
                    }
                    ),
                    this.audioSegmentLoader_.on("appenderror", () => {
                        this.error = this.audioSegmentLoader_.error_,
                            this.trigger("error")
                    }
                    ),
                    this.mainSegmentLoader_.on("ended", () => {
                        this.logger_("main segment loader ended"),
                            this.onEndOfStream()
                    }
                    ),
                    this.mainSegmentLoader_.on("earlyabort", e => {
                        this.bufferBasedABR || (this.delegateLoaders_("all", ["abort"]),
                            this.excludePlaylist({
                                error: {
                                    message: "Aborted early because there isn't enough bandwidth to complete the request without rebuffering."
                                },
                                playlistExclusionDuration: eb
                            }))
                    }
                    );
                const t = () => {
                    if (!this.sourceUpdater_.hasCreatedSourceBuffers())
                        return this.tryToCreateSourceBuffers_();
                    const e = this.getCodecsOrExclude_();
                    e && this.sourceUpdater_.addOrChangeSourceBuffers(e)
                }
                    ;
                this.mainSegmentLoader_.on("trackinfo", t),
                    this.audioSegmentLoader_.on("trackinfo", t),
                    this.mainSegmentLoader_.on("fmp4", () => {
                        this.triggeredFmp4Usage || (this.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        }),
                            this.triggeredFmp4Usage = !0)
                    }
                    ),
                    this.audioSegmentLoader_.on("fmp4", () => {
                        this.triggeredFmp4Usage || (this.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        }),
                            this.triggeredFmp4Usage = !0)
                    }
                    ),
                    this.audioSegmentLoader_.on("ended", () => {
                        this.logger_("audioSegmentLoader ended"),
                            this.onEndOfStream()
                    }
                    )
            }
            mediaSecondsLoaded_() {
                return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded)
            }
            load() {
                this.mainSegmentLoader_.load(),
                    this.mediaTypes_.AUDIO.activePlaylistLoader && this.audioSegmentLoader_.load(),
                    this.mediaTypes_.SUBTITLES.activePlaylistLoader && this.subtitleSegmentLoader_.load()
            }
            fastQualityChange_(t = this.selectPlaylist()) {
                if (t === this.mainPlaylistLoader_.media()) {
                    this.logger_("skipping fastQualityChange because new media is same as old");
                    return
                }
                this.switchMedia_(t, "fast-quality"),
                    this.waitingForFastQualityPlaylistReceived_ = !0
            }
            runFastQualitySwitch_() {
                this.waitingForFastQualityPlaylistReceived_ = !1,
                    this.mainSegmentLoader_.pause(),
                    this.mainSegmentLoader_.resetEverything(() => {
                        this.tech_.setCurrentTime(this.tech_.currentTime())
                    }
                    )
            }
            play() {
                if (this.setupFirstPlay())
                    return;
                this.tech_.ended() && this.tech_.setCurrentTime(0),
                    this.hasPlayed_ && this.load();
                const t = this.tech_.seekable();
                if (this.tech_.duration() === 1 / 0 && this.tech_.currentTime() < t.start(0))
                    return this.tech_.setCurrentTime(t.end(t.length - 1))
            }
            setupFirstPlay() {
                const t = this.mainPlaylistLoader_.media();
                if (!t || this.tech_.paused() || this.hasPlayed_)
                    return !1;
                if (!t.endList || t.start) {
                    const e = this.seekable();
                    if (!e.length)
                        return !1;
                    const s = e.end(0);
                    let r = s;
                    if (t.start) {
                        const n = t.start.timeOffset;
                        n < 0 ? r = Math.max(s + n, e.start(0)) : r = Math.min(s, n)
                    }
                    this.trigger("firstplay"),
                        this.tech_.setCurrentTime(r)
                }
                return this.hasPlayed_ = !0,
                    this.load(),
                    !0
            }
            handleSourceOpen_() {
                if (this.tryToCreateSourceBuffers_(),
                    this.tech_.autoplay()) {
                    const t = this.tech_.play();
                    typeof t < "u" && typeof t.then == "function" && t.then(null, e => { }
                    )
                }
                this.trigger("sourceopen")
            }
            handleSourceEnded_() {
                if (!this.inbandTextTracks_.metadataTrack_)
                    return;
                const t = this.inbandTextTracks_.metadataTrack_.cues;
                if (!t || !t.length)
                    return;
                const e = this.duration();
                t[t.length - 1].endTime = isNaN(e) || Math.abs(e) === 1 / 0 ? Number.MAX_VALUE : e
            }
            handleDurationChange_() {
                this.tech_.trigger("durationchange")
            }
            onEndOfStream() {
                let t = this.mainSegmentLoader_.ended_;
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                    const e = this.mainSegmentLoader_.getCurrentMediaInfo_();
                    !e || e.hasVideo ? t = t && this.audioSegmentLoader_.ended_ : t = this.audioSegmentLoader_.ended_
                }
                t && (this.stopABRTimer_(),
                    this.sourceUpdater_.endOfStream())
            }
            stuckAtPlaylistEnd_(t) {
                if (!this.seekable().length)
                    return !1;
                const s = this.syncController_.getExpiredTime(t, this.duration());
                if (s === null)
                    return !1;
                const r = Es.Playlist.playlistEnd(t, s)
                    , n = this.tech_.currentTime()
                    , a = this.tech_.buffered();
                if (!a.length)
                    return r - n <= ss;
                const o = a.end(a.length - 1);
                return o - n <= ss && r - o <= ss
            }
            excludePlaylist({ playlistToExclude: t = this.mainPlaylistLoader_.media(), error: e = {}, playlistExclusionDuration: s }) {
                if (t = t || this.mainPlaylistLoader_.media(),
                    s = s || e.playlistExclusionDuration || this.playlistExclusionDuration,
                    !t) {
                    this.error = e,
                        this.mediaSource.readyState !== "open" ? this.trigger("error") : this.sourceUpdater_.endOfStream("network");
                    return
                }
                t.playlistErrors_++;
                const r = this.mainPlaylistLoader_.main.playlists
                    , n = r.filter(Al)
                    , a = n.length === 1 && n[0] === t;
                if (r.length === 1 && s !== 1 / 0)
                    return U.log.warn(`Problem encountered with playlist ${t.id}. Trying again since it is the only playlist.`),
                        this.tech_.trigger("retryplaylist"),
                        this.mainPlaylistLoader_.load(a);
                if (a) {
                    if (this.main().contentSteering) {
                        const _ = this.pathwayAttribute_(t)
                            , L = this.contentSteeringController_.steeringManifest.ttl * 1e3;
                        this.contentSteeringController_.excludePathway(_),
                            this.excludeThenChangePathway_(),
                            setTimeout(() => {
                                this.contentSteeringController_.addAvailablePathway(_)
                            }
                                , L);
                        return
                    }
                    let D = !1;
                    r.forEach(_ => {
                        if (_ === t)
                            return;
                        const L = _.excludeUntil;
                        typeof L < "u" && L !== 1 / 0 && (D = !0,
                            delete _.excludeUntil)
                    }
                    ),
                        D && (U.log.warn("Removing other playlists from the exclusion list because the last rendition is about to be excluded."),
                            this.tech_.trigger("retryplaylist"))
                }
                let o;
                t.playlistErrors_ > this.maxPlaylistRetries ? o = 1 / 0 : o = Date.now() + s * 1e3,
                    t.excludeUntil = o,
                    e.reason && (t.lastExcludeReason_ = e.reason),
                    this.tech_.trigger("excludeplaylist"),
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-rendition-excluded"
                    });
                const u = this.selectPlaylist();
                if (!u) {
                    this.error = "Playback cannot continue. No available working or supported playlists.",
                        this.trigger("error");
                    return
                }
                const c = e.internal ? this.logger_ : U.log.warn
                    , f = e.message ? " " + e.message : "";
                c(`${e.internal ? "Internal problem" : "Problem"} encountered with playlist ${t.id}.${f} Switching to playlist ${u.id}.`),
                    u.attributes.AUDIO !== t.attributes.AUDIO && this.delegateLoaders_("audio", ["abort", "pause"]),
                    u.attributes.SUBTITLES !== t.attributes.SUBTITLES && this.delegateLoaders_("subtitle", ["abort", "pause"]),
                    this.delegateLoaders_("main", ["abort", "pause"]);
                const v = u.targetDuration / 2 * 1e3 || 5 * 1e3
                    , T = typeof u.lastRequest == "number" && Date.now() - u.lastRequest <= v;
                return this.switchMedia_(u, "exclude", a || T)
            }
            pauseLoading() {
                this.delegateLoaders_("all", ["abort", "pause"]),
                    this.stopABRTimer_()
            }
            delegateLoaders_(t, e) {
                const s = []
                    , r = t === "all";
                (r || t === "main") && s.push(this.mainPlaylistLoader_);
                const n = [];
                (r || t === "audio") && n.push("AUDIO"),
                    (r || t === "subtitle") && (n.push("CLOSED-CAPTIONS"),
                        n.push("SUBTITLES")),
                    n.forEach(a => {
                        const o = this.mediaTypes_[a] && this.mediaTypes_[a].activePlaylistLoader;
                        o && s.push(o)
                    }
                    ),
                    ["main", "audio", "subtitle"].forEach(a => {
                        const o = this[`${a}SegmentLoader_`];
                        o && (t === a || t === "all") && s.push(o)
                    }
                    ),
                    s.forEach(a => e.forEach(o => {
                        typeof a[o] == "function" && a[o]()
                    }
                    ))
            }
            setCurrentTime(t) {
                const e = En(this.tech_.buffered(), t);
                if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media()) || !this.mainPlaylistLoader_.media().segments)
                    return 0;
                if (e && e.length)
                    return t;
                this.mainSegmentLoader_.pause(),
                    this.mainSegmentLoader_.resetEverything(),
                    this.mediaTypes_.AUDIO.activePlaylistLoader && (this.audioSegmentLoader_.pause(),
                        this.audioSegmentLoader_.resetEverything()),
                    this.mediaTypes_.SUBTITLES.activePlaylistLoader && (this.subtitleSegmentLoader_.pause(),
                        this.subtitleSegmentLoader_.resetEverything()),
                    this.load()
            }
            duration() {
                if (!this.mainPlaylistLoader_)
                    return 0;
                const t = this.mainPlaylistLoader_.media();
                return t ? t.endList ? this.mediaSource ? this.mediaSource.duration : Es.Playlist.duration(t) : 1 / 0 : 0
            }
            seekable() {
                return this.seekable_
            }
            onSyncInfoUpdate_() {
                let t;
                if (!this.mainPlaylistLoader_)
                    return;
                let e = this.mainPlaylistLoader_.media();
                if (!e)
                    return;
                let s = this.syncController_.getExpiredTime(e, this.duration());
                if (s === null)
                    return;
                const r = this.mainPlaylistLoader_.main
                    , n = Es.Playlist.seekable(e, s, Es.Playlist.liveEdgeDelay(r, e));
                if (n.length === 0 || this.mediaTypes_.AUDIO.activePlaylistLoader && (e = this.mediaTypes_.AUDIO.activePlaylistLoader.media(),
                    s = this.syncController_.getExpiredTime(e, this.duration()),
                    s === null || (t = Es.Playlist.seekable(e, s, Es.Playlist.liveEdgeDelay(r, e)),
                        t.length === 0)))
                    return;
                let a, o;
                this.seekable_ && this.seekable_.length && (a = this.seekable_.end(0),
                    o = this.seekable_.start(0)),
                    t ? t.start(0) > n.end(0) || n.start(0) > t.end(0) ? this.seekable_ = n : this.seekable_ = xt([[t.start(0) > n.start(0) ? t.start(0) : n.start(0), t.end(0) < n.end(0) ? t.end(0) : n.end(0)]]) : this.seekable_ = n,
                    !(this.seekable_ && this.seekable_.length && this.seekable_.end(0) === a && this.seekable_.start(0) === o) && (this.logger_(`seekable updated [${Wp(this.seekable_)}]`),
                        this.tech_.trigger("seekablechanged"))
            }
            updateDuration(t) {
                if (this.updateDuration_ && (this.mediaSource.removeEventListener("sourceopen", this.updateDuration_),
                    this.updateDuration_ = null),
                    this.mediaSource.readyState !== "open") {
                    this.updateDuration_ = this.updateDuration.bind(this, t),
                        this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
                    return
                }
                if (t) {
                    const r = this.seekable();
                    if (!r.length)
                        return;
                    (isNaN(this.mediaSource.duration) || this.mediaSource.duration < r.end(r.length - 1)) && this.sourceUpdater_.setDuration(r.end(r.length - 1));
                    return
                }
                const e = this.tech_.buffered();
                let s = Es.Playlist.duration(this.mainPlaylistLoader_.media());
                e.length > 0 && (s = Math.max(s, e.end(e.length - 1))),
                    this.mediaSource.duration !== s && this.sourceUpdater_.setDuration(s)
            }
            dispose() {
                this.trigger("dispose"),
                    this.decrypter_.terminate(),
                    this.mainPlaylistLoader_.dispose(),
                    this.mainSegmentLoader_.dispose(),
                    this.contentSteeringController_.dispose(),
                    this.keyStatusMap_.clear(),
                    this.loadOnPlay_ && this.tech_.off("play", this.loadOnPlay_),
                    ["AUDIO", "SUBTITLES"].forEach(t => {
                        const e = this.mediaTypes_[t].groups;
                        for (const s in e)
                            e[s].forEach(r => {
                                r.playlistLoader && r.playlistLoader.dispose()
                            }
                            )
                    }
                    ),
                    this.audioSegmentLoader_.dispose(),
                    this.subtitleSegmentLoader_.dispose(),
                    this.sourceUpdater_.dispose(),
                    this.timelineChangeController_.dispose(),
                    this.stopABRTimer_(),
                    this.updateDuration_ && this.mediaSource.removeEventListener("sourceopen", this.updateDuration_),
                    this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_),
                    this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_),
                    this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_),
                    this.off()
            }
            main() {
                return this.mainPlaylistLoader_.main
            }
            media() {
                return this.mainPlaylistLoader_.media() || this.initialMedia_
            }
            areMediaTypesKnown_() {
                const t = !!this.mediaTypes_.AUDIO.activePlaylistLoader
                    , e = !!this.mainSegmentLoader_.getCurrentMediaInfo_()
                    , s = t ? !!this.audioSegmentLoader_.getCurrentMediaInfo_() : !0;
                return !(!e || !s)
            }
            getCodecsOrExclude_() {
                const t = {
                    main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
                    audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
                }
                    , e = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
                t.video = t.main;
                const s = Na(this.main(), e)
                    , r = {}
                    , n = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
                if (t.main.hasVideo && (r.video = s.video || t.main.videoCodec || t_),
                    t.main.isMuxed && (r.video += `,${s.audio || t.main.audioCodec || Rc}`),
                    (t.main.hasAudio && !t.main.isMuxed || t.audio.hasAudio || n) && (r.audio = s.audio || t.main.audioCodec || t.audio.audioCodec || Rc,
                        t.audio.isFmp4 = t.main.hasAudio && !t.main.isMuxed ? t.main.isFmp4 : t.audio.isFmp4),
                    !r.audio && !r.video) {
                    this.excludePlaylist({
                        playlistToExclude: e,
                        error: {
                            message: "Could not determine codecs for playlist."
                        },
                        playlistExclusionDuration: 1 / 0
                    });
                    return
                }
                const a = (c, f) => c ? Ho(f) : dh(f)
                    , o = {};
                let u;
                if (["video", "audio"].forEach(function (c) {
                    if (r.hasOwnProperty(c) && !a(t[c].isFmp4, r[c])) {
                        const f = t[c].isFmp4 ? "browser" : "muxer";
                        o[f] = o[f] || [],
                            o[f].push(r[c]),
                            c === "audio" && (u = f)
                    }
                }),
                    n && u && e.attributes.AUDIO) {
                    const c = e.attributes.AUDIO;
                    this.main().playlists.forEach(f => {
                        (f.attributes && f.attributes.AUDIO) === c && f !== e && (f.excludeUntil = 1 / 0)
                    }
                    ),
                        this.logger_(`excluding audio group ${c} as ${u} does not support codec(s): "${r.audio}"`)
                }
                if (Object.keys(o).length) {
                    const c = Object.keys(o).reduce((f, v) => (f && (f += ", "),
                        f += `${v} does not support codec(s): "${o[v].join(",")}"`,
                        f), "") + ".";
                    this.excludePlaylist({
                        playlistToExclude: e,
                        error: {
                            internal: !0,
                            message: c
                        },
                        playlistExclusionDuration: 1 / 0
                    });
                    return
                }
                if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
                    const c = [];
                    if (["video", "audio"].forEach(f => {
                        const v = (Xi(this.sourceUpdater_.codecs[f] || "")[0] || {}).type
                            , T = (Xi(r[f] || "")[0] || {}).type;
                        v && T && v.toLowerCase() !== T.toLowerCase() && c.push(`"${this.sourceUpdater_.codecs[f]}" -> "${r[f]}"`)
                    }
                    ),
                        c.length) {
                        this.excludePlaylist({
                            playlistToExclude: e,
                            error: {
                                message: `Codec switching not supported: ${c.join(", ")}.`,
                                internal: !0
                            },
                            playlistExclusionDuration: 1 / 0
                        });
                        return
                    }
                }
                return r
            }
            tryToCreateSourceBuffers_() {
                if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers() || !this.areMediaTypesKnown_())
                    return;
                const t = this.getCodecsOrExclude_();
                if (!t)
                    return;
                this.sourceUpdater_.createSourceBuffers(t);
                const e = [t.video, t.audio].filter(Boolean).join(",");
                this.excludeIncompatibleVariants_(e)
            }
            excludeUnsupportedVariants_() {
                const t = this.main().playlists
                    , e = [];
                Object.keys(t).forEach(s => {
                    const r = t[s];
                    if (e.indexOf(r.id) !== -1)
                        return;
                    e.push(r.id);
                    const n = Na(this.main, r)
                        , a = [];
                    n.audio && !dh(n.audio) && !Ho(n.audio) && a.push(`audio codec ${n.audio}`),
                        n.video && !dh(n.video) && !Ho(n.video) && a.push(`video codec ${n.video}`),
                        n.text && n.text === "stpp.ttml.im1t" && a.push(`text codec ${n.text}`),
                        a.length && (r.excludeUntil = 1 / 0,
                            this.logger_(`excluding ${r.id} for unsupported: ${a.join(", ")}`))
                }
                )
            }
            excludeIncompatibleVariants_(t) {
                const e = []
                    , s = this.main().playlists
                    , r = Dl(Xi(t))
                    , n = Mm(r)
                    , a = r.video && Xi(r.video)[0] || null
                    , o = r.audio && Xi(r.audio)[0] || null;
                Object.keys(s).forEach(u => {
                    const c = s[u];
                    if (e.indexOf(c.id) !== -1 || c.excludeUntil === 1 / 0)
                        return;
                    e.push(c.id);
                    const f = []
                        , v = Na(this.mainPlaylistLoader_.main, c)
                        , T = Mm(v);
                    if (!(!v.audio && !v.video)) {
                        if (T !== n && f.push(`codec count "${T}" !== "${n}"`),
                            !this.sourceUpdater_.canChangeType()) {
                            const D = v.video && Xi(v.video)[0] || null
                                , _ = v.audio && Xi(v.audio)[0] || null;
                            D && a && D.type.toLowerCase() !== a.type.toLowerCase() && f.push(`video codec "${D.type}" !== "${a.type}"`),
                                _ && o && _.type.toLowerCase() !== o.type.toLowerCase() && f.push(`audio codec "${_.type}" !== "${o.type}"`)
                        }
                        f.length && (c.excludeUntil = 1 / 0,
                            this.logger_(`excluding ${c.id}: ${f.join(" && ")}`))
                    }
                }
                )
            }
            updateAdCues_(t) {
                let e = 0;
                const s = this.seekable();
                s.length && (e = s.start(0)),
                    B1(t, this.cueTagsTrack_, e)
            }
            goalBufferLength() {
                const t = this.tech_.currentTime()
                    , e = mt.GOAL_BUFFER_LENGTH
                    , s = mt.GOAL_BUFFER_LENGTH_RATE
                    , r = Math.max(e, mt.MAX_GOAL_BUFFER_LENGTH);
                return Math.min(e + t * s, r)
            }
            bufferLowWaterLine() {
                const t = this.tech_.currentTime()
                    , e = mt.BUFFER_LOW_WATER_LINE
                    , s = mt.BUFFER_LOW_WATER_LINE_RATE
                    , r = Math.max(e, mt.MAX_BUFFER_LOW_WATER_LINE)
                    , n = Math.max(e, mt.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
                return Math.min(e + t * s, this.bufferBasedABR ? n : r)
            }
            bufferHighWaterLine() {
                return mt.BUFFER_HIGH_WATER_LINE
            }
            addDateRangesToTextTrack_(t) {
                Fm(this.inbandTextTracks_, "com.apple.streaming", this.tech_),
                    y1({
                        inbandTextTracks: this.inbandTextTracks_,
                        dateRanges: t
                    })
            }
            addMetadataToTextTrack(t, e, s) {
                const r = this.sourceUpdater_.videoBuffer ? this.sourceUpdater_.videoTimestampOffset() : this.sourceUpdater_.audioTimestampOffset();
                Fm(this.inbandTextTracks_, t, this.tech_),
                    m1({
                        inbandTextTracks: this.inbandTextTracks_,
                        metadataArray: e,
                        timestampOffset: r,
                        videoDuration: s
                    })
            }
            pathwayAttribute_(t) {
                return t.attributes["PATHWAY-ID"] || t.attributes.serviceLocation
            }
            initContentSteeringController_() {
                const t = this.main();
                if (t.contentSteering) {
                    for (const e of t.playlists)
                        this.contentSteeringController_.addAvailablePathway(this.pathwayAttribute_(e));
                    if (this.contentSteeringController_.assignTagProperties(t.uri, t.contentSteering),
                        this.contentSteeringController_.queryBeforeStart) {
                        this.contentSteeringController_.requestSteeringManifest(!0);
                        return
                    }
                    this.tech_.one("canplay", () => {
                        this.contentSteeringController_.requestSteeringManifest()
                    }
                    )
                }
            }
            resetContentSteeringController_() {
                this.contentSteeringController_.clearAvailablePathways(),
                    this.contentSteeringController_.dispose(),
                    this.initContentSteeringController_()
            }
            attachContentSteeringListeners_() {
                this.contentSteeringController_.on("content-steering", this.excludeThenChangePathway_.bind(this)),
                    this.sourceType_ === "dash" && this.mainPlaylistLoader_.on("loadedplaylist", () => {
                        const t = this.main();
                        (this.contentSteeringController_.didDASHTagChange(t.uri, t.contentSteering) || (() => {
                            const r = this.contentSteeringController_.getAvailablePathways()
                                , n = [];
                            for (const a of t.playlists) {
                                const o = a.attributes.serviceLocation;
                                if (o && (n.push(o),
                                    !r.has(o)))
                                    return !0
                            }
                            return !!(!n.length && r.size)
                        }
                        )()) && this.resetContentSteeringController_()
                    }
                    )
            }
            excludeThenChangePathway_() {
                const t = this.contentSteeringController_.getPathway();
                if (!t)
                    return;
                this.handlePathwayClones_();
                const s = this.main().playlists
                    , r = new Set;
                let n = !1;
                Object.keys(s).forEach(a => {
                    const o = s[a]
                        , u = this.pathwayAttribute_(o)
                        , c = u && t !== u;
                    o.excludeUntil === 1 / 0 && o.lastExcludeReason_ === "content-steering" && !c && (delete o.excludeUntil,
                        delete o.lastExcludeReason_,
                        n = !0);
                    const v = !o.excludeUntil && o.excludeUntil !== 1 / 0;
                    !r.has(o.id) && c && v && (r.add(o.id),
                        o.excludeUntil = 1 / 0,
                        o.lastExcludeReason_ = "content-steering",
                        this.logger_(`excluding ${o.id} for ${o.lastExcludeReason_}`))
                }
                ),
                    this.contentSteeringController_.manifestType_ === "DASH" && Object.keys(this.mediaTypes_).forEach(a => {
                        const o = this.mediaTypes_[a];
                        if (o.activePlaylistLoader) {
                            const u = o.activePlaylistLoader.media_;
                            u && u.attributes.serviceLocation !== t && (n = !0)
                        }
                    }
                    ),
                    n && this.changeSegmentPathway_()
            }
            handlePathwayClones_() {
                const e = this.main().playlists
                    , s = this.contentSteeringController_.currentPathwayClones
                    , r = this.contentSteeringController_.nextPathwayClones;
                if (s && s.size || r && r.size) {
                    for (const [a, o] of s.entries())
                        r.get(a) || (this.mainPlaylistLoader_.updateOrDeleteClone(o),
                            this.contentSteeringController_.excludePathway(a));
                    for (const [a, o] of r.entries()) {
                        const u = s.get(a);
                        if (!u) {
                            e.filter(f => f.attributes["PATHWAY-ID"] === o["BASE-ID"]).forEach(f => {
                                this.mainPlaylistLoader_.addClonePathway(o, f)
                            }
                            ),
                                this.contentSteeringController_.addAvailablePathway(a);
                            continue
                        }
                        this.equalPathwayClones_(u, o) || (this.mainPlaylistLoader_.updateOrDeleteClone(o, !0),
                            this.contentSteeringController_.addAvailablePathway(a))
                    }
                    this.contentSteeringController_.currentPathwayClones = new Map(JSON.parse(JSON.stringify([...r])))
                }
            }
            equalPathwayClones_(t, e) {
                if (t["BASE-ID"] !== e["BASE-ID"] || t.ID !== e.ID || t["URI-REPLACEMENT"].HOST !== e["URI-REPLACEMENT"].HOST)
                    return !1;
                const s = t["URI-REPLACEMENT"].PARAMS
                    , r = e["URI-REPLACEMENT"].PARAMS;
                for (const n in s)
                    if (s[n] !== r[n])
                        return !1;
                for (const n in r)
                    if (s[n] !== r[n])
                        return !1;
                return !0
            }
            changeSegmentPathway_() {
                const t = this.selectPlaylist();
                this.pauseLoading(),
                    this.contentSteeringController_.manifestType_ === "DASH" && this.switchMediaForDASHContentSteering_(),
                    this.switchMedia_(t, "content-steering")
            }
            excludeNonUsablePlaylistsByKeyId_() {
                !this.mainPlaylistLoader_ || !this.mainPlaylistLoader_.main || this.mainPlaylistLoader_.main.playlists.forEach(t => {
                    const e = this.mainPlaylistLoader_.getKeyIdSet(t);
                    !e || !e.size || e.forEach(s => {
                        const r = "usable"
                            , n = "non-usable"
                            , a = this.keyStatusMap_.has(s) && this.keyStatusMap_.get(s) === r
                            , o = t.lastExcludeReason_ === n && t.excludeUntil === 1 / 0;
                        a ? a && o && (delete t.excludeUntil,
                            delete t.lastExcludeReason_,
                            this.logger_(`enabling playlist ${t.id} because key ID ${s} is ${r}`)) : (t.excludeUntil = 1 / 0,
                                t.lastExcludeReason_ = n,
                                this.logger_(`excluding playlist ${t.id} because the key ID ${s} doesn't exist in the keyStatusMap or is not ${r}`))
                    }
                    )
                }
                )
            }
            addKeyStatus_(t, e) {
                const r = typeof t == "string" ? t : O1(t);
                this.keyStatusMap_.set(r.slice(0, 32), e)
            }
            updatePlaylistByKeyStatus(t, e) {
                this.addKeyStatus_(t, e),
                    this.excludeNonUsablePlaylistsByKeyId_();
                const s = this.mainPlaylistLoader_.media()
                    , r = this.selectPlaylist()
                    , n = "keystatus-change";
                r !== s && this.switchMedia_(r, n)
            }
        }
        , nb = (t, e, s) => r => {
            const n = t.main.playlists[e]
                , a = _d(n)
                , o = Al(n);
            return typeof r > "u" ? o : (r ? delete n.disabled : n.disabled = !0,
                r !== o && !a && (s(),
                    r ? t.trigger("renditionenabled") : t.trigger("renditiondisabled")),
                r)
        }
        , ab = class {
            constructor(t, e, s) {
                const { playlistController_: r } = t
                    , n = r.fastQualityChange_.bind(r);
                if (e.attributes) {
                    const a = e.attributes.RESOLUTION;
                    this.width = a && a.width,
                        this.height = a && a.height,
                        this.bandwidth = e.attributes.BANDWIDTH,
                        this.frameRate = e.attributes["FRAME-RATE"]
                }
                this.codecs = Na(r.main(), e),
                    this.playlist = e,
                    this.id = s,
                    this.enabled = nb(t.playlists, e.id, n)
            }
        }
        , ob = function (t) {
            t.representations = () => {
                const e = t.playlistController_.main()
                    , s = Ma(e) ? t.playlistController_.getAudioTrackPlaylists_() : e.playlists;
                return s ? s.filter(r => !_d(r)).map((r, n) => new ab(t, r, r.id)) : []
            }
        }, eg = ["seeking", "seeked", "pause", "playing", "error"], lb = class {
            constructor(t) {
                this.playlistController_ = t.playlistController,
                    this.tech_ = t.tech,
                    this.seekable = t.seekable,
                    this.allowSeeksWithinUnsafeLiveWindow = t.allowSeeksWithinUnsafeLiveWindow,
                    this.liveRangeSafeTimeDelta = t.liveRangeSafeTimeDelta,
                    this.media = t.media,
                    this.consecutiveUpdates = 0,
                    this.lastRecordedTime = null,
                    this.checkCurrentTimeTimeout_ = null,
                    this.logger_ = Ci("PlaybackWatcher"),
                    this.logger_("initialize");
                const e = () => this.monitorCurrentTime_()
                    , s = () => this.monitorCurrentTime_()
                    , r = () => this.techWaiting_()
                    , n = () => this.resetTimeUpdate_()
                    , a = this.playlistController_
                    , o = ["main", "subtitle", "audio"]
                    , u = {};
                o.forEach(f => {
                    u[f] = {
                        reset: () => this.resetSegmentDownloads_(f),
                        updateend: () => this.checkSegmentDownloads_(f)
                    },
                        a[`${f}SegmentLoader_`].on("appendsdone", u[f].updateend),
                        a[`${f}SegmentLoader_`].on("playlistupdate", u[f].reset),
                        this.tech_.on(["seeked", "seeking"], u[f].reset)
                }
                );
                const c = f => {
                    ["main", "audio"].forEach(v => {
                        a[`${v}SegmentLoader_`][f]("appended", this.seekingAppendCheck_)
                    }
                    )
                }
                    ;
                this.seekingAppendCheck_ = () => {
                    this.fixesBadSeeks_() && (this.consecutiveUpdates = 0,
                        this.lastRecordedTime = this.tech_.currentTime(),
                        c("off"))
                }
                    ,
                    this.clearSeekingAppendCheck_ = () => c("off"),
                    this.watchForBadSeeking_ = () => {
                        this.clearSeekingAppendCheck_(),
                            c("on")
                    }
                    ,
                    this.tech_.on("seeked", this.clearSeekingAppendCheck_),
                    this.tech_.on("seeking", this.watchForBadSeeking_),
                    this.tech_.on("waiting", r),
                    this.tech_.on(eg, n),
                    this.tech_.on("canplay", s),
                    this.tech_.one("play", e),
                    this.dispose = () => {
                        this.clearSeekingAppendCheck_(),
                            this.logger_("dispose"),
                            this.tech_.off("waiting", r),
                            this.tech_.off(eg, n),
                            this.tech_.off("canplay", s),
                            this.tech_.off("play", e),
                            this.tech_.off("seeking", this.watchForBadSeeking_),
                            this.tech_.off("seeked", this.clearSeekingAppendCheck_),
                            o.forEach(f => {
                                a[`${f}SegmentLoader_`].off("appendsdone", u[f].updateend),
                                    a[`${f}SegmentLoader_`].off("playlistupdate", u[f].reset),
                                    this.tech_.off(["seeked", "seeking"], u[f].reset)
                            }
                            ),
                            this.checkCurrentTimeTimeout_ && O.default.clearTimeout(this.checkCurrentTimeTimeout_),
                            this.resetTimeUpdate_()
                    }
            }
            monitorCurrentTime_() {
                this.checkCurrentTime_(),
                    this.checkCurrentTimeTimeout_ && O.default.clearTimeout(this.checkCurrentTimeTimeout_),
                    this.checkCurrentTimeTimeout_ = O.default.setTimeout(this.monitorCurrentTime_.bind(this), 250)
            }
            resetSegmentDownloads_(t) {
                const e = this.playlistController_[`${t}SegmentLoader_`];
                this[`${t}StalledDownloads_`] > 0 && this.logger_(`resetting possible stalled download count for ${t} loader`),
                    this[`${t}StalledDownloads_`] = 0,
                    this[`${t}Buffered_`] = e.buffered_()
            }
            checkSegmentDownloads_(t) {
                const e = this.playlistController_
                    , s = e[`${t}SegmentLoader_`]
                    , r = s.buffered_()
                    , n = QT(this[`${t}Buffered_`], r);
                if (this[`${t}Buffered_`] = r,
                    n) {
                    this.resetSegmentDownloads_(t);
                    return
                }
                this[`${t}StalledDownloads_`]++,
                    this.logger_(`found #${this[`${t}StalledDownloads_`]} ${t} appends that did not increase buffer (possible stalled download)`, {
                        playlistId: s.playlist_ && s.playlist_.id,
                        buffered: Sr(r)
                    }),
                    !(this[`${t}StalledDownloads_`] < 10) && (this.logger_(`${t} loader stalled download exclusion`),
                        this.resetSegmentDownloads_(t),
                        this.tech_.trigger({
                            type: "usage",
                            name: `vhs-${t}-download-exclusion`
                        }),
                        t !== "subtitle" && e.excludePlaylist({
                            error: {
                                message: `Excessive ${t} segment downloading detected.`
                            },
                            playlistExclusionDuration: 1 / 0
                        }))
            }
            checkCurrentTime_() {
                if (this.tech_.paused() || this.tech_.seeking())
                    return;
                const t = this.tech_.currentTime()
                    , e = this.tech_.buffered();
                if (this.lastRecordedTime === t && (!e.length || t + ss >= e.end(e.length - 1)))
                    return this.techWaiting_();
                this.consecutiveUpdates >= 5 && t === this.lastRecordedTime ? (this.consecutiveUpdates++,
                    this.waiting_()) : t === this.lastRecordedTime ? this.consecutiveUpdates++ : (this.consecutiveUpdates = 0,
                        this.lastRecordedTime = t)
            }
            resetTimeUpdate_() {
                this.consecutiveUpdates = 0
            }
            fixesBadSeeks_() {
                if (!this.tech_.seeking())
                    return !1;
                const e = this.seekable()
                    , s = this.tech_.currentTime()
                    , r = this.afterSeekableWindow_(e, s, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
                let n;
                if (r && (n = e.end(e.length - 1)),
                    this.beforeSeekableWindow_(e, s)) {
                    const _ = e.start(0);
                    n = _ + (_ === e.end(0) ? 0 : ss)
                }
                if (typeof n < "u")
                    return this.logger_(`Trying to seek outside of seekable at time ${s} with seekable range ${Wp(e)}. Seeking to ${n}.`),
                        this.tech_.setCurrentTime(n),
                        !0;
                const a = this.playlistController_.sourceUpdater_
                    , o = this.tech_.buffered()
                    , u = a.audioBuffer ? a.audioBuffered() : null
                    , c = a.videoBuffer ? a.videoBuffered() : null
                    , f = this.media()
                    , v = f.partTargetDuration ? f.partTargetDuration : (f.targetDuration - Ks) * 2
                    , T = [u, c];
                for (let _ = 0; _ < T.length; _++) {
                    if (!T[_])
                        continue;
                    if (gd(T[_], s) < v)
                        return !1
                }
                const D = Cl(o, s);
                return D.length === 0 ? !1 : (n = D.start(0) + ss,
                    this.logger_(`Buffered region starts (${D.start(0)})  just beyond seek point (${s}). Seeking to ${n}.`),
                    this.tech_.setCurrentTime(n),
                    !0)
            }
            waiting_() {
                if (this.techWaiting_())
                    return;
                const t = this.tech_.currentTime()
                    , e = this.tech_.buffered()
                    , s = En(e, t);
                if (s.length && t + 3 <= s.end(0)) {
                    this.resetTimeUpdate_(),
                        this.tech_.setCurrentTime(t),
                        this.logger_(`Stopped at ${t} while inside a buffered region [${s.start(0)} -> ${s.end(0)}]. Attempting to resume playback by seeking to the current time.`),
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-unknown-waiting"
                        });
                    return
                }
            }
            techWaiting_() {
                const t = this.seekable()
                    , e = this.tech_.currentTime();
                if (this.tech_.seeking())
                    return !0;
                if (this.beforeSeekableWindow_(t, e)) {
                    const o = t.end(t.length - 1);
                    return this.logger_(`Fell out of live window at time ${e}. Seeking to live point (seekable end) ${o}`),
                        this.resetTimeUpdate_(),
                        this.tech_.setCurrentTime(o),
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-live-resync"
                        }),
                        !0
                }
                const s = this.tech_.vhs.playlistController_.sourceUpdater_
                    , r = this.tech_.buffered();
                if (this.videoUnderflow_({
                    audioBuffered: s.audioBuffered(),
                    videoBuffered: s.videoBuffered(),
                    currentTime: e
                }))
                    return this.resetTimeUpdate_(),
                        this.tech_.setCurrentTime(e),
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-video-underflow"
                        }),
                        !0;
                const a = Cl(r, e);
                return a.length > 0 ? (this.logger_(`Stopped at ${e} and seeking to ${a.start(0)}`),
                    this.resetTimeUpdate_(),
                    this.skipTheGap_(e),
                    !0) : !1
            }
            afterSeekableWindow_(t, e, s, r = !1) {
                if (!t.length)
                    return !1;
                let n = t.end(t.length - 1) + ss;
                const a = !s.endList
                    , o = typeof s.partTargetDuration == "number";
                return a && (o || r) && (n = t.end(t.length - 1) + s.targetDuration * 3),
                    e > n
            }
            beforeSeekableWindow_(t, e) {
                return !!(t.length && t.start(0) > 0 && e < t.start(0) - this.liveRangeSafeTimeDelta)
            }
            videoUnderflow_({ videoBuffered: t, audioBuffered: e, currentTime: s }) {
                if (!t)
                    return;
                let r;
                if (t.length && e.length) {
                    const n = En(t, s - 3)
                        , a = En(t, s)
                        , o = En(e, s);
                    o.length && !a.length && n.length && (r = {
                        start: n.end(0),
                        end: o.end(0)
                    })
                } else
                    Cl(t, s).length || (r = this.gapFromVideoUnderflow_(t, s));
                return r ? (this.logger_(`Encountered a gap in video from ${r.start} to ${r.end}. Seeking to current time ${s}`),
                    !0) : !1
            }
            skipTheGap_(t) {
                const e = this.tech_.buffered()
                    , s = this.tech_.currentTime()
                    , r = Cl(e, s);
                this.resetTimeUpdate_(),
                    !(r.length === 0 || s !== t) && (this.logger_("skipTheGap_:", "currentTime:", s, "scheduled currentTime:", t, "nextRange start:", r.start(0)),
                        this.tech_.setCurrentTime(r.start(0) + Ks),
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-gap-skip"
                        }))
            }
            gapFromVideoUnderflow_(t, e) {
                const s = KT(t);
                for (let r = 0; r < s.length; r++) {
                    const n = s.start(r)
                        , a = s.end(r);
                    if (e - n < 4 && e - n > 2)
                        return {
                            start: n,
                            end: a
                        }
                }
                return null
            }
        }
        , ub = {
            errorInterval: 30,
            getSource(t) {
                const s = this.tech({
                    IWillNotUseThisInPlugins: !0
                }).currentSource_ || this.currentSource();
                return t(s)
            }
        }, tg = function (t, e) {
            let s = 0
                , r = 0;
            const n = Re(ub, e);
            t.ready(() => {
                t.trigger({
                    type: "usage",
                    name: "vhs-error-reload-initialized"
                })
            }
            );
            const a = function () {
                r && t.currentTime(r)
            }
                , o = function (v) {
                    v != null && (r = t.duration() !== 1 / 0 && t.currentTime() || 0,
                        t.one("loadedmetadata", a),
                        t.src(v),
                        t.trigger({
                            type: "usage",
                            name: "vhs-error-reload"
                        }),
                        t.play())
                }
                , u = function () {
                    if (Date.now() - s < n.errorInterval * 1e3) {
                        t.trigger({
                            type: "usage",
                            name: "vhs-error-reload-canceled"
                        });
                        return
                    }
                    if (!n.getSource || typeof n.getSource != "function") {
                        U.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
                        return
                    }
                    return s = Date.now(),
                        n.getSource.call(t, o)
                }
                , c = function () {
                    t.off("loadedmetadata", a),
                        t.off("error", u),
                        t.off("dispose", c)
                }
                , f = function (v) {
                    c(),
                        tg(t, v)
                };
            t.on("error", u),
                t.on("dispose", c),
                t.reloadSourceOnError = f
        }, hb = function (t) {
            tg(this, t)
        }, ig = "3.9.0", db = "7.0.2", cb = "1.3.0", fb = "7.1.0", pb = "4.0.1", Je = {
            PlaylistLoader: An,
            Playlist: si,
            utils: E2,
            STANDARD_PLAYLIST_SELECTOR: Bm,
            INITIAL_PLAYLIST_SELECTOR: h1,
            lastBandwidthSelector: Bm,
            movingAverageBandwidthSelector: l1,
            comparePlaylistBandwidth: Pd,
            comparePlaylistResolution: o1,
            xhr: cm()
        };
    Object.keys(mt).forEach(t => {
        Object.defineProperty(Je, t, {
            get() {
                return U.log.warn(`using Vhs.${t} is UNSAFE be sure you know what you are doing`),
                    mt[t]
            },
            set(e) {
                if (U.log.warn(`using Vhs.${t} is UNSAFE be sure you know what you are doing`),
                    typeof e != "number" || e < 0) {
                    U.log.warn(`value of Vhs.${t} must be greater than or equal to 0`);
                    return
                }
                mt[t] = e
            }
        })
    }
    );
    var sg = "videojs-vhs"
        , rg = function (t, e) {
            const s = e.media();
            let r = -1;
            for (let n = 0; n < t.length; n++)
                if (t[n].id === s.id) {
                    r = n;
                    break
                }
            t.selectedIndex_ = r,
                t.trigger({
                    selectedIndex: r,
                    type: "change"
                })
        }
        , mb = function (t, e) {
            e.representations().forEach(s => {
                t.addQualityLevel(s)
            }
            ),
                rg(t, e.playlists)
        };
    Je.canPlaySource = function () {
        return U.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.")
    }
        ;
    var gb = (t, e, s) => {
        if (!t)
            return t;
        let r = {};
        e && e.attributes && e.attributes.CODECS && (r = Dl(Xi(e.attributes.CODECS))),
            s && s.attributes && s.attributes.CODECS && (r.audio = s.attributes.CODECS);
        const n = ma(r.video)
            , a = ma(r.audio)
            , o = {};
        for (const u in t)
            o[u] = {},
                a && (o[u].audioContentType = a),
                n && (o[u].videoContentType = n),
                e.contentProtection && e.contentProtection[u] && e.contentProtection[u].pssh && (o[u].pssh = e.contentProtection[u].pssh),
                typeof t[u] == "string" && (o[u].url = t[u]);
        return Re(t, o)
    }
        , vb = (t, e) => t.reduce((s, r) => {
            if (!r.contentProtection)
                return s;
            const n = e.reduce((a, o) => {
                const u = r.contentProtection[o];
                return u && u.pssh && (a[o] = {
                    pssh: u.pssh
                }),
                    a
            }
                , {});
            return Object.keys(n).length && s.push(n),
                s
        }
            , [])
        , yb = ({ player: t, sourceKeySystems: e, audioMedia: s, mainPlaylists: r }) => {
            if (!t.eme.initializeMediaKeys)
                return Promise.resolve();
            const n = s ? r.concat([s]) : r
                , a = vb(n, Object.keys(e))
                , o = []
                , u = [];
            return a.forEach(c => {
                u.push(new Promise((f, v) => {
                    t.tech_.one("keysessioncreated", f)
                }
                )),
                    o.push(new Promise((f, v) => {
                        t.eme.initializeMediaKeys({
                            keySystems: c
                        }, T => {
                            if (T) {
                                v(T);
                                return
                            }
                            f()
                        }
                        )
                    }
                    ))
            }
            ),
                Promise.race([Promise.all(o), Promise.race(u)])
        }
        , _b = ({ player: t, sourceKeySystems: e, media: s, audioMedia: r }) => {
            const n = gb(e, s, r);
            return n ? (t.currentSource().keySystems = n,
                n && !t.eme ? (U.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin"),
                    !1) : !0) : !1
        }
        , ng = () => {
            if (!O.default.localStorage)
                return null;
            const t = O.default.localStorage.getItem(sg);
            if (!t)
                return null;
            try {
                return JSON.parse(t)
            } catch (e) {
                return null
            }
        }
        , Tb = t => {
            if (!O.default.localStorage)
                return !1;
            let e = ng();
            e = e ? Re(e, t) : t;
            try {
                O.default.localStorage.setItem(sg, JSON.stringify(e))
            } catch (s) {
                return !1
            }
            return e
        }
        , bb = t => t.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0 ? JSON.parse(t.substring(t.indexOf(",") + 1)) : t
        , ag = (t, e) => {
            t._requestCallbackSet || (t._requestCallbackSet = new Set),
                t._requestCallbackSet.add(e)
        }
        , og = (t, e) => {
            t._responseCallbackSet || (t._responseCallbackSet = new Set),
                t._responseCallbackSet.add(e)
        }
        , lg = (t, e) => {
            t._requestCallbackSet && (t._requestCallbackSet.delete(e),
                t._requestCallbackSet.size || delete t._requestCallbackSet)
        }
        , ug = (t, e) => {
            t._responseCallbackSet && (t._responseCallbackSet.delete(e),
                t._responseCallbackSet.size || delete t._responseCallbackSet)
        }
        ;
    Je.supportsNativeHls = function () {
        if (!le.default || !le.default.createElement)
            return !1;
        const t = le.default.createElement("video");
        return U.getTech("Html5").isSupported() ? ["application/vnd.apple.mpegurl", "audio/mpegurl", "audio/x-mpegurl", "application/x-mpegurl", "video/x-mpegurl", "video/mpegurl", "application/mpegurl"].some(function (s) {
            return /maybe|probably/i.test(t.canPlayType(s))
        }) : !1
    }(),
        Je.supportsNativeDash = function () {
            return !le.default || !le.default.createElement || !U.getTech("Html5").isSupported() ? !1 : /maybe|probably/i.test(le.default.createElement("video").canPlayType("application/dash+xml"))
        }(),
        Je.supportsTypeNatively = t => t === "hls" ? Je.supportsNativeHls : t === "dash" ? Je.supportsNativeDash : !1,
        Je.isSupported = function () {
            return U.log.warn("VHS is no longer a tech. Please remove it from your player's techOrder.")
        }
        ,
        Je.xhr.onRequest = function (t) {
            ag(Je.xhr, t)
        }
        ,
        Je.xhr.onResponse = function (t) {
            og(Je.xhr, t)
        }
        ,
        Je.xhr.offRequest = function (t) {
            lg(Je.xhr, t)
        }
        ,
        Je.xhr.offResponse = function (t) {
            ug(Je.xhr, t)
        }
        ;
    var Eb = U.getComponent("Component")
        , hg = class extends Eb {
            constructor(t, e, s) {
                if (super(e, s.vhs),
                    typeof s.initialBandwidth == "number" && (this.options_.bandwidth = s.initialBandwidth),
                    this.logger_ = Ci("VhsHandler"),
                    e.options_ && e.options_.playerId) {
                    const r = U.getPlayer(e.options_.playerId);
                    this.player_ = r
                }
                if (this.tech_ = e,
                    this.source_ = t,
                    this.stats = {},
                    this.ignoreNextSeekingEvent_ = !1,
                    this.setOptions_(),
                    this.options_.overrideNative && e.overrideNativeAudioTracks && e.overrideNativeVideoTracks)
                    e.overrideNativeAudioTracks(!0),
                        e.overrideNativeVideoTracks(!0);
                else if (this.options_.overrideNative && (e.featuresNativeVideoTracks || e.featuresNativeAudioTracks))
                    throw new Error("Overriding native VHS requires emulated tracks. See https://git.io/vMpjB");
                this.on(le.default, ["fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange"], r => {
                    const n = le.default.fullscreenElement || le.default.webkitFullscreenElement || le.default.mozFullScreenElement || le.default.msFullscreenElement;
                    n && n.contains(this.tech_.el()) ? this.playlistController_.fastQualityChange_() : this.playlistController_.checkABR_()
                }
                ),
                    this.on(this.tech_, "seeking", function () {
                        if (this.ignoreNextSeekingEvent_) {
                            this.ignoreNextSeekingEvent_ = !1;
                            return
                        }
                        this.setCurrentTime(this.tech_.currentTime())
                    }),
                    this.on(this.tech_, "error", function () {
                        this.tech_.error() && this.playlistController_ && this.playlistController_.pauseLoading()
                    }),
                    this.on(this.tech_, "play", this.play)
            }
            setOptions_(t = {}) {
                if (this.options_ = Re(this.options_, t),
                    this.options_.withCredentials = this.options_.withCredentials || !1,
                    this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions !== !1,
                    this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || !1,
                    this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage < "u" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || !1,
                    this.options_.useForcedSubtitles = this.options_.useForcedSubtitles || !1,
                    this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || !1,
                    this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || !1,
                    this.options_.customTagParsers = this.options_.customTagParsers || [],
                    this.options_.customTagMappers = this.options_.customTagMappers || [],
                    this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || !1,
                    this.options_.llhls = this.options_.llhls !== !1,
                    this.options_.bufferBasedABR = this.options_.bufferBasedABR || !1,
                    typeof this.options_.playlistExclusionDuration != "number" && (this.options_.playlistExclusionDuration = 60),
                    typeof this.options_.bandwidth != "number" && this.options_.useBandwidthFromLocalStorage) {
                    const e = ng();
                    e && e.bandwidth && (this.options_.bandwidth = e.bandwidth,
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-bandwidth-from-local-storage"
                        })),
                        e && e.throughput && (this.options_.throughput = e.throughput,
                            this.tech_.trigger({
                                type: "usage",
                                name: "vhs-throughput-from-local-storage"
                            }))
                }
                typeof this.options_.bandwidth != "number" && (this.options_.bandwidth = mt.INITIAL_BANDWIDTH),
                    this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === mt.INITIAL_BANDWIDTH,
                    ["withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useForcedSubtitles", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector"].forEach(e => {
                        typeof this.source_[e] < "u" && (this.options_[e] = this.source_[e])
                    }
                    ),
                    this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions,
                    this.useDevicePixelRatio = this.options_.useDevicePixelRatio
            }
            setOptions(t = {}) {
                this.setOptions_(t)
            }
            src(t, e) {
                if (!t)
                    return;
                this.setOptions_(),
                    this.options_.src = bb(this.source_.src),
                    this.options_.tech = this.tech_,
                    this.options_.externVhs = Je,
                    this.options_.sourceType = Nc(e),
                    this.options_.seekTo = n => {
                        this.tech_.setCurrentTime(n)
                    }
                    ,
                    this.playlistController_ = new rb(this.options_);
                const s = Re({
                    liveRangeSafeTimeDelta: ss
                }, this.options_, {
                    seekable: () => this.seekable(),
                    media: () => this.playlistController_.media(),
                    playlistController: this.playlistController_
                });
                this.playbackWatcher_ = new lb(s),
                    this.playlistController_.on("error", () => {
                        const n = U.players[this.tech_.options_.playerId];
                        let a = this.playlistController_.error;
                        typeof a == "object" && !a.code ? a.code = 3 : typeof a == "string" && (a = {
                            message: a,
                            code: 3
                        }),
                            n.error(a)
                    }
                    );
                const r = this.options_.bufferBasedABR ? Je.movingAverageBandwidthSelector(.55) : Je.STANDARD_PLAYLIST_SELECTOR;
                this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : r.bind(this),
                    this.playlistController_.selectInitialPlaylist = Je.INITIAL_PLAYLIST_SELECTOR.bind(this),
                    this.playlists = this.playlistController_.mainPlaylistLoader_,
                    this.mediaSource = this.playlistController_.mediaSource,
                    Object.defineProperties(this, {
                        selectPlaylist: {
                            get() {
                                return this.playlistController_.selectPlaylist
                            },
                            set(n) {
                                this.playlistController_.selectPlaylist = n.bind(this)
                            }
                        },
                        throughput: {
                            get() {
                                return this.playlistController_.mainSegmentLoader_.throughput.rate
                            },
                            set(n) {
                                this.playlistController_.mainSegmentLoader_.throughput.rate = n,
                                    this.playlistController_.mainSegmentLoader_.throughput.count = 1
                            }
                        },
                        bandwidth: {
                            get() {
                                let n = this.playlistController_.mainSegmentLoader_.bandwidth;
                                const a = O.default.navigator.connection || O.default.navigator.mozConnection || O.default.navigator.webkitConnection
                                    , o = 1e7;
                                if (this.options_.useNetworkInformationApi && a) {
                                    const u = a.downlink * 1e3 * 1e3;
                                    u >= o && n >= o ? n = Math.max(n, u) : n = u
                                }
                                return n
                            },
                            set(n) {
                                this.playlistController_.mainSegmentLoader_.bandwidth = n,
                                    this.playlistController_.mainSegmentLoader_.throughput = {
                                        rate: 0,
                                        count: 0
                                    }
                            }
                        },
                        systemBandwidth: {
                            get() {
                                const n = 1 / (this.bandwidth || 1);
                                let a;
                                return this.throughput > 0 ? a = 1 / this.throughput : a = 0,
                                    Math.floor(1 / (n + a))
                            },
                            set() {
                                U.log.error('The "systemBandwidth" property is read-only')
                            }
                        }
                    }),
                    this.options_.bandwidth && (this.bandwidth = this.options_.bandwidth),
                    this.options_.throughput && (this.throughput = this.options_.throughput),
                    Object.defineProperties(this.stats, {
                        bandwidth: {
                            get: () => this.bandwidth || 0,
                            enumerable: !0
                        },
                        mediaRequests: {
                            get: () => this.playlistController_.mediaRequests_() || 0,
                            enumerable: !0
                        },
                        mediaRequestsAborted: {
                            get: () => this.playlistController_.mediaRequestsAborted_() || 0,
                            enumerable: !0
                        },
                        mediaRequestsTimedout: {
                            get: () => this.playlistController_.mediaRequestsTimedout_() || 0,
                            enumerable: !0
                        },
                        mediaRequestsErrored: {
                            get: () => this.playlistController_.mediaRequestsErrored_() || 0,
                            enumerable: !0
                        },
                        mediaTransferDuration: {
                            get: () => this.playlistController_.mediaTransferDuration_() || 0,
                            enumerable: !0
                        },
                        mediaBytesTransferred: {
                            get: () => this.playlistController_.mediaBytesTransferred_() || 0,
                            enumerable: !0
                        },
                        mediaSecondsLoaded: {
                            get: () => this.playlistController_.mediaSecondsLoaded_() || 0,
                            enumerable: !0
                        },
                        mediaAppends: {
                            get: () => this.playlistController_.mediaAppends_() || 0,
                            enumerable: !0
                        },
                        mainAppendsToLoadedData: {
                            get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,
                            enumerable: !0
                        },
                        audioAppendsToLoadedData: {
                            get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,
                            enumerable: !0
                        },
                        appendsToLoadedData: {
                            get: () => this.playlistController_.appendsToLoadedData_() || 0,
                            enumerable: !0
                        },
                        timeToLoadedData: {
                            get: () => this.playlistController_.timeToLoadedData_() || 0,
                            enumerable: !0
                        },
                        buffered: {
                            get: () => Sr(this.tech_.buffered()),
                            enumerable: !0
                        },
                        currentTime: {
                            get: () => this.tech_.currentTime(),
                            enumerable: !0
                        },
                        currentSource: {
                            get: () => this.tech_.currentSource_,
                            enumerable: !0
                        },
                        currentTech: {
                            get: () => this.tech_.name_,
                            enumerable: !0
                        },
                        duration: {
                            get: () => this.tech_.duration(),
                            enumerable: !0
                        },
                        main: {
                            get: () => this.playlists.main,
                            enumerable: !0
                        },
                        playerDimensions: {
                            get: () => this.tech_.currentDimensions(),
                            enumerable: !0
                        },
                        seekable: {
                            get: () => Sr(this.tech_.seekable()),
                            enumerable: !0
                        },
                        timestamp: {
                            get: () => Date.now(),
                            enumerable: !0
                        },
                        videoPlaybackQuality: {
                            get: () => this.tech_.getVideoPlaybackQuality(),
                            enumerable: !0
                        }
                    }),
                    this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_)),
                    this.tech_.on("bandwidthupdate", () => {
                        this.options_.useBandwidthFromLocalStorage && Tb({
                            bandwidth: this.bandwidth,
                            throughput: Math.round(this.throughput)
                        })
                    }
                    ),
                    this.playlistController_.on("selectedinitialmedia", () => {
                        ob(this)
                    }
                    ),
                    this.playlistController_.sourceUpdater_.on("createdsourcebuffers", () => {
                        this.setupEme_()
                    }
                    ),
                    this.on(this.playlistController_, "progress", function () {
                        this.tech_.trigger("progress")
                    }),
                    this.on(this.playlistController_, "firstplay", function () {
                        this.ignoreNextSeekingEvent_ = !0
                    }),
                    this.setupQualityLevels_(),
                    this.tech_.el() && (this.mediaSourceUrl_ = O.default.URL.createObjectURL(this.playlistController_.mediaSource),
                        this.tech_.src(this.mediaSourceUrl_))
            }
            createKeySessions_() {
                const t = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
                this.logger_("waiting for EME key session creation"),
                    yb({
                        player: this.player_,
                        sourceKeySystems: this.source_.keySystems,
                        audioMedia: t && t.media(),
                        mainPlaylists: this.playlists.main.playlists
                    }).then(() => {
                        this.logger_("created EME key session"),
                            this.playlistController_.sourceUpdater_.initializedEme()
                    }
                    ).catch(e => {
                        this.logger_("error while creating EME key session", e),
                            this.player_.error({
                                message: "Failed to initialize media keys for EME",
                                code: 3
                            })
                    }
                    )
            }
            handleWaitingForKey_() {
                this.logger_("waitingforkey fired, attempting to create any new key sessions"),
                    this.createKeySessions_()
            }
            setupEme_() {
                const t = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader
                    , e = _b({
                        player: this.player_,
                        sourceKeySystems: this.source_.keySystems,
                        media: this.playlists.media(),
                        audioMedia: t && t.media()
                    });
                if (this.player_.tech_.on("keystatuschange", s => {
                    this.playlistController_.updatePlaylistByKeyStatus(s.keyId, s.status)
                }
                ),
                    this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this),
                    this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_),
                    !e) {
                    this.playlistController_.sourceUpdater_.initializedEme();
                    return
                }
                this.createKeySessions_()
            }
            setupQualityLevels_() {
                const t = U.players[this.tech_.options_.playerId];
                !t || !t.qualityLevels || this.qualityLevels_ || (this.qualityLevels_ = t.qualityLevels(),
                    this.playlistController_.on("selectedinitialmedia", () => {
                        mb(this.qualityLevels_, this)
                    }
                    ),
                    this.playlists.on("mediachange", () => {
                        rg(this.qualityLevels_, this.playlists)
                    }
                    ))
            }
            static version() {
                return {
                    "@videojs/http-streaming": ig,
                    "mux.js": db,
                    "mpd-parser": cb,
                    "m3u8-parser": fb,
                    "aes-decrypter": pb
                }
            }
            version() {
                return this.constructor.version()
            }
            canChangeType() {
                return Wm.canChangeType()
            }
            play() {
                this.playlistController_.play()
            }
            setCurrentTime(t) {
                this.playlistController_.setCurrentTime(t)
            }
            duration() {
                return this.playlistController_.duration()
            }
            seekable() {
                return this.playlistController_.seekable()
            }
            dispose() {
                this.playbackWatcher_ && this.playbackWatcher_.dispose(),
                    this.playlistController_ && this.playlistController_.dispose(),
                    this.qualityLevels_ && this.qualityLevels_.dispose(),
                    this.tech_ && this.tech_.vhs && delete this.tech_.vhs,
                    this.mediaSourceUrl_ && O.default.URL.revokeObjectURL && (O.default.URL.revokeObjectURL(this.mediaSourceUrl_),
                        this.mediaSourceUrl_ = null),
                    this.tech_ && this.tech_.off("waitingforkey", this.handleWaitingForKey_),
                    super.dispose()
            }
            convertToProgramTime(t, e) {
                return x2({
                    playlist: this.playlistController_.media(),
                    time: t,
                    callback: e
                })
            }
            seekToProgramTime(t, e, s = !0, r = 2) {
                return vm({
                    programTime: t,
                    playlist: this.playlistController_.media(),
                    retryCount: r,
                    pauseAfterSeek: s,
                    seekTo: this.options_.seekTo,
                    tech: this.options_.tech,
                    callback: e
                })
            }
            setupXhrHooks_() {
                this.xhr.onRequest = t => {
                    ag(this.xhr, t)
                }
                    ,
                    this.xhr.onResponse = t => {
                        og(this.xhr, t)
                    }
                    ,
                    this.xhr.offRequest = t => {
                        lg(this.xhr, t)
                    }
                    ,
                    this.xhr.offResponse = t => {
                        ug(this.xhr, t)
                    }
                    ,
                    this.player_.trigger("xhr-hooks-ready")
            }
        }
        , Ll = {
            name: "videojs-http-streaming",
            VERSION: ig,
            canHandleSource(t, e = {}) {
                const s = Re(U.options, e);
                return Ll.canPlayType(t.type, s)
            },
            handleSource(t, e, s = {}) {
                const r = Re(U.options, s);
                return e.vhs = new hg(t, e, r),
                    e.vhs.xhr = cm(),
                    e.vhs.setupXhrHooks_(),
                    e.vhs.src(t.src, t.type),
                    e.vhs
            },
            canPlayType(t, e) {
                const s = Nc(t);
                if (!s)
                    return "";
                const r = Ll.getOverrideNative(e);
                return !Je.supportsTypeNatively(s) || r ? "maybe" : ""
            },
            getOverrideNative(t = {}) {
                const { vhs: e = {} } = t
                    , s = !(U.browser.IS_ANY_SAFARI || U.browser.IS_IOS)
                    , { overrideNative: r = s } = e;
                return r
            }
        }
        , Sb = () => Ho("avc1.4d400d,mp4a.40.2");
    Sb() && U.getTech("Html5").registerSourceHandler(Ll, 0),
        U.VhsHandler = hg,
        U.VhsSourceHandler = Ll,
        U.Vhs = Je,
        U.use || U.registerComponent("Vhs", Je),
        U.options.vhs = U.options.vhs || {},
        (!U.getPlugin || !U.getPlugin("reloadSourceOnError")) && U.registerPlugin("reloadSourceOnError", hb);
    var Cb = U.getPlugin("plugin")
        , Ab = (mg = class extends Cb {
            constructor(e, s) {
                super(e, s);
                j(this, bt, void 0);
                j(this, st, void 0);
                V(this, bt, U.dom)
            }
            remove() {
                this.player.controlBar.show(),
                    h(this, st) && h(this, st).remove()
            }
            showCharge(e, s) {
                this.remove(),
                    V(this, st, h(this, bt).createEl("div", {
                        className: "video-cover-wrapper"
                    }));
                let r = h(this, bt).createEl("a", {
                    className: "cancel",
                    href: "#",
                    innerHTML: '<i class="material-icons">close</i>'
                })
                    , n = h(this, bt).createEl("div", {
                        className: "video-verify",
                        innerHTML: `<div class="verify_title">${e}</div><a class="bluebtn cta-btn" href="https://ani.gamer.com.tw/animePay.php" target="_blank"><p>\u4ED8\u8CBB\u65B9\u6848</p></a>`
                    });
                s && (h(this, st).appendChild(r),
                    r.onclick = () => {
                        this.remove(),
                            s()
                    }
                ),
                    h(this, st).appendChild(n),
                    this.player.el().appendChild(h(this, st)),
                    this.player.controlBar.hide()
            }
            showLogin(e, s) {
                this.remove(),
                    V(this, st, h(this, bt).createEl("div", {
                        className: "video-cover-wrapper"
                    }));
                let r = h(this, bt).createEl("a", {
                    className: "cancel",
                    href: "#",
                    innerHTML: '<i class="material-icons">close</i>'
                })
                    , n = h(this, bt).createEl("div", {
                        className: "video-verify",
                        innerHTML: `<div class="verify_title">${e}</div><div class="login_btns"><a class="login" href="https://user.gamer.com.tw/login.php"><div class="login_choose_title">\u5DF2\u6709\u5E33\u865F</div><p><i class="material-icons">person</i>\u767B\u5165</p></a><a class="reg" href="https://user.gamer.com.tw/regS1.php"><div class="login_choose_title">\u9084\u6C92\u6709\u5E33\u865F\uFF1F</div><p><i class="material-icons">person_add</i>\u8A3B\u518A</p><b>\u975E\u5E38\u7C21\u55AE\uFF01</b></a></div>`
                    });
                s && (h(this, st).appendChild(r),
                    r.onclick = () => {
                        this.remove(),
                            s()
                    }
                ),
                    n.querySelector("a.login").addEventListener("click", a => {
                        window.User.Login.requireLoginIframe() && location.reload(),
                            a.preventDefault()
                    }
                    ),
                    h(this, st).appendChild(n),
                    this.player.el().appendChild(h(this, st)),
                    this.player.controlBar.hide()
            }
            showAgeValidateOnly(e, s) {
                this.remove(),
                    V(this, st, h(this, bt).createEl("div", {
                        className: "video-cover-wrapper"
                    }));
                let r = h(this, bt).createEl("a", {
                    className: "cancel",
                    href: "#",
                    innerHTML: '<i class="material-icons">close</i>'
                })
                    , n = h(this, bt).createEl("div", {
                        className: "video-verify",
                        innerHTML: `<div class="verify_title">${e}</div><a class="bluebtn cta-btn" href="https://ani.gamer.com.tw/animeAgeValidate.php" target="_blank"><p>\u524D\u5F80\u5E74\u9F61\u9A57\u8B49</p></a>`
                    });
                s && (h(this, st).appendChild(r),
                    r.onclick = () => {
                        this.remove(),
                            s()
                    }
                ),
                    h(this, st).appendChild(n),
                    this.player.el().appendChild(h(this, st)),
                    this.player.controlBar.hide()
            }
            showAgeValidateOrEvenCharge(e, s) {
                this.remove(),
                    V(this, st, h(this, bt).createEl("div", {
                        className: "video-cover-wrapper"
                    }));
                let r = h(this, bt).createEl("a", {
                    className: "cancel",
                    href: "#",
                    innerHTML: '<i class="material-icons">close</i>'
                })
                    , n = e.details.errorType & 1 ? "\u524D\u5F80\u5E74\u9F61\u9A57\u8B49" : "\u4ED8\u8CBB\u65B9\u6848"
                    , a = "https://ani.gamer.com.tw/" + (e.details.errorType & 1 ? "animeAgeValidate.php" : "animePay.php")
                    , o = e.details.extraMessage.replace(/(非付費會員|未通過年齡驗證)/g, "<span class='emphasize'>$1</span>")
                    , u = h(this, bt).createEl("div", {
                        className: "video-verify",
                        innerHTML: `<div class="verify_title">${e.message}<br>${o}</div><a class="bluebtn cta-btn" href="${a}" target="_blank"><p>${n}</p></a>`
                    });
                s && (h(this, st).appendChild(r),
                    r.onclick = () => {
                        this.remove(),
                            s()
                    }
                ),
                    h(this, st).appendChild(u),
                    this.player.el().appendChild(h(this, st)),
                    this.player.controlBar.hide()
            }
            showError(e) {
                let s = h(this, bt).createEl("div", {
                    className: "vjs-error",
                    innerHTML: `<div class="vjs-error-display"><div>${e}</div></div>`
                });
                document.getElementsByClassName("video")[0].appendChild(s),
                    this.player.dispose()
            }
        }
            ,
            bt = new WeakMap,
            st = new WeakMap,
            mg);
    U.registerPlugin("animeMask", Ab);
    var wb = U.getPlugin("plugin")
        , Db = (gg = class extends wb {
            constructor(e, s) {
                super(e, s);
                j(this, Fl);
                j(this, Ul);
                s.namespace = s.namespace || "VIDEOJS",
                    s.key = s.namespace + "_BP",
                    this.options = s
            }
            get(e) {
                let s = JSON.parse(te(this, Fl, kv).call(this));
                return s !== null && e == s.videoSn ? s : {}
            }
            startRecord(e) {
                this.intervalId = this.player.setInterval(() => {
                    if (this.player.currentTime() > 0 && !this.player.paused()) {
                        let s = new Date
                            , r = JSON.stringify({
                                videoSn: e,
                                breakPoint: this.player.currentTime(),
                                watchTime: s.getFullYear() + "-" + (s.getMonth() + 1).toString().padStart(2, "0") + "-" + s.getDate().toString().padStart(2, "0") + " " + s.getHours().toString().padStart(2, "0") + ":" + s.getMinutes().toString().padStart(2, "0") + ":" + s.getSeconds().toString().padStart(2, "0")
                            });
                        te(this, Ul, xv).call(this, r)
                    }
                }
                    , 5e3)
            }
            stop() {
                this.intervalId !== null && (this.player.clearInterval(this.intervalId),
                    this.intervalId = null)
            }
        }
            ,
            Fl = new WeakSet,
            kv = function () {
                return window.localStorage.getItem(this.options.key)
            }
            ,
            Ul = new WeakSet,
            xv = function (e) {
                return window.localStorage.setItem(this.options.key, e)
            }
            ,
            gg);
    U.registerPlugin("breakPoint", Db);
    var xn = "https://ani.gamer.com.tw"
        , Mi = "https://api.gamer.com.tw"
        , kb = class {
            constructor() { }
            getCsrfToken() {
                return fetch("/ajax/getCSRFToken.php", {
                    cache: "no-cache"
                }).then(t => t.text())
            }
            danmuSet(t) {
                return this.getCsrfToken().then(e => {
                    t.token = e;
                    let s = new URLSearchParams(t);
                    return fetch("/ajax/danmuSet.php", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
                        },
                        body: s.toString()
                    }).then(r => r.json())
                }
                )
            }
            danmuGet(t, e = Fd, s = 0) {
                let r = new URL("/anime/v1/danmu.php", Mi);
                return r.searchParams.append("videoSn", t),
                    r.searchParams.append("geo", e.join(",")),
                    s != 0 && r.searchParams.append("limit", s),
                    fetch(r, {
                        method: "GET",
                        credentials: "include"
                    }).then(n => n.json())
            }
            blackUser(t, e) {
                let s = new URL("/ajax/blackUser.php", xn);
                return this.getCsrfToken().then(r => {
                    let n = new URLSearchParams({
                        fid: e,
                        cno: 0,
                        token: r,
                        vidoeSn: t
                    });
                    return fetch(s, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
                        },
                        body: n.toString()
                    }).then(a => a.json())
                }
                )
            }
            checkLock(t, e) {
                let s = new URL("/ajax/checklock.php", xn);
                return s.searchParams.append("device", e),
                    s.searchParams.append("sn", t),
                    fetch(s)
            }
            videoStart(t) {
                let e = new URL("/ajax/checklock.php", xn);
                return e.searchParams.append("sn", t),
                    fetch(e)
            }
            accuseDanmu(t) {
                let e = new URL("/mobile_app/anime/v1/danmu_accuse.php", Mi);
                return this.getCsrfToken().then(s => {
                    let r = new URLSearchParams({
                        token: s,
                        "danmaku_sn[]": [t]
                    });
                    return fetch(e, {
                        method: "POST",
                        mode: "cors",
                        headers: {
                            "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8"
                        },
                        credentials: "include",
                        body: r.toString()
                    }).then(n => n.json())
                }
                )
            }
            getDeviceId(t = "") {
                let e = new URL("/ajax/getdeviceid.php", xn);
                return t && e.searchParams.append("id", t),
                    fetch(e, {
                        credentials: "include"
                    }).then(s => s.json())
            }
            getVideo(t, e = 0, s = 0) {
                let r = new URL("/anime/v1/video.php", Mi);
                return e > 0 && r.searchParams.append("videoSn", e),
                    s > 0 && r.searchParams.append("animeSn", s),
                    fetch(r, {
                        signal: t,
                        credentials: "include"
                    }).then(n => n.json()).catch(n => Promise.reject(n))
            }
            constants() {
                let t = new URL("/mobile_app/anime/v3/constants.php", Mi);
                return fetch(t, {
                    credentials: "include"
                }).then(e => e.json()).catch(e => Promise.reject(e))
            }
            search(t) {
                let e = new URL("/anime/v1/search.php", Mi);
                return e.searchParams.append("kw", t),
                    e.searchParams.append("recordKeyword", 0),
                    fetch(e, {
                        credentials: "include"
                    }).then(s => s.json()).catch(s => Promise.reject(s))
            }
            animeGetQuestion() {
                let t = new URL("/ajax/animeGetQuestion.php", xn);
                return t.searchParams.append("t", Date.now()),
                    fetch(t, {
                        credentials: "include"
                    }).then(e => e.json()).catch(e => Promise.reject(e))
            }
            animeAnsQuestion(t, e) {
                let s = new URL("/ajax/animeAnsQuestion.php", xn)
                    , r = new FormData;
                return r.append("token", t),
                    r.append("ans", e),
                    fetch(s, {
                        method: "POST",
                        credentials: "include",
                        body: r
                    }).then(n => n.json()).catch(n => Promise.reject(n))
            }
            partyCreateRoom(t) {
                let e = new URL("/anime/v1/party_create_room.php", Mi)
                    , s = new FormData
                    , r = new Bahamut.Csrf;
                return r.setCookie(),
                    t.forEach(n => {
                        s.append("videoSn[]", n)
                    }
                    ),
                    fetch(e, {
                        method: "POST",
                        mode: "cors",
                        headers: r.getFetchHeaders(),
                        credentials: "include",
                        body: s
                    }).then(n => n.json()).catch(n => Promise.reject(n))
            }
            partyVideoAdd(t, e) {
                let s = new URL("/anime/v1/party_video_add.php", Mi)
                    , r = new FormData
                    , n = new Bahamut.Csrf;
                return r.append("roomName", t),
                    e.forEach(a => {
                        r.append("videoSn[]", a)
                    }
                    ),
                    n.setCookie(),
                    fetch(s, {
                        method: "POST",
                        mode: "cors",
                        headers: n.getFetchHeaders(),
                        credentials: "include",
                        body: r
                    }).then(a => a.json()).catch(a => Promise.reject(a))
            }
            partyVideoDelete(t, e) {
                let s = new URL("/anime/v1/party_video_delete.php", Mi)
                    , r = new FormData
                    , n = new Bahamut.Csrf;
                return r.append("roomName", t),
                    e.forEach(a => {
                        r.append("videoListId[]", a)
                    }
                    ),
                    n.setCookie(),
                    fetch(s, {
                        method: "POST",
                        mode: "cors",
                        headers: n.getFetchHeaders(),
                        credentials: "include",
                        body: r
                    }).then(a => a.json()).catch(a => Promise.reject(a))
            }
            partyVideoOrderEdit(t, e) {
                let s = new URL("/anime/v1/party_video_order_edit.php", Mi)
                    , r = new FormData
                    , n = new Bahamut.Csrf;
                return r.append("roomName", t),
                    e.forEach(a => {
                        r.append("videoListId[]", a)
                    }
                    ),
                    n.setCookie(),
                    fetch(s, {
                        method: "POST",
                        mode: "cors",
                        headers: n.getFetchHeaders(),
                        credentials: "include",
                        body: r
                    }).then(a => a.json()).catch(a => Promise.reject(a))
            }
            partySetting(t, e = {}) {
                if (e.enableVideoDanmu === void 0 && e.id === void 0 && e.state === void 0 && e.streamingType === void 0)
                    return;
                let s = new URL("/anime/v1/party_setting.php", Mi)
                    , r = new FormData
                    , n = new Bahamut.Csrf;
                n.setCookie();
                let a = n.getFetchHeaders();
                return r.append("roomName", t),
                    e.id !== void 0 && (r.append("videoListId", e.id),
                        r.append("state", e.state)),
                    e.enableVideoDanmu !== void 0 && r.append("enableVideoDanmu", e.enableVideoDanmu),
                    e.streamingType !== void 0 && e.streamingId !== void 0 && (r.append("streamingType", e.streamingType),
                        r.append("streamingId", e.streamingId)),
                    fetch(s, {
                        method: "POST",
                        mode: "cors",
                        headers: a,
                        credentials: "include",
                        body: r
                    }).then(o => o.json()).catch(o => Promise.reject(o))
            }
            partyGetMemberList(t) {
                let e = new URL("/anime/v1/party_member_list.php", Mi)
                    , s = new URLSearchParams({
                        roomName: t
                    });
                e = `${e}?${s}`;
                let r = new Bahamut.Csrf;
                return r.setCookie(),
                    fetch(e, {
                        method: "GET",
                        mode: "cors",
                        headers: r.getFetchHeaders(),
                        credentials: "include"
                    }).then(n => n.json()).catch(n => Promise.reject(n))
            }
        }
        , Ri = new kb
        , Nd = "TW"
        , Bd = "HK"
        , Fd = [Nd, Bd]
        , Ua = {
            MAIN: 0,
            MOVIE: 1,
            OVA: 2,
            MAIN_TW: 3,
            MOVIE_TW: 4,
            OVA_TW: 5
        }
        , Be = {
            QUALITY: "quality",
            VOLUME: "volume",
            VOLUME_MUTE: "mute",
            INDENT: "indent",
            DANMU: "danmu",
            DANMU_OPACITY: "danmu_opacity",
            DANMU_SIZE: "danmu_size",
            DANMU_GEOS: "DANMU_GEOS",
            PARTY_ACTIVE_DELAY: "PARTY_ACTIVE_DELAY",
            PARTY_STREAMING_SETTING: "PARTY_STREAMING_SETTING"
        }
        , Ai = {
            HIDE: 0,
            SHOW: 1,
            PLAYING_AD: 2,
            REMOVE: -1
        }
        , Vt = {
            NORMAL: "normal",
            PARTY: "party",
            PARTY_MODERATOR: "party_moderator",
            AD: "ad",
            SHOW_AGE_GATE: "show_age_gate"
        }
        , Ud = {
            NORMAL: {
                NAME: "NORMAL_AUTOPLAY",
                EPISODE: 4,
                SECOND: 80 * 60
            },
            PARTY: {
                NAME: "PARTY_AUTOPLAY",
                EPISODE: 4,
                SECOND: 80 * 60
            }
        }
        , xb = (vg = class {
            constructor() {
                j(this, Ss, "")
            }
            async get(t = !1) {
                if (h(this, Ss) && !t)
                    return h(this, Ss);
                window.localStorage.getItem("ANIME_deviceid") && V(this, Ss, window.localStorage.getItem("ANIME_deviceid"));
                let e = await Ri.getDeviceId(h(this, Ss));
                return this.set(e.deviceid),
                    h(this, Ss)
            }
            set(t) {
                V(this, Ss, t),
                    window.localStorage.setItem("ANIME_deviceid", t)
            }
        }
            ,
            Ss = new WeakMap,
            vg)
        , Ib = (yg = class {
            constructor() {
                j(this, Pn);
                j(this, jl)
            }
            log(t, ...e) {
                te(this, Pn, ih).call(this, "log", t, ...e)
            }
            warn(t, ...e) {
                te(this, Pn, ih).call(this, "warn", t, ...e)
            }
            error(t, ...e) {
                te(this, Pn, ih).call(this, "error", t, ...e)
            }
        }
            ,
            Pn = new WeakSet,
            ih = function (t, e, ...s) {
                if (e.match(/\%c/g) && !(s && s.length > 0)) {
                    let a = e.match(/\%c/g).length
                        , o = ["color:#5abfc8", "", "color:#ec9f3e", "", "color:#e77d95", ""];
                    s = [];
                    for (var r = 0; r < a; r++)
                        s.push(o[r % o.length])
                }
                let n = [`%c${te(this, jl, Iv).call(this)}	%c${e}`, "color:gray", ""].concat(s);
                switch (t) {
                    case "log":
                    case "warn":
                    case "error":
                        console[t](...n);
                        break;
                    default:
                }
            }
            ,
            jl = new WeakSet,
            Iv = function () {
                let t = new Date;
                return [t.getHours().toString().padStart(2, 0), t.getMinutes().toString().padStart(2, 0), t.getSeconds().toString().padStart(2, 0)].join(":")
            }
            ,
            yg)
        , ja = (Kd = class {
            constructor() { }
            static formatTime(t, e = ":") {
                let s = [Math.floor(t / 3600).toString().padStart(2, "0"), Math.floor(t % 3600 / 60).toString().padStart(2, "0"), Math.floor(t % 60).toString().padStart(2, "0")];
                return s[0] == "00" && (s = s.slice(1)),
                    s.join(e)
            }
            static timeToSeconds(t, e = this.PATTERN_TIME) {
                let s = 0;
                return t = t.match(e),
                    t == null ? t : (t.groups.totalS != null ? s = parseInt(t.groups.totalS) : (t.groups.unitH != null && (s += parseInt(t.groups.unitH) * 3600),
                        t.groups.unitM != null && (s += parseInt(t.groups.unitM) * 60),
                        t.groups.unitS != null && (s += parseInt(t.groups.unitS))),
                        s)
            }
        }
            ,
            Yr(Kd, "PATTERN_TIME", new RegExp("^((?<unitH>\\d+)[:_])?(?<unitM>[0-5]?\\d)[:_](?<unitS>[0-5]\\d)$|^(?<totalS>\\d+)$")),
            Kd)
        , Le = (Xd = class {
            static setItem(t, e) {
                try {
                    return window.localStorage.setItem([this.NAME_SPACE, t].join("_"), e),
                        !0
                } catch (s) {
                    return console.warn(s),
                        !1
                }
            }
            static getItem(t) {
                return window.localStorage.getItem([this.NAME_SPACE, t].join("_"))
            }
        }
            ,
            Yr(Xd, "NAME_SPACE", "ANIME"),
            Xd)
        , Ol = new xb
        , gC = new Ib
        , Pb = U.getPlugin("plugin")
        , Lb = 60
        , Ob = (_g = class extends Pb {
            constructor(e, s) {
                super(e, s);
                j(this, Ln, 0);
                j(this, Cs, -1);
                j(this, dt, {
                    start: 0,
                    end: 0,
                    base: 0,
                    total: 0,
                    counter: 0
                })
            }
            init(e) {
                V(this, Ln, 0),
                    V(this, Cs, e),
                    V(this, dt, {
                        start: 0,
                        end: 0,
                        base: 0,
                        total: 0,
                        counter: 0
                    })
            }
            countTotalWatchTime() {
                if (h(this, Cs) <= 0)
                    return;
                h(this, dt).total >= (h(this, dt).counter + 1) * Lb && (this.sendElapse(),
                    V(this, Ln, h(this, dt).total),
                    h(this, dt).counter++);
                let e = this.player.currentTime();
                !this.player.seeking() && !this.player.paused() && Math.abs(e - h(this, dt).end) < .6 ? h(this, dt).end = e : (h(this, dt).base = h(this, dt).total,
                    h(this, dt).start = h(this, dt).end = e);
                let s = h(this, dt).end - h(this, dt).start;
                h(this, dt).total = h(this, dt).base + s
            }
            videoStateChanged() {
                h(this, Cs) <= 0 || fetch("/ajax/unlock.php?sn=" + h(this, Cs) + "&ttl=" + parseInt(h(this, dt).total, 10))
            }
            async sendElapse() {
                if (h(this, Cs) <= 0)
                    return;
                let e = await Ol.get()
                    , s = Math.abs(this.player.duration() - this.player.currentTime())
                    , r = Math.round(s > 120 ? this.player.currentTime() : -1);
                fetch("/ajax/elapse.php?sn=" + h(this, Cs) + "&device=" + e + "&time=" + r).then(n => n.json()).then(n => {
                    switch (n.state) {
                        case "ok":
                            n.device && Ol.set(n.device);
                            break;
                        case 1:
                            this.player.animeMask().showError("\u5C1A\u672A\u767B\u5165\uFF0C\u8ACB\u9032\u884C\u767B\u5165\u3002");
                            break;
                        case 2:
                            this.player.animeMask().showError('\u932F\u8AA4\u4EE3\u78BC1\uFF0C\u5F71\u7247\u50B3\u8F38\u4E2D\u65B7\uFF0C\u8ACB\u53C3\u8003<a href="https://ani.gamer.com.tw/anime403info.php">\u53EF\u80FD\u539F\u56E0</a>');
                            break;
                        case 3:
                            this.player.animeMask().showError("\u767B\u5165\u72C0\u614B\u7570\u5E38(2)\u3002");
                            break;
                        case 4:
                            this.player.animeMask().showError("\u672C\u670D\u52D9\u540C\u6642\u9593\u5167\u50C5\u63D0\u4F9B\u64AD\u653E\u4E00\u90E8\u5F71\u7247\uFF01");
                            break;
                        case 5:
                            this.player.animeMask().showError("\u767B\u5165\u72C0\u614B\u7570\u5E38(3)\u3002");
                            break;
                        case 6:
                            this.player.animeMask().showError("\u767B\u5165\u72C0\u614B\u7570\u5E38(4)\u3002");
                            break;
                        default:
                            this.player.animeMask().showError("\u5DF2\u5075\u6E2C\u5230\u65B0\u7684\u88DD\u7F6E\u767B\u5165\uFF01<br>\u672C\u670D\u52D9\u540C\u6642\u9593\u5167\u50C5\u5141\u8A31\u4E00\u500B\u88DD\u7F6E\u767B\u5165\u4F7F\u7528\uFF01")
                    }
                }
                )
            }
            getTotalTime() {
                return h(this, Ln)
            }
        }
            ,
            Ln = new WeakMap,
            Cs = new WeakMap,
            dt = new WeakMap,
            _g);
    U.registerPlugin("elapse", Ob);
    var Mb = U.getPlugin("plugin")
        , Rb = (Tg = class extends Mb {
            constructor(e, s) {
                super(e, s);
                j(this, Hl);
                j(this, ql);
                j(this, $l);
                j(this, Va);
                j(this, Vl);
                j(this, _e, {});
                j(this, Et, void 0);
                j(this, As, 0);
                j(this, Xs, 0);
                V(this, Et, U.dom),
                    te(this, Hl, Pv).call(this)
            }
            showQuiz(e) {
                Ri.animeGetQuestion().then(s => {
                    if (s.error)
                        throw new Error(s.error);
                    te(this, ql, Lv).call(this, s, e)
                }
                ).catch(s => {
                    e()
                }
                )
            }
            show(e = "", s = !0, r = !0) {
                te(this, Va, mc).call(this),
                    h(this, _e).titleEl.textContent = e,
                    s && r && te(this, Vl, Mv).call(this),
                    r || h(this, _e).stopAutoPlay.classList.add("vjs-hidden"),
                    s || (h(this, _e).nextEpisode.classList.add("vjs-hidden"),
                        h(this, _e).countDownTitle.textContent = "",
                        h(this, _e).stopAutoPlay.classList.add("vjs-hidden")),
                    h(this, _e).mask.classList.remove("vjs-hidden"),
                    this.player.one(["seeked", "seeking", "playing"], () => {
                        this.hide()
                    }
                    )
            }
            showBreak(e = "", s = !0) {
                te(this, Va, mc).call(this),
                    h(this, _e).mask.classList.remove("vjs-hidden"),
                    h(this, _e).titleEl.textContent = e,
                    s || h(this, _e).replay.classList.add("vjs-hidden"),
                    h(this, _e).countDownTitle.textContent = "\u756B\u9762\u9592\u7F6E\u904E\u4E45\uFF0C\u662F\u5426\u8981\u7E7C\u7E8C\u64AD\u653E\uFF1F",
                    h(this, _e).nextEpisode.querySelector("p").textContent = "\u7E7C\u7E8C\u64AD\u653E",
                    h(this, _e).stopAutoPlay.classList.add("vjs-hidden"),
                    this.player.one(["seeked", "seeking", "playing"], () => {
                        this.hide()
                    }
                    )
            }
            isShowQuiz() {
                return !!h(this, _e).quizWrapper
            }
            hide() {
                h(this, _e).mask.classList.add("vjs-hidden"),
                    clearInterval(h(this, As))
            }
            dispose() {
                clearInterval(h(this, As)),
                    super.dispose()
            }
        }
            ,
            _e = new WeakMap,
            Et = new WeakMap,
            As = new WeakMap,
            Xs = new WeakMap,
            Hl = new WeakSet,
            Pv = function () {
                let e = h(this, Et).createEl("div", {
                    className: "stop vjs-hidden"
                })
                    , s = h(this, Et).createEl("div", {
                        className: "anime_title"
                    })
                    , r = h(this, Et).createEl("div", {
                        className: "replay"
                    });
                r.innerHTML = `
        <div class="replay-col">
            <h5 id="countDownTitle" class="title">\u5012\u6578<span>3</span>\u79D2\u7E7C\u7E8C\u64AD\u653E</h5>
            <div class="icon-list">
                <a id="replay" class="auto-next" role="button"><i class="material-icons-round">replay</i><p>\u91CD\u64AD</p></a>
                <a id="nextEpisode" class="auto-next center-btn" role="button">
                    <i class="material-icons-round next-episode">
                        skip_next
                    </i>
                    <svg width="80" height="80" viewBox="0 0 80 80" version="1.1"  style="transform:rotate(-90deg)">
                        <circle r="38" cx="40" cy="40" fill="transparent" stroke="#ffffff4d" stroke-width="4" stroke-dasharray="238.64" stroke-dashoffset="0"></circle>
                        <circle id="countDownCircle" class="is-countdown" r="38" cx="40" cy="40" stroke="#00b4d8" stroke-width="4" stroke-linecap="round" stroke-dashoffset="238.64" fill="transparent" stroke-dasharray="238.64"></circle>
                    </svg>
                    <p>\u7E7C\u7E8C\u64AD\u653E</p>
                </a>
                <a id="stopAutoPlay" class="auto-next" role="button"><i class="material-icons-round">stop</i><p>\u4E2D\u6B62</p></a>
            </div>
        </div>
        `;
                let n = r.querySelector("#countDownTitle")
                    , a = r.querySelector("#countDownCircle")
                    , o = r.querySelector("#replay");
                o.addEventListener("click", () => {
                    this.player.currentTime(0),
                        this.player.play(),
                        clearInterval(h(this, As))
                }
                );
                let u = r.querySelector("#nextEpisode");
                u.addEventListener("click", v => {
                    v.preventDefault(),
                        this.trigger("nextEpisode"),
                        clearInterval(h(this, As))
                }
                );
                let c = r.querySelector("#stopAutoPlay")
                    , f = c.querySelector("p");
                c.addEventListener("click", () => {
                    a.classList.remove("is-countdown"),
                        c.classList.add("is-disabled"),
                        f.textContent = "\u5DF2\u4E2D\u65B7",
                        n.textContent = "",
                        clearInterval(h(this, As))
                }
                ),
                    e.appendChild(s),
                    e.appendChild(r),
                    h(this, _e).mask = e,
                    h(this, _e).titleEl = s,
                    h(this, _e).replay = o,
                    h(this, _e).countDownTitle = n,
                    h(this, _e).countDownCircle = a,
                    h(this, _e).stopAutoPlay = c,
                    h(this, _e).stopAutoPlayTxt = f,
                    h(this, _e).nextEpisode = u,
                    h(this, _e).nextEpisodeTxt = u.querySelector("p"),
                    this.player.el().appendChild(e)
            }
            ,
            ql = new WeakSet,
            Lv = function (e, s) {
                let r = h(this, Et).createEl("div", {
                    className: "video-cover-wrapper"
                })
                    , n = h(this, Et).createEl("div", {
                        className: "anime-quiz"
                    })
                    , a = h(this, Et).createEl("a", {
                        innerHTML: "<i class='material-icons'>close</i>"
                    }, {
                        href: "javascript: void(0)"
                    });
                a.onclick = T => {
                    T.preventDefault(),
                        r.classList.add("vjs-hidden"),
                        Ri.animeAnsQuestion(e.token, 0),
                        s()
                }
                    ;
                let o = document.createElement("div");
                o.innerHTML = e.question;
                let u = h(this, Et).createEl("p", {
                    textContent: o.textContent + " \uFF08\u4F5C\u8005\uFF1A" + e.userid + "\uFF09"
                })
                    , c = h(this, Et).createEl("div", {
                        className: "quiz_title",
                        innerHTML: "\u52D5\u6F2B\u901A<span>\u95DC\u9023\u4F5C\u54C1\uFF1A" + e.game + "</span>"
                    })
                    , f = h(this, Et).createEl("div", {
                        className: "support",
                        innerHTML: `
                <a href="https://www.facebook.com/animategamer/" target="_blank">
                    <i class="material-icons" style="vertical-align:middle">chevron_right</i>
                    <span style="vertical-align:middle">\u7C89\u7D72\u5718\u627E\u7B54\u6848</span>
                </a>
            `
                    })
                    , v = [];
                ["a1", "a2", "a3", "a4"].forEach((T, D) => {
                    v[T] = h(this, Et).createEl("a", {
                        textContent: e[T]
                    }, {
                        href: "javascript: void(0)"
                    }),
                        v[T].onclick = () => {
                            te(this, $l, Ov).call(this, e, ++D, s)
                        }
                }
                ),
                    c.appendChild(a),
                    n.appendChild(c),
                    n.appendChild(u),
                    ["a1", "a2", "a3", "a4"].forEach(T => {
                        n.appendChild(v[T])
                    }
                    ),
                    n.appendChild(f),
                    r.appendChild(n),
                    this.player.el().appendChild(r),
                    h(this, _e).quizWrapper = r,
                    h(this, _e).animeQuiz = n,
                    this.player.one(["seeked", "seeking", "playing"], () => {
                        h(this, _e).quizWrapper && (h(this, _e).quizWrapper.remove(),
                            h(this, _e).quizWrapper = null)
                    }
                    )
            }
            ,
            $l = new WeakSet,
            Ov = function (e, s, r) {
                Ri.animeAnsQuestion(e.token, s).then(n => {
                    let a = h(this, Et).createEl("a", {
                        textContent: "\u7D50\u675F\u52D5\u6F2B\u901A"
                    }, {
                        href: "javascript: void(0)"
                    });
                    if (a.onclick = u => {
                        u.preventDefault(),
                            h(this, _e).quizWrapper.remove(),
                            r()
                    }
                        ,
                        n.error) {
                        let u = h(this, Et).createEl("a", {
                            textContent: "\u52D5\u756B\u760B\u7C89\u7D72\u5718"
                        }, {
                            href: "https://www.facebook.com/animategamer/",
                            target: "_blank"
                        })
                            , c = n.msg === "\u7B54\u984C\u932F\u8AA4" ? "\u5F88\u907A\u61BE\u7B54\u932F\u56C9\uFF01\u4E0B\u6B21\u53EF\u4EE5\u5148\u4E0A\u52D5\u756B\u760B\u7C89\u7D72\u5718\u627E\u7B54\u6848\u5594\uFF01" : n.msg;
                        h(this, _e).animeQuiz.innerHTML = `
                    <div class="quiz_title">\u52D5\u6F2B\u901A</div>
                    <p>
                        <i class="material-icons" style="vertical-align:middle;color:red">close</i>
                        <span style="vertical-align:middle;">${c}</span>
                    </p>
                `,
                            h(this, _e).animeQuiz.appendChild(a),
                            h(this, _e).animeQuiz.appendChild(u);
                        return
                    }
                    h(this, _e).animeQuiz.innerHTML = `
                <div class="quiz_title">\u52D5\u6F2B\u901A</div>
                <div class="pic">
                    <img src="https://i2.bahamut.com.tw/anime/award.png" alt="">
                </div>
                <p class="get">
                    <i class="material-icons" style="vertical-align:middle;color:lawngreen;">panorama_fish_eye</i>
                    <span style="vertical-align:middle">\u606D\u559C\u7B54\u5C0D\u56C9\uFF0C\u62BD\u500B\u734E\u5427\uFF01</span><br>
                </p>
            `;
                    let o = h(this, Et).createEl("a", {
                        textContent: "\u62BD\u734E"
                    }, {
                        href: "javascript:void(0)"
                    });
                    o.onclick = u => {
                        u.preventDefault(),
                            h(this, _e).animeQuiz.innerHTML = '<div class="quiz_title">\u52D5\u6F2B\u901A</div><p>' + n.gift + "<br>\u8A73\u898B\u7AD9\u5167\u4FE1\u8AAA\u660E\u5594\uFF01</p>",
                            h(this, _e).animeQuiz.appendChild(a)
                    }
                        ,
                        h(this, _e).animeQuiz.querySelector(".get").appendChild(o)
                }
                ).catch(n => {
                    console.log("Error: No response from quiz")
                }
                )
            }
            ,
            Va = new WeakSet,
            mc = function () {
                h(this, _e).countDownTitle.textContent = "",
                    h(this, _e).countDownCircle.classList.remove("is-countdown"),
                    h(this, _e).stopAutoPlay.classList.remove("is-disabled"),
                    h(this, _e).stopAutoPlay.classList.remove("vjs-hidden"),
                    h(this, _e).stopAutoPlayTxt.textContent = "\u4E2D\u65B7\u64AD\u653E",
                    h(this, _e).nextEpisode.classList.remove("vjs-hidden"),
                    h(this, _e).nextEpisode.querySelector("p").textContent = "\u4E0B\u4E00\u96C6",
                    h(this, _e).nextEpisode.classList.remove("center-btn"),
                    h(this, _e).nextEpisode.querySelector("svg").classList.add("is-hide"),
                    h(this, _e).replay.classList.remove("vjs-hidden")
            }
            ,
            Vl = new WeakSet,
            Mv = function () {
                V(this, Xs, 5),
                    h(this, _e).countDownTitle.innerHTML = `\u5012\u6578<span>${h(this, Xs)}</span>\u79D2\u7E7C\u7E8C\u64AD\u653E`,
                    h(this, _e).countDownCircle.classList.add("is-countdown"),
                    h(this, _e).nextEpisode.classList.add("center-btn"),
                    h(this, _e).nextEpisode.querySelector("svg").classList.remove("is-hide");
                let e = h(this, _e).countDownTitle.querySelector("span");
                V(this, As, setInterval(() => {
                    fa(this, Xs)._--,
                        e.textContent = h(this, Xs),
                        h(this, Xs) <= 0 && (this.hide(),
                            this.trigger("nextEpisode"))
                }
                    , 1e3))
            }
            ,
            Tg);
    U.registerPlugin("stopMask", Rb);
    var Nb = U.getComponent("MenuButton")
        , Bb = U.getComponent("MenuItem")
        , Fb = (bg = class extends Nb {
            constructor(e, s) {
                super(e, s);
                j(this, as, void 0);
                j(this, Ni, []);
                j(this, Ar, []);
                j(this, za, void 0);
                this.player = e,
                    this.showFakeFHD = s.showFakeFHD,
                    this.showLoginBtn = s.showLoginBtn,
                    this.showAutoBtn = s.showAutoBtn,
                    V(this, za, s.defaultQuality),
                    this.player.el().querySelector(".vjs-switchRes-button") === null ? (V(this, as, document.createElement("div")),
                        h(this, as).className = "vjs-switchRes-button vjs-hidden",
                        this.player.el().appendChild(h(this, as))) : V(this, as, this.player.el().querySelector(".vjs-switchRes-button"))
            }
            createItems() {
                if (this.player.qualityLevels === void 0)
                    return;
                let e = this.player.qualityLevels();
                V(this, Ni, []),
                    V(this, Ar, []);
                for (let s = 0; s < e.length; s++) {
                    let r = e[s]
                        , n = r.height ? r.height : r.width
                        , a = new Ml(this.player, {
                            label: n + "P",
                            selectable: !0,
                            resolution: n,
                            showVipMark: n == 1080
                        });
                    a.handleClick = () => {
                        this.updateItemsStatus(n)
                    }
                        ,
                        h(this, Ar).push(n),
                        h(this, Ni).push(a)
                }
                if (this.options().showFakeFHD) {
                    let s = new Ml(this.player, {
                        label: "1080P",
                        selectable: !0,
                        resolution: 1080,
                        showVipMark: !0
                    });
                    s.handleClick = () => {
                        s.selected(!1),
                            this.trigger("vipCharge")
                    }
                        ,
                        h(this, Ni).push(s)
                }
                if (this.options().showAutoBtn) {
                    let s = new Ml(this.player, {
                        label: this.player.localize("Auto"),
                        selectable: !0,
                        resolution: this.player.localize("Auto")
                    });
                    s.handleClick = () => {
                        this.updateItemsStatus(this.player.localize("Auto"))
                    }
                        ,
                        h(this, Ni).push(s)
                }
                if (this.options().showLoginBtn) {
                    let s = new Ml(this.player, {
                        label: "\u767B\u5165\u770B\u9AD8\u756B\u8CEA",
                        selectable: !0
                    });
                    s.handleClick = () => {
                        s.selected(!1),
                            this.trigger("login")
                    }
                        ,
                        h(this, Ni).push(s)
                }
                return h(this, Ni).sort((s, r) => typeof s.options().resolution > "u" ? -1 : parseInt(r.options().resolution) - parseInt(s.options().resolution)),
                    h(this, Ni)
            }
            updateQuality(e) {
                this.update(),
                    this.updateItemsStatus(e, !1)
            }
            handleClick() { }
            updateItemsStatus(e, s = !0) {
                if (this.player.qualityLevels === void 0)
                    return;
                let r = this.player.qualityLevels();
                if (e != this.player.localize("Auto") && !h(this, Ar).includes(e) && (e = Math.max(...h(this, Ar))),
                    e != this.player.localize("Auto") && s) {
                    let n = !this.player.paused();
                    this.player.pause(),
                        h(this, as).classList.remove("vjs-hidden"),
                        h(this, as).textContent = "\u756B\u8CEA\u8B8A\u66F4\u4E2D\uFF0C\u8ACB\u7A0D\u5019...",
                        this.setTimeout(() => {
                            n && this.player.play(),
                                h(this, as).classList.add("vjs-hidden")
                        }
                            , 3e3)
                }
                h(this, Ni).forEach(n => {
                    n.selected(n.options().resolution == e),
                        n.options().resolution == e && this.controlText(n.options().label)
                }
                );
                for (let n = 0; n < r.length; n++)
                    r[n].enabled = e == this.player.localize("Auto") || r[n].height == e;
                s && this.trigger({
                    type: "quality",
                    detail: {
                        quality: e
                    }
                }),
                    V(this, za, e)
            }
        }
            ,
            as = new WeakMap,
            Ni = new WeakMap,
            Ar = new WeakMap,
            za = new WeakMap,
            bg)
        , Ml = class extends Bb {
            constructor(t, e) {
                if (super(t, e),
                    this.resolution = e.resolution,
                    e.showVipMark) {
                    let s = document.createElement("span");
                    s.classList.add("vipmark"),
                        s.textContent = "vip",
                        this.el().appendChild(s)
                }
            }
        }
        ;
    U.registerComponent("QualitySelector", Fb);
    var Ub = (it = class {
        constructor() {
            j(this, ut, void 0);
            return this.constructor.instance || (V(this, ut, {}),
                this.constructor.instance = this),
                this.constructor.instance
        }
        _put(e, s, r, n, a) {
            let o, u, c, f = new Promise((T, D) => {
                u = T,
                    c = D,
                    o = setTimeout((_, L) => {
                        this._clean(e, it.COMPETITION_TYPE.RACE, a, o),
                            s(_, L)
                    }
                        , r, u, c)
            }
            ), v = () => {
                h(this, ut)[e] && h(this, ut)[e][o] && (h(this, ut)[e][o] = null,
                    delete h(this, ut)[e][o]),
                    this.isEmpty(e) && delete h(this, ut)[e]
            }
                ;
            return f.then(v, v),
                h(this, ut)[e] = h(this, ut)[e] ? h(this, ut)[e] : {},
                h(this, ut)[e][o] = {
                    timerID: o,
                    settleForLosing: n,
                    _resolve: u,
                    _reject: c
                },
                f
        }
        _clean(e, s, r, n = 0) {
            if (h(this, ut)[e]) {
                for (let [a, o] of Object.entries(h(this, ut)[e])) {
                    if (a == n)
                        continue;
                    let u;
                    switch (o.settleForLosing && o.settleForLosing[s] ? u = o.settleForLosing[s] : r && r[s] ? u = r[s] : u = {},
                    clearTimeout(o.timerID),
                    !0) {
                        case u.hasOwnProperty("resolve"):
                            o._resolve(u.resolve);
                            break;
                        case u.hasOwnProperty("reject"):
                            o._reject(u.reject);
                            break;
                        default:
                            o._reject()
                    }
                    h(this, ut)[e][a] = null,
                        delete h(this, ut)[e][a]
                }
                this.isEmpty(e) && delete h(this, ut)[e]
            }
            return this
        }
        isEmpty(e) {
            return !h(this, ut)[e] || Object.keys(h(this, ut)[e]).length == 0
        }
        static clean(e, s = it.COMPETITION_TYPE.FORCE) {
            new it()._clean(e, s)
        }
        static race(e, s, r, n, a) {
            return new it()._put(e, s, r, n, a)
        }
        static force(e, s, r, n, a) {
            let o = new it;
            return o._clean(e, it.COMPETITION_TYPE.FORCE, a),
                o._put(e, s, r, n, a)
        }
        static giveWay(e, s, r, n, a) {
            let o = new it, u;
            if (o.isEmpty(e))
                u = o._put(e, s, r, n, a);
            else {
                let c = n && n[it.COMPETITION_TYPE.GIVE_WAY] ? n[it.COMPETITION_TYPE.GIVE_WAY] : {};
                switch (!0) {
                    case c.hasOwnProperty("resolve"):
                        u = Promise.resolve(c.resolve);
                        break;
                    case c.hasOwnProperty("reject"):
                        u = Promise.reject(c.reject);
                        break;
                    default:
                        u = Promise.reject()
                }
            }
            return u
        }
        static coolDown(e, s, r = !1) {
            let n = `_CD_${e}`, a;
            return it.checkCoolDown(n) || (it.COOL_DOWN_POOL[n] = !0),
                r ? a = it.force(n, o => {
                    it.COOL_DOWN_POOL[n] = !1,
                        o()
                }
                    , s) : a = it.giveWay(n, o => {
                        it.COOL_DOWN_POOL[n] = !1,
                            o()
                    }
                        , s),
                a
        }
        static checkCoolDown(e) {
            let s = `_CD_${e}`;
            return !!it.COOL_DOWN_POOL[s]
        }
    }
        ,
        ut = new WeakMap,
        Yr(it, "COMPETITION_TYPE", {
            FORCE: "force",
            RACE: "race",
            GIVE_WAY: "giveWay"
        }),
        Yr(it, "COOL_DOWN_POOL", {}),
        it)
        , Rl = Ub
        , vC = _t(Hy())
        , jb = (Eg = class {
            constructor() {
                j(this, zl);
                j(this, Gl);
                j(this, ws, void 0);
                j(this, Bi, {});
                j(this, On, 0);
                j(this, Mn, !0);
                j(this, Qe, void 0);
                j(this, Ga, Ua.MAIN);
                V(this, Qe, document.getElementById("sub_list")),
                    h(this, Qe).onmouseenter = () => {
                        V(this, Mn, !1)
                    }
                    ,
                    h(this, Qe).onmouseleave = () => {
                        V(this, Mn, !0)
                    }
                    ,
                    document.querySelector(".refresh") != null && (document.querySelector(".refresh").onclick = () => {
                        this.onDanmuRefresh()
                    }
                    );
                let t = 0;
                h(this, Qe).parentElement.addEventListener("scroll", e => {
                    t == 0 && (t = e.target.querySelector(".sub-list-li").offsetHeight),
                        e.target.scrollTop + e.target.offsetHeight >= e.target.scrollHeight - t * 2 && this.onDanmuScrollEnd()
                }
                )
            }
            refreshDanmuList(t = 0, e = {}, s = !1, r = 0, n = Ua.MAIN) {
                if (t == 0)
                    return;
                if (s && (h(this, Qe).parentElement.scrollTop = 0),
                    V(this, ws, e),
                    V(this, On, r),
                    V(this, Bi, {}),
                    h(this, Qe).className = "sub_list",
                    h(this, Qe).innerHTML = "",
                    V(this, Ga, n),
                    !e.length) {
                    h(this, Qe).className = "no_sub",
                        h(this, Qe).innerHTML = "<img src='https://i2.bahamut.com.tw/anime/no_sub.png'>\u76EE\u524D\u6C92\u6709\u5F48\u5E55\u5594\uFF01<br>\u767C\u500B\u5F48\u5E55\u6436\u982D\u9999\u5427\uFF01";
                    return
                }
                let a = h(this, Qe).dataset.tip ? `<div class="is-hint" style="width: calc( 100% - 100px );margin-left: 32px;padding-top: 5px;line-height: 20px;">${h(this, Qe).dataset.tip}</div>` : ""
                    , o = r > 3e3 ? "3000+" : r;
                (n == Ua.MOVIE || n == Ua.MOVIE_TW) && (o = r > 6e3 ? "6000+" : r),
                    h(this, Qe).innerHTML = `<li class="anime-tip" style="height: auto;"><div><i class="material-icons">info_outline</i> \u672C\u52D5\u756B\u5171 ${o} \u7B46\u5F48\u5E55${a}</div></li><li class="danmu-desc-bottom-line"></li>`,
                    e.forEach(u => {
                        h(this, Bi)[u.time] = u.sn;
                        let c = document.createElement("span");
                        c.textContent = u.text;
                        let f = document.createElement("li");
                        f.className = "sub-list-li",
                            f.dataset.danmuSn = u.sn,
                            f.dataset.danmuUserid = u.userid,
                            f.dataset.danmuTime = u.time,
                            f.innerHTML = `<div><b>${te(this, Gl, Nv).call(this, u.time)}</b><div id="danmu${u.sn}" class="sub_content">${c.outerHTML}</div></div><div><button class="edit copy">\u8907\u88FD</button><button class="edit mute">\u6D88\u97F3</button><button class="edit accuse">\u6AA2\u8209</button><div class="name">ID <span>${u.userid}</span></div></div>`,
                            f.querySelectorAll(".edit").forEach(v => {
                                v.onclick = T => {
                                    switch (!0) {
                                        case T.target.classList.contains("copy"):
                                            this.onDanmuCopy(u.text);
                                            break;
                                        case T.target.classList.contains("mute"):
                                            te(this, zl, Rv).call(this, t, u.userid);
                                            break;
                                        case T.target.classList.contains("accuse"):
                                            if (!window.User.Login.requireLoginIframe())
                                                return;
                                            Ri.accuseDanmu(u.sn).then(D => {
                                                if (D.code === 0) {
                                                    Dialogify.alert(D.message);
                                                    return
                                                }
                                                f.querySelector(".sub_content").textContent = "\u5DF2\u5B8C\u6210\u6AA2\u8209\uFF01",
                                                    f.querySelector(".sub_content").style.color = "darkgray"
                                            }
                                            );
                                            break;
                                        default:
                                    }
                                }
                            }
                            ),
                            h(this, Qe).appendChild(f)
                    }
                    )
            }
            insertDanmu(t, e) {
                h(this, ws).push(e),
                    h(this, ws).sort((s, r) => s.time.toString() + s.sn.toString() - (r.time.toString() + r.sn.toString())),
                    fa(this, On)._++,
                    this.refreshDanmuList(t, h(this, ws), !1, h(this, On), h(this, Ga))
            }
            showDisableAllGeoInfo() {
                V(this, ws, {}),
                    V(this, Bi, {}),
                    h(this, Qe).className = "no_sub",
                    h(this, Qe).innerHTML = "\u5DF2\u95DC\u9589\u6240\u6709\u4F86\u6E90\u7684\u5F48\u5E55"
            }
            scrollDanmuList(t = 0) {
                if (!h(this, Mn) || Object.keys(h(this, Bi)).length == 0)
                    return;
                let e, s = Object.keys(h(this, Bi)), r = Math.max(...s), n = Math.min(...s), a = h(this, Qe).offsetHeight, o = h(this, Qe).querySelector(".anime-tip") ? h(this, Qe).querySelector(".anime-tip").offsetHeight : 0, u = Math.floor((a - o) / 40);
                if (t == 0 || h(this, ws).length < u || t < n) {
                    h(this, Qe).parentElement.scrollTop = 0;
                    return
                }
                switch (!0) {
                    case (e = h(this, Bi)[t]):
                        break;
                    case t >= r:
                        e = h(this, Bi)[r];
                        break;
                    default:
                        s.some(v => {
                            if (v > t)
                                return !0;
                            e = h(this, Bi)[v]
                        }
                        )
                }
                let c = h(this, Qe).querySelector(".sub-list-li[data-danmu-sn='" + e + "']")
                    , f = c.offsetTop + c.offsetHeight - a;
                h(this, Qe).parentElement.scrollTop = Math.max(0, f)
            }
            onDanmuRefresh() { }
            onDanmuCopy(t) { }
            onDanmuScrollEnd() { }
        }
            ,
            ws = new WeakMap,
            Bi = new WeakMap,
            On = new WeakMap,
            Mn = new WeakMap,
            Qe = new WeakMap,
            Ga = new WeakMap,
            zl = new WeakSet,
            Rv = function (t, e) {
                if (!window.User.Login.requireLoginIframe())
                    return;
                let s = {
                    dialog: {
                        contentStyle: {
                            "line-height": "1.6"
                        }
                    }
                };
                new Dialogify(`\u5F80\u5F8C\u5C07\u6703\u770B\u4E0D\u5230"${e}"\u7684\u5F48\u5E55\uFF0C\u8ACB\u554F\u662F\u5426\u78BA\u5B9A\uFF1F<br>(\u63D0\u793A\uFF1A\u88AB\u6D88\u97F3\u7684\u5C0D\u8C61\u53EF\u4EE5\u5728\u52C7\u8005\u5C0F\u5C4B\u7684\u9ED1\u540D\u55AE\u529F\u80FD\u4E2D\u9032\u884C\u89E3\u9664)`, s).title("\u6D88\u97F3").buttons([{
                    text: "\u53D6\u6D88",
                    click: function (r) {
                        this.close()
                    }
                }, {
                    text: "\u78BA\u5B9A",
                    type: Dialogify.BUTTON_PRIMARY,
                    click: () => {
                        Ri.blackUser(t, e).then(r => {
                            if (r.error) {
                                Dialogify.alert(r.msg);
                                return
                            }
                            this.onDanmuRefresh()
                        }
                        )
                    }
                }]).showModal()
            }
            ,
            Gl = new WeakSet,
            Nv = function (t) {
                t = Math.floor(t / 10);
                let e = Math.floor(t / 3600)
                    , s = Math.floor((t - e * 3600) / 60)
                    , r = Math.floor(t - e * 3600 - s * 60);
                return s < 10 && (s = "0" + s),
                    r < 10 && (r = "0" + r),
                    e + ":" + s + ":" + r
            }
            ,
            Eg)
        , Hb = (Sg = class {
            constructor(t) {
                j(this, Wl);
                j(this, Fi, void 0);
                j(this, wr, void 0);
                j(this, Ys, void 0);
                j(this, Qs, void 0);
                j(this, fi, void 0);
                j(this, pi, void 0);
                j(this, mi, void 0);
                j(this, Wa, void 0);
                j(this, zt, void 0);
                j(this, Ka, void 0);
                j(this, Xa, void 0);
                j(this, Gt, void 0);
                j(this, Ya, void 0);
                V(this, Fi, t),
                    te(this, Wl, Bv).call(this)
            }
            onDanmuEnable(t) { }
            onDanmuPositionEnable(t, e) { }
            onDanmuOpacityChange(t) { }
            onDanmuSizeRateChange(t) { }
            onDanmuGeoChange(t) { }
            setDanmuEnable(t) {
                h(this, wr).checked = !!t
            }
            setDanmuPositionEnable(t, e) {
                let s;
                switch (t) {
                    case "rolling":
                        s = h(this, fi);
                        break;
                    case "top":
                        s = h(this, pi);
                        break;
                    case "bottom":
                        s = h(this, mi);
                        break;
                    default:
                        return
                }
                e ? s.classList.add("is-active") : s.classList.remove("is-active")
            }
            setDanmuOpacity(t) {
                V(this, Wa, t),
                    h(this, Ka).textContent = t + "%",
                    h(this, zt).value = t
            }
            setDanmuSizeRate(t) {
                V(this, Xa, t),
                    h(this, Ya).textContent = t + "%",
                    h(this, Gt).value = t
            }
        }
            ,
            Fi = new WeakMap,
            wr = new WeakMap,
            Ys = new WeakMap,
            Qs = new WeakMap,
            fi = new WeakMap,
            pi = new WeakMap,
            mi = new WeakMap,
            Wa = new WeakMap,
            zt = new WeakMap,
            Ka = new WeakMap,
            Xa = new WeakMap,
            Gt = new WeakMap,
            Ya = new WeakMap,
            Wl = new WeakSet,
            Bv = function () {
                if (V(this, wr, document.getElementById("danmu-show")),
                    h(this, wr).checked = h(this, Fi).danmuEnable,
                    h(this, wr).onclick = e => {
                        this.onDanmuEnable(e.target.checked)
                    }
                    ,
                    V(this, Ys, document.getElementById("danmu-source-tw")),
                    V(this, Qs, document.getElementById("danmu-source-hk")),
                    h(this, Ys) != null && h(this, Qs) != null) {
                    let e = h(this, Fi).geos;
                    h(this, Ys).checked = e.includes(Nd),
                        h(this, Qs).checked = e.includes(Bd);
                    let s = () => {
                        let r = [];
                        h(this, Ys).checked && r.push(Nd),
                            h(this, Qs).checked && r.push(Bd),
                            this.onDanmuGeoChange(r)
                    }
                        ;
                    h(this, Ys).addEventListener("click", s),
                        h(this, Qs).addEventListener("click", s)
                }
                V(this, Ka, document.querySelector(".ani-setting-label .DanmuOpacityNum")),
                    V(this, zt, document.createElement("input")),
                    h(this, zt).type = "range",
                    h(this, zt).className = "DanmuOpacityRange",
                    h(this, zt).max = 100,
                    h(this, zt).min = 0,
                    h(this, zt).step = 10,
                    h(this, zt).value = h(this, Fi).opacityRate * 100 || 100,
                    this.setDanmuOpacity(h(this, zt).value),
                    h(this, zt).onmousemove = e => {
                        h(this, Wa) != e.target.value && (this.onDanmuOpacityChange(e.target.value),
                            this.setDanmuOpacity(e.target.value))
                    }
                    ,
                    h(this, zt).onchange = e => {
                        this.onDanmuOpacityChange(e.target.value),
                            this.setDanmuOpacity(e.target.value)
                    }
                    ,
                    V(this, Ya, document.querySelector(".ani-setting-label .DanmuSizeNum")),
                    V(this, Gt, document.createElement("input")),
                    h(this, Gt).type = "range",
                    h(this, Gt).className = "DanmuSizeRange",
                    h(this, Gt).max = 150,
                    h(this, Gt).min = 50,
                    h(this, Gt).step = 10,
                    h(this, Gt).value = h(this, Fi).sizeRate * 100 || 100,
                    this.setDanmuSizeRate(h(this, Gt).value),
                    h(this, Gt).onmousemove = e => {
                        e.target.value != h(this, Xa) && (this.onDanmuSizeRateChange(e.target.value),
                            this.setDanmuSizeRate(e.target.value))
                    }
                    ,
                    h(this, Gt).onchange = e => {
                        this.onDanmuSizeRateChange(e.target.value),
                            this.setDanmuSizeRate(e.target.value)
                    }
                    ,
                    V(this, fi, document.createElement("a")),
                    h(this, fi).href = "#",
                    h(this, fi).role = "button",
                    h(this, fi).className = "ani-danmu-position-btn" + (h(this, Fi).rolling ? " is-active" : ""),
                    h(this, fi).id = "ani-danmu-position-middle",
                    h(this, fi).innerHTML = '<i class="danmu-middle"></i><i class="material-icons">close</i><span>\u6EFE\u52D5\u5F48\u5E55</span>',
                    h(this, fi).onclick = e => {
                        let s = h(this, fi).classList.contains("is-active");
                        this.setDanmuPositionEnable("rolling", !s),
                            this.onDanmuPositionEnable("rolling", !s)
                    }
                    ,
                    V(this, pi, document.createElement("a")),
                    h(this, pi).href = "#",
                    h(this, pi).role = "button",
                    h(this, pi).className = "ani-danmu-position-btn" + (h(this, Fi).top ? " is-active" : ""),
                    h(this, pi).id = "ani-danmu-position-top",
                    h(this, pi).innerHTML = '<i class="danmu-top"></i><i class="material-icons">close</i><span>\u4E0A\u65B9\u5F48\u5E55</span>',
                    h(this, pi).onclick = e => {
                        let s = h(this, pi).classList.contains("is-active");
                        this.setDanmuPositionEnable("top", !s),
                            this.onDanmuPositionEnable("top", !s)
                    }
                    ,
                    V(this, mi, document.createElement("a")),
                    h(this, mi).href = "#",
                    h(this, mi).role = "button",
                    h(this, mi).className = "ani-danmu-position-btn" + (h(this, Fi).bottom ? " is-active" : ""),
                    h(this, mi).id = "ani-danmu-position-bottom",
                    h(this, mi).innerHTML = '<i class="danmu-bottom"></i><i class="material-icons">close</i><span>\u4E0B\u65B9\u5F48\u5E55</span>',
                    h(this, mi).onclick = e => {
                        let s = h(this, mi).classList.contains("is-active");
                        this.setDanmuPositionEnable("bottom", !s),
                            this.onDanmuPositionEnable("bottom", !s)
                    }
                    ,
                    document.getElementById("ani-opacity-range").appendChild(h(this, zt)),
                    document.getElementById("ani-size-range").appendChild(h(this, Gt));
                let t = document.getElementById("setting-danmu-appear");
                t.appendChild(h(this, fi)),
                    t.appendChild(h(this, pi)),
                    t.appendChild(h(this, mi))
            }
            ,
            Sg)
        , qb = (Cg = class {
            constructor(t, e = !1) {
                j(this, Rn, void 0);
                j(this, Js, !1);
                V(this, Rn, document.getElementById("autoPlay")),
                    Le.getItem(t) == null ? (Le.setItem(t, e),
                        V(this, Js, e)) : V(this, Js, Le.getItem(t) == "true"),
                    h(this, Rn).checked = h(this, Js),
                    h(this, Rn).addEventListener("click", s => {
                        Le.setItem(t, s.target.checked),
                            V(this, Js, s.target.checked),
                            this.onAutoPlayChange(s.target.checked)
                    }
                    )
            }
            isEnable() {
                return h(this, Js)
            }
            onAutoPlayChange(t) { }
        }
            ,
            Rn = new WeakMap,
            Js = new WeakMap,
            Cg)
        , $b = U.getComponent("MenuButton")
        , Vb = (Ag = class extends $b {
            constructor(e, s) {
                super(e, s);
                j(this, We, void 0);
                j(this, It, {});
                j(this, os, void 0);
                j(this, ls, void 0);
                j(this, us, void 0);
                j(this, Nn, void 0);
                j(this, Pt, void 0);
                j(this, Qa, void 0);
                j(this, Bn, void 0);
                j(this, Lt, void 0);
                j(this, Ja, void 0);
                j(this, Fn, void 0);
                j(this, Zs, !0);
                this.player = e;
                let r = this.el();
                r.id = s.id,
                    r.className = s.className,
                    r.setAttribute("role", s.role),
                    r.setAttribute("aria-live", s.ariaLive),
                    r.setAttribute("tabindex", s.tabindex);
                let n = s.defaultSetup;
                h(this, It).opacityRate = n.opacityRate,
                    h(this, It).sizeRate = n.sizeRate,
                    h(this, It).rolling = n.rolling,
                    h(this, It).top = n.top,
                    h(this, It).bottom = n.bottom,
                    h(this, It).danmuEnable = n.display,
                    h(this, It).geos = n.geos,
                    n.rightMenu && V(this, We, new Hb(h(this, It))),
                    this.switchDanmu(s.defaultSetup.display, !1),
                    this.initElement(),
                    this.initRightMenuEvent()
            }
            initElement() {
                let e = document.createElement("div");
                e.className = "vjs-menu";
                let s = document.createElement("div");
                s.className = "vjs-menu-item vjs-danmu-opacity",
                    V(this, Pt, document.createElement("input")),
                    h(this, Pt).type = "range",
                    h(this, Pt).className = "DanmuOpacityRange",
                    h(this, Pt).max = 100,
                    h(this, Pt).min = 0,
                    h(this, Pt).step = 10,
                    h(this, Pt).value = h(this, It).opacityRate * 100 || 100,
                    V(this, Nn, h(this, Pt).value),
                    h(this, Pt).onmousemove = u => {
                        h(this, Nn) != u.target.value && (this.setDanmuOpacity(u.target.value),
                            h(this, We) && h(this, We).setDanmuOpacity(u.target.value))
                    }
                    ,
                    h(this, Pt).onchange = u => {
                        this.setDanmuOpacity(u.target.value),
                            h(this, We) && h(this, We).setDanmuOpacity(u.target.value)
                    }
                    ,
                    s.innerHTML = '<p>\u5F48\u5E55\u900F\u660E&nbsp;<span class="DanmuOpacityNum">' + h(this, Pt).value + "%</span></p>",
                    V(this, Qa, s.querySelector(".DanmuOpacityNum"));
                let r = document.createElement("div");
                r.className = "vjs-menu-item vjs-danmu-opacity",
                    V(this, Lt, document.createElement("input")),
                    h(this, Lt).type = "range",
                    h(this, Lt).className = "DanmuSizeRange",
                    h(this, Lt).max = 150,
                    h(this, Lt).min = 50,
                    h(this, Lt).step = 10,
                    h(this, Lt).value = h(this, It).sizeRate * 100 || 100,
                    V(this, Bn, h(this, Lt).value),
                    h(this, Lt).onmousemove = u => {
                        u.target.value != h(this, Bn) && (this.setDanmuSizeRate(u.target.value),
                            h(this, We) && h(this, We).setDanmuSizeRate(u.target.value))
                    }
                    ,
                    h(this, Lt).onchange = u => {
                        this.setDanmuSizeRate(u.target.value),
                            h(this, We) && h(this, We).setDanmuSizeRate(u.target.value)
                    }
                    ,
                    r.innerHTML = `<p>\u5F48\u5E55\u5927\u5C0F&nbsp;<span class="DanmuSizeNum">${h(this, Lt).value}%</span></p><div class="danmusize-text"><div>\u5C0F</div><div>\u6A19\u6E96</div><div>\u5927</div></div>`,
                    V(this, Ja, r.querySelector(".DanmuSizeNum")),
                    s.appendChild(h(this, Pt)),
                    r.appendChild(h(this, Lt));
                let n = document.createElement("div");
                n.className = "vjs-menu-item vjs-danmu-position vjs-show-tip",
                    n.innerHTML = "<p>\u5F48\u5E55\u986F\u793A\u985E\u578B</p>",
                    V(this, os, document.createElement("button")),
                    h(this, os).className = "vjs-danmu-position-middle" + (h(this, It).rolling ? " active" : ""),
                    h(this, os).innerHTML = "<i></i><span>\u6EFE\u52D5</span>",
                    h(this, os).onclick = u => {
                        let c = h(this, os).classList.contains("active");
                        h(this, We) && h(this, We).setDanmuPositionEnable("rolling", !c),
                            this.setDanmuPositionEnable("rolling", !c)
                    }
                    ,
                    V(this, ls, document.createElement("button")),
                    h(this, ls).className = "vjs-danmu-position-top" + (h(this, It).top ? " active" : ""),
                    h(this, ls).innerHTML = "<i></i><span>\u4E0A\u65B9</span>",
                    h(this, ls).onclick = u => {
                        let c = h(this, ls).classList.contains("active");
                        h(this, We) && h(this, We).setDanmuPositionEnable("top", !c),
                            this.setDanmuPositionEnable("top", !c)
                    }
                    ,
                    V(this, us, document.createElement("button")),
                    h(this, us).className = "vjs-danmu-position-bottom" + (h(this, It).bottom ? " active" : ""),
                    h(this, us).innerHTML = "<i></i><span>\u4E0B\u65B9</span>",
                    h(this, us).onclick = u => {
                        let c = h(this, us).classList.contains("active");
                        h(this, We) && h(this, We).setDanmuPositionEnable("bottom", !c),
                            this.setDanmuPositionEnable("bottom", !c)
                    }
                    ;
                let a = document.createElement("div");
                a.className = "danmudisplay_btn",
                    a.append(h(this, os)),
                    a.append(h(this, ls)),
                    a.append(h(this, us)),
                    n.appendChild(a);
                let o = document.createElement("div");
                o.className = "vjs-menu-content",
                    o.appendChild(s),
                    o.appendChild(r),
                    o.appendChild(n),
                    e.appendChild(o),
                    V(this, Fn, e),
                    this.el().appendChild(e)
            }
            initRightMenuEvent() {
                h(this, We) && (h(this, We).onDanmuEnable = e => {
                    this.switchDanmu(e)
                }
                    ,
                    h(this, We).onDanmuPositionEnable = (e, s) => {
                        this.setDanmuPositionEnable(e, s)
                    }
                    ,
                    h(this, We).onDanmuOpacityChange = e => {
                        this.setDanmuOpacity(e)
                    }
                    ,
                    h(this, We).onDanmuSizeRateChange = e => {
                        this.setDanmuSizeRate(e)
                    }
                    ,
                    h(this, We).onDanmuGeoChange = e => {
                        this.options().onDanmuGeoChange && h(this, Zs) && this.options().onDanmuGeoChange(e)
                    }
                )
            }
            setDanmuPositionEnable(e, s, r = !0) {
                let n;
                switch (e) {
                    case "rolling":
                        n = h(this, os);
                        break;
                    case "top":
                        n = h(this, ls);
                        break;
                    case "bottom":
                        n = h(this, us);
                        break;
                    default:
                        return
                }
                s ? n.classList.add("active") : n.classList.remove("active"),
                    r && this.options().onDanmuDisplayChange && h(this, Zs) && this.options().onDanmuDisplayChange(e, s)
            }
            setDanmuOpacity(e) {
                V(this, Nn, e),
                    h(this, Qa).textContent = e + "%",
                    h(this, Pt).value = e,
                    this.options().onOpacityChange && h(this, Zs) && this.options().onOpacityChange(e / 100)
            }
            setDanmuSizeRate(e) {
                V(this, Bn, e),
                    h(this, Ja).textContent = e + "%",
                    h(this, Lt).value = e,
                    this.options().onSizeRateChange && h(this, Zs) && this.options().onSizeRateChange(e / 100)
            }
            switchDanmu(e, s = !0) {
                this.checked = e,
                    e ? (this.el().classList.remove("vjs-danmu-close"),
                        this.el().title = "\u95DC\u9589\u5F48\u5E55 (D)") : (this.el().classList.add("vjs-danmu-close"),
                            this.el().title = "\u958B\u555F\u5F48\u5E55 (D)"),
                    s && this.options().onDanmuDisplayChange && this.options().onDanmuDisplayChange("danmu", e)
            }
            enableSetup(e) {
                V(this, Zs, e),
                    e ? h(this, Fn).classList.remove("vjs-hidden") : h(this, Fn).classList.add("vjs-hidden")
            }
            handleClick() {
                h(this, We) && h(this, We).setDanmuEnable(!this.checked),
                    this.switchDanmu(!this.checked)
            }
        }
            ,
            We = new WeakMap,
            It = new WeakMap,
            os = new WeakMap,
            ls = new WeakMap,
            us = new WeakMap,
            Nn = new WeakMap,
            Pt = new WeakMap,
            Qa = new WeakMap,
            Bn = new WeakMap,
            Lt = new WeakMap,
            Ja = new WeakMap,
            Fn = new WeakMap,
            Zs = new WeakMap,
            Ag);
    U.registerComponent("DanmuToggle", Vb);
    var jd = U.getComponent("Component")
        , zb = U.getComponent("MenuButton")
        , Gb = (wg = class extends jd {
            constructor(e, s) {
                super(e, s);
                j(this, Za);
                j(this, Di, void 0);
                j(this, er, void 0);
                j(this, Dr, void 0);
                j(this, Ds, void 0);
                j(this, Un, void 0);
                V(this, Ds, new Xb(this.player(), {
                    id: "danmuTextareaButton",
                    className: "danmu-setting_btn vjs-menu-button",
                    ariaLive: "polite",
                    tabindex: 0,
                    role: "button"
                })),
                    V(this, Di, new Kb(this.player())),
                    h(this, Di).on("sendText", r => {
                        te(this, Za, gc).call(this, h(this, Ds).getSetup(), r.detail.text)
                    }
                    ),
                    V(this, Dr, new Wb(this.player())),
                    h(this, Dr).on("click", () => {
                        te(this, Za, gc).call(this, h(this, Ds).getSetup(), h(this, Di).getText())
                    }
                    ),
                    V(this, er, this.addChild("Component", {
                        className: "danmu_UserSignIn"
                    })),
                    h(this, er).on("click", () => {
                        window.User.Login.requireLoginIframe() && location.reload()
                    }
                    ),
                    this.addChild(h(this, Ds)),
                    V(this, Un, this.addChild("Component", {
                        className: "danmu-text-leftline"
                    })),
                    this.addChild(h(this, Di), {
                        id: "danmuTextareaInput"
                    }),
                    this.addChild(h(this, Dr)),
                    this.options()
            }
            options(e) {
                var r, n;
                let s = super.options(e);
                return s.isLogin ? h(this, er).hide() : h(this, er).show(),
                    s.showSetupButton ? (h(this, Un).show(),
                        h(this, Ds).show()) : (h(this, Un).hide(),
                            h(this, Ds).hide()),
                    h(this, er).el().textContent = (r = s.noLoginDesc) != null ? r : "\u767B\u5165\u5E33\u865F\u767C\u8868\u5F48\u5E55",
                    h(this, Di).el().placeholder = (n = s.placeholder) != null ? n : "",
                    s
            }
            shouldCbKeepingHold() {
                return h(this, Di).shouldCbKeepingHold()
            }
            clearText() {
                h(this, Di).clearText()
            }
            setText(e) {
                h(this, Di).setText(e)
            }
            disable(e) {
                h(this, Di).el().disabled = !!e,
                    h(this, Dr).el().disabled = !!e
            }
        }
            ,
            Di = new WeakMap,
            er = new WeakMap,
            Dr = new WeakMap,
            Ds = new WeakMap,
            Un = new WeakMap,
            Za = new WeakSet,
            gc = function (e, s) {
                this.trigger({
                    type: "danmuSend",
                    detail: {
                        setup: e,
                        text: s
                    }
                })
            }
            ,
            wg)
        , Wb = class extends jd {
            constructor(t, e) {
                super(t, e)
            }
            createEl(t = "button", e = {
                className: "danmu-send_btn",
                textContent: "\u767C\u9001"
            }, s = {}) {
                return super.createEl(t, e, s)
            }
        }
        , Kb = (Dg = class extends jd {
            constructor(e, s) {
                super(e, s);
                j(this, Kl);
                j(this, eo, void 0);
                j(this, jn, "cb-hold-on-for-danmu");
                V(this, eo, U.dom),
                    this.on(["keydown", "focus"], () => {
                        this.cbHolderOn()
                    }
                    ),
                    this.on("focusout", () => {
                        this.cbHolderOff()
                    }
                    ),
                    this.on("keydown", r => {
                        r.stopPropagation()
                    }
                    ),
                    this.on("keypress", r => {
                        (r.which || r.keyCode) == 13 && (te(this, Kl, Fv).call(this, this.getText()),
                            r.preventDefault())
                    }
                    )
            }
            createEl(e = "input", s = {
                className: "danmu-text"
            }, r = {
                id: "danmutxt",
                type: "text",
                autocomplete: "off"
            }) {
                return super.createEl(e, s, r)
            }
            shouldCbKeepingHold() {
                return h(this, eo).hasClass(this.el_, h(this, jn))
            }
            cbHolderOn() {
                this.timerId && this.clearTimeout(this.timerId),
                    this.addClass(h(this, jn)),
                    this.timerId = this.setTimeout(() => {
                        this.cbHolderOff()
                    }
                        , 5e3)
            }
            cbHolderOff() {
                this.timerId && this.clearTimeout(this.timerId),
                    this.removeClass(h(this, jn))
            }
            clearText() {
                this.el().value = ""
            }
            setText(e) {
                this.el().value = e
            }
            getText() {
                return this.el().value
            }
        }
            ,
            eo = new WeakMap,
            jn = new WeakMap,
            Kl = new WeakSet,
            Fv = function (e) {
                this.trigger({
                    type: "sendText",
                    detail: {
                        text: e
                    }
                })
            }
            ,
            Dg)
        , Xb = (kg = class extends zb {
            constructor(e, s) {
                super(e, s);
                j(this, Xl);
                j(this, St, void 0);
                j(this, to, "#FFFFFF");
                j(this, io, 0);
                j(this, so, 1);
                V(this, St, U.dom);
                let r = h(this, St).createEl("div", {
                    className: "danmu-setting_icon"
                })
                    , n = this.el();
                n.id = s.id,
                    n.className = s.className,
                    n.setAttribute("role", s.role),
                    n.setAttribute("aria-live", s.ariaLive),
                    n.setAttribute("tabindex", s.tabindex),
                    n.appendChild(r),
                    n.querySelector("button").remove(),
                    n.querySelector(".vjs-menu").innerHTML = "",
                    n.querySelector(".vjs-menu").appendChild(te(this, Xl, Uv).call(this))
            }
            getSetup() {
                return {
                    position: h(this, io),
                    color: h(this, to),
                    size: h(this, so)
                }
            }
        }
            ,
            St = new WeakMap,
            to = new WeakMap,
            io = new WeakMap,
            so = new WeakMap,
            Xl = new WeakSet,
            Uv = function () {
                let e = h(this, St).createEl("div", {
                    className: "danmusetting_area"
                })
                    , s = h(this, St).createEl("div", {
                        className: "danmusetting"
                    })
                    , r = h(this, St).createEl("div", {
                        className: "danmucolor_area"
                    });
                e.appendChild(s),
                    e.appendChild(h(this, St).createEl("div", {
                        className: "line"
                    })),
                    e.appendChild(r);
                let n = h(this, St).createEl("div", {
                    className: "danmutype-send"
                });
                n.innerHTML = '<p class="title">\u5F48\u5E55\u986F\u793A\u985E\u578B</p>',
                    s.appendChild(n);
                let a = h(this, St).createEl("div", {
                    className: "danmudisplay-area_btn"
                });
                [{
                    className: "danmu-slide active",
                    innerHTML: '<div class="svg"></div><span>\u6EFE\u52D5</span>',
                    value: 0
                }, {
                    className: "danmu-top",
                    innerHTML: '<div class="svg"></div><span>\u4E0A\u65B9</span>',
                    value: 1
                }, {
                    className: "danmu-bottom",
                    innerHTML: '<div class="svg"></div><span>\u4E0B\u65B9</span>',
                    value: 2
                }].forEach(f => {
                    let v = h(this, St).createEl("div", f, {
                        "data-value": f.value
                    });
                    v.onclick = () => {
                        a.querySelector(".active").classList.remove("active"),
                            v.classList.add("active"),
                            V(this, io, f.value)
                    }
                        ,
                        a.appendChild(v)
                }
                ),
                    n.appendChild(a);
                let o = h(this, St).createEl("div", {
                    className: "danmusize-send"
                });
                o.innerHTML = '<p class="title">\u6587\u5B57\u5927\u5C0F</p>',
                    s.appendChild(o);
                let u = h(this, St).createEl("div", {
                    className: "danmusize-btn"
                });
                [{
                    textContent: "\u5C0F",
                    value: 0
                }, {
                    className: "active",
                    textContent: "\u6A19\u6E96",
                    value: 1
                }, {
                    textContent: "\u5927",
                    value: 2
                }].forEach(f => {
                    let v = h(this, St).createEl("div", f, {
                        "data-value": f.value
                    });
                    v.onclick = () => {
                        u.querySelector(".active").classList.remove("active"),
                            v.classList.add("active"),
                            V(this, so, f.value)
                    }
                        ,
                        u.appendChild(v)
                }
                ),
                    o.appendChild(u),
                    r.innerHTML = '<p class="title">\u984F\u8272</p>';
                let c = h(this, St).createEl("div", {
                    className: "danmucolors"
                });
                return [{
                    className: "danmucolor is-active",
                    value: "#FFFFFF"
                }, {
                    className: "danmucolor",
                    value: "#FDE53D"
                }, {
                    className: "danmucolor",
                    value: "#FF0026"
                }, {
                    className: "danmucolor",
                    value: "#00C3FC"
                }, {
                    className: "danmucolor",
                    value: "#A7FE39"
                }, {
                    className: "danmucolor",
                    value: "#B538FA"
                }, {
                    className: "danmucolor",
                    value: "#BEBEBE"
                }, {
                    className: "danmucolor",
                    value: "#FF9625"
                }, {
                    className: "danmucolor",
                    value: "#FF9496"
                }, {
                    className: "danmucolor",
                    value: "#0036FA"
                }, {
                    className: "danmucolor",
                    value: "#00FF91"
                }, {
                    className: "danmucolor",
                    value: "#FF02D3"
                }].forEach(f => {
                    let v = h(this, St).createEl("div", f, {
                        "data-value": f.value
                    });
                    v.style.background = f.value,
                        v.innerHTML = '<div class="userdanmucolor"></div>',
                        v.onclick = () => {
                            c.querySelector(".is-active").classList.remove("is-active"),
                                v.classList.add("is-active"),
                                V(this, to, f.value)
                        }
                        ,
                        c.appendChild(v)
                }
                ),
                    r.appendChild(c),
                    e
            }
            ,
            kg);
    U.registerComponent("DanmuTextarea", Gb);
    var Yb = U.getPlugin("plugin")
        , Qb = class extends Yb {
            constructor(t, e) {
                super(t, e);
                let s = {
                    volumeStep: .1,
                    seekStep: 5,
                    enableMute: !0,
                    enablePlayPause: !0,
                    enableDanmuToggle: !0,
                    enableVolumeChange: !0,
                    enableFullscreen: !0,
                    enableNumbers: !0,
                    enableJogStyle: !1,
                    enablePlayPauseHint: !0,
                    enableForwardRewindKey: !0,
                    enableNumberKey: !0,
                    alwaysCaptureHotkeys: !1
                };
                this.options = this.extend({}, s, e || {}),
                    this.enableHotkey = !0,
                    this.init()
            }
            init() {
                this.initHotKeyHint(),
                    this.danmuToggle = this.player.controlBar.getChildById("controlBarR").getChildById("danmuToggle"),
                    this.indent = this.player.controlBar.getChildById("controlBarR").getChildById("theaterToggle"),
                    this.pageFullscreenToggle = this.player.controlBar.getChildById("controlBarR").getChildById("pageFullscreenToggle"),
                    this.player.el().hasAttribute("tabIndex") || this.player.el().setAttribute("tabIndex", "-1"),
                    this.options.alwaysCaptureHotkeys && this.player.one("play", () => {
                        this.player.el().focus()
                    }
                    ),
                    this.player.on("play", () => {
                        let t = this.player.el().querySelector(".iframeblocker");
                        t && t.style.display === "" && (t.style.display = "block",
                            t.style.bottom = "39px")
                    }
                    ),
                    this.player.on("click", t => {
                        t.target.closest(".vjs-tech") && (this.player.paused() ? this.pause() : this.play()),
                            t.detail == 2 && this.removeHintAnimation()
                    }
                    ),
                    this.player.on("keydown", t => {
                        let e = t.which, s;
                        if (this.player.controls() && this.enableHotkey) {
                            let a = document.activeElement;
                            if (this.options.alwaysCaptureHotkeys || a == this.player.el() || a == this.player.el().querySelector(".vjs-tech") || a == this.player.el().querySelector(".vjs-control-bar") || a == this.player.el().querySelector(".iframeblocker"))
                                switch (e) {
                                    case 32:
                                        if (t.preventDefault(),
                                            this.options.alwaysCaptureHotkeys && t.stopPropagation(),
                                            !this.options.enablePlayPause)
                                            break;
                                        this.player.paused() ? (this.player.play(),
                                            this.play()) : (this.player.pause(),
                                                this.pause());
                                        break;
                                    case 37:
                                        t.preventDefault(),
                                            this.options.enableForwardRewindKey && (s = this.player.currentTime() - this.options.seekStep,
                                                this.player.currentTime() <= this.options.seekStep && (s = 0),
                                                this.player.currentTime(s),
                                                this.rewind());
                                        break;
                                    case 39:
                                        t.preventDefault(),
                                            this.options.enableForwardRewindKey && (this.player.currentTime(this.player.currentTime() + this.options.seekStep),
                                                this.fastForward());
                                        break;
                                    case 40:
                                        if (t.preventDefault(),
                                            !this.options.enableVolumeChange)
                                            break;
                                        this.options.enableJogStyle ? (s = this.player.currentTime() - 1,
                                            this.player.currentTime() <= 1 && (s = 0),
                                            this.player.currentTime(s)) : (this.player.volume((this.player.volume() * 100 - this.options.volumeStep * 100) / 100),
                                                this.player.muted() || this.volume(this.player.volume(), "down"));
                                        break;
                                    case 38:
                                        if (t.preventDefault(),
                                            !this.options.enableVolumeChange)
                                            break;
                                        this.options.enableJogStyle ? this.player.currentTime(this.player.currentTime() + 1) : (this.player.volume((this.player.volume() * 100 + this.options.volumeStep * 100) / 100),
                                            this.player.muted() || this.volume(this.player.volume(), "up"));
                                        break;
                                    case 77:
                                        this.options.enableMute && (this.player.muted() ? (this.player.muted(!1),
                                            this.volume(this.player.volume(), "up")) : (this.player.muted(!0),
                                                this.volume(0, "mute")));
                                        break;
                                    case 84:
                                        this.indent.el().click();
                                        break;
                                    case 70:
                                        this.options.enableFullscreen && this.pageFullscreenToggle.el().click();
                                        break;
                                    case 68:
                                        this.options.enableDanmuToggle && this.danmuToggle.handleClick();
                                        break;
                                    default:
                                        if (this.options.enableNumberKey && (e > 47 && e < 59 || e > 95 && e < 106) && this.options.enableNumbers) {
                                            var r = 48;
                                            e > 95 && (r = 96);
                                            var n = e - r;
                                            t.preventDefault(),
                                                this.player.currentTime(this.player.duration() * n * .1)
                                        }
                                }
                        }
                    }
                    ),
                    this.player.on("keypress", t => {
                        (t.keyCode || t.which) == 32 && t.target.type === "button" && (t.target.blur(),
                            t.preventDefault())
                    }
                    )
            }
            initHotKeyHint() {
                let t = document.createElement("div");
                t.className = "vjs-hotkey-hint";
                let e = document.createElement("div");
                e.className = "hotkey-hint-center",
                    e.innerHTML = "<img class='play' src='https://i2.bahamut.com.tw/anime/play.svg'><img class='pause' src='https://i2.bahamut.com.tw/anime/pause.svg'><img class='volume-up' src='https://i2.bahamut.com.tw/anime/sound_up.svg'><img class='volume-down' src='https://i2.bahamut.com.tw/anime/sound_down.svg'><img class='mute' src='https://i2.bahamut.com.tw/anime/mute.svg'>";
                let s = document.createElement("div");
                e.appendChild(s);
                let r = document.createElement("div");
                r.className = "hotkey-hint-right",
                    r.innerHTML = "<img src='https://i2.bahamut.com.tw/anime/forward.svg'> <div>5s</div>";
                let n = document.createElement("div");
                n.className = "hotkey-hint-left",
                    n.innerHTML = "<img src='https://i2.bahamut.com.tw/anime/backward.svg'><div>5s</div>",
                    t.appendChild(e),
                    t.appendChild(r),
                    t.appendChild(n),
                    this.centerHintText = s,
                    this.centerHint = e,
                    this.leftHint = n,
                    this.rightHint = r,
                    this.player.el().appendChild(t)
            }
            removeHintAnimation() {
                this.centerHint.classList.remove("hotkey-hint-show"),
                    this.leftHint.classList.remove("hotkey-hint-show"),
                    this.rightHint.classList.remove("hotkey-hint-show")
            }
            resetHintAnimation(t) {
                t.classList.remove("hotkey-hint-show"),
                    t.offsetWidth,
                    t.classList.add("hotkey-hint-show")
            }
            resetHintCss(t, e) {
                t.classList.remove("hotkey-hint-play"),
                    t.classList.remove("hotkey-hint-pause"),
                    t.classList.remove("hotkey-hint-volume-up"),
                    t.classList.remove("hotkey-hint-volume-down"),
                    t.classList.remove("hotkey-hint-volume-mute"),
                    t.classList.add(e)
            }
            play() {
                this.options.enablePlayPauseHint && (this.centerHintText.textContent = "",
                    this.resetHintCss(this.centerHint, "hotkey-hint-play"),
                    this.resetHintAnimation(this.centerHint))
            }
            pause() {
                this.options.enablePlayPauseHint && (this.centerHintText.textContent = "",
                    this.resetHintCss(this.centerHint, "hotkey-hint-pause"),
                    this.resetHintAnimation(this.centerHint))
            }
            volume(t, e) {
                switch (t = Math.ceil(t * 100),
                this.centerHintText.textContent = t + "%",
                t <= 0 && (this.centerHintText.textContent = "\u975C\u97F3"),
                e) {
                    case "down":
                        this.resetHintCss(this.centerHint, "hotkey-hint-volume-" + (t <= 0 ? "mute" : "down"));
                        break;
                    case "mute":
                        this.resetHintCss(this.centerHint, "hotkey-hint-volume-mute");
                        break;
                    case "up":
                    default:
                        this.resetHintCss(this.centerHint, "hotkey-hint-volume-" + (t <= 0 ? "mute" : "up"))
                }
                this.resetHintAnimation(this.centerHint)
            }
            fastForward() {
                this.resetHintAnimation(this.rightHint)
            }
            rewind() {
                this.resetHintAnimation(this.leftHint)
            }
            extend(t) {
                let e, s, r;
                for (let n = 1; n < arguments.length; n++) {
                    e = arguments[n];
                    for (r in e)
                        e.hasOwnProperty(r) && (t[r] = e[r])
                }
                return t
            }
            setOptions(t = {}) {
                this.options = this.extend({}, this.options, t)
            }
            enable(t) {
                this.enableHotkey = !!t
            }
        }
        ;
    U.registerPlugin("hotkeys", Qb);
    var dg = U.getComponent("Component")
        , Jb = U.getComponent("ClickableComponent")
        , Zb = (xg = class extends dg {
            constructor(e, s) {
                super(e, s);
                j(this, ro);
                j(this, Hn, void 0);
                j(this, tr, void 0);
                j(this, ir, void 0);
                let r = e.options().inactivityTimeout;
                V(this, Hn, this.addChild("Component", {
                    className: "tool-bar-mask"
                })),
                    this.on("mouseenter", () => {
                        e.options().inactivityTimeout = 0
                    }
                    ),
                    this.on("mouseleave", () => {
                        e.options().inactivityTimeout = r
                    }
                    );
                let n = this.addChild("Component", {
                    className: "tools"
                });
                V(this, tr, new eE(e, {
                    videoSn: s.videoSn
                })),
                    V(this, ir, new tE(e)),
                    n.addChild(h(this, tr)),
                    n.addChild(h(this, ir)),
                    te(this, ro, vc).call(this, s)
            }
            options(e) {
                let s = super.options(e);
                return te(this, ro, vc).call(this, s),
                    s
            }
            createEl(e = "div", s = {
                className: "top-tool-bar"
            }, r = {}) {
                return super.createEl(e, s, r)
            }
        }
            ,
            Hn = new WeakMap,
            tr = new WeakMap,
            ir = new WeakMap,
            ro = new WeakSet,
            vc = function (e) {
                h(this, tr).options({
                    videoSn: e.videoSn
                }),
                    e.enableShareButton ? (h(this, tr).show(),
                        h(this, Hn).show()) : (h(this, tr).hide(),
                            h(this, Hn).hide()),
                    e.enableAdLogo ? (h(this, ir).show(),
                        h(this, ir).options(e.adLogoSetup)) : h(this, ir).hide()
            }
            ,
            xg)
        , eE = class extends Jb {
            constructor(t, e) {
                super(t, e)
            }
            createEl(t = "div", e = {
                className: "share-button",
                innerHTML: '<img class="share-button-img" src="https://i2.bahamut.com.tw/anime/icon_tc_share.svg" alt="\u5206\u4EAB\u7DB2\u5740">'
            }, s = {}) {
                return super.createEl(t, e, s)
            }
            handleClick(t) {
                this.player().pause(),
                    new Dialogify('<textarea id="share-url-text" class="text-field input_url" readonly placeholder="https://"></textarea><input type="checkbox" class="checkBtns check_timecode" id="check-for-tc"><label class="label_timecode" for="check-for-tc">\u5F9E<input id="share-url-tc" type="text" class="text-field input_timecode" placeholder="00:00:00">\u958B\u59CB\u64AD\u653E</label>').title("\u5206\u4EAB").buttons([{
                        text: "\u8907\u88FD\u7DB2\u5740",
                        type: Dialogify.BUTTON_PRIMARY,
                        click: function (e) {
                            var r = this.$content[0].querySelector("#share-url-text").value;
                            navigator.clipboard.writeText(r),
                                toastr.success("\u5DF2\u8907\u88FD\u5F71\u7247\u7DB2\u5740\uFF01", "", {
                                    closeButton: !0,
                                    positionClass: "toast-top-center"
                                })
                        }
                    }]).on("show", e => {
                        let s = e.target.$content[0]
                            , r = s.querySelector("#share-url-tc")
                            , n = s.querySelector("#share-url-text")
                            , a = s.querySelector("#check-for-tc")
                            , o = Math.floor(this.player().currentTime())
                            , u = function (f, v) {
                                return /^\d+$/.test(f) || (f = ja.timeToSeconds(f)),
                                    v && f <= 0 ? !1 : ja.formatTime(f, v ? "_" : ":")
                            }
                            , c = f => {
                                var v = "https://ani.baha.tw/" + this.options().videoSn;
                                return f && (v += "/" + f),
                                    v
                            }
                            ;
                        a.addEventListener("click", function () {
                            this.checked ? n.value = c(u(r.value, !0)) : n.value = c()
                        }),
                            r.addEventListener("focusout", function () {
                                a.checked && (n.value = c(u(this.value, !0))),
                                    this.value = u(this.value)
                            }),
                            r.value = u(o),
                            n.value = c(a.checked ? u(o, !0) : null)
                    }
                    ).showModal()
            }
        }
        , tE = (Ig = class extends dg {
            constructor(e, s) {
                super(e, s);
                j(this, kr, void 0);
                V(this, kr, U.dom.createEl("img", {
                    src: this.options().imgSrc || ""
                }, {
                    alt: ""
                })),
                    this.el().appendChild(h(this, kr))
            }
            createEl(e = "a", s = {
                className: "sponsorship-img is-visible",
                title: this.options().title || ""
            }, r = {
                href: this.options().link || "",
                target: "_blank"
            }) {
                return super.createEl(e, s, r)
            }
            options(e) {
                let s = super.options(e);
                return this.el() !== void 0 && (this.el().href = s.link || "",
                    this.el().title = s.title || "",
                    h(this, kr) !== void 0 && (h(this, kr).src = s.imgSrc || "")),
                    s
            }
        }
            ,
            kr = new WeakMap,
            Ig);
    U.registerComponent("TopToolBar", Zb);
    var iE = U.getComponent("Button")
        , sE = (Yd = class extends iE {
            constructor(t, e) {
                super(t, e),
                    this.setIcon("fullscreen-enter"),
                    this.on(document.querySelector(":root"), ["fullscreenchange", "msfullscreenchange", "mozfullscreenchange", "webkitfullscreenchange"], s => this.handleFullscreenChange(s)),
                    document[t.fsApi_.fullscreenEnabled] === !1 && this.disable(),
                    t.isFullscreen = this.isPageFullscreen,
                    t.requestFullscreen = this.requestFullscreen,
                    t.exitFullscreen = this.exitFullscreen
            }
            buildCSSClass() {
                return `vjs-fullscreen-control ${super.buildCSSClass()}`
            }
            isPageFullscreen() {
                return document.fullscreenElement ? document.fullscreenElement == document.querySelector(":root") : document.msFullscreenElement ? document.msFullscreenElement == document.querySelector(":root") : document.mozFullscreenElement ? document.mozFullscreenElement == document.querySelector(":root") : document.webkitFullscreenElement ? document.webkitFullscreenElement == document.querySelector(":root") : !1
            }
            requestFullscreen() {
                let t = document.querySelector(":root");
                return t.requestFullscreen ? t.requestFullscreen() : t.msRequestFullscreen ? t.msRequestFullscreen() : t.mozRequestFullScreen ? t.mozRequestFullScreen() : t.webkitRequestFullscreen ? t.webkitRequestFullscreen() : !1
            }
            exitFullscreen() {
                return document.exitFullscreen ? document.exitFullscreen() : document.msExitFullscreen ? document.msExitFullscreen() : document.mozExitFullscreen ? document.mozExitFullscreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : !1
            }
            handleFullscreenChange(t) {
                let e = this.isPageFullscreen();
                this.isPageFullscreen() ? (this.controlText("Exit Fullscreen"),
                    this.setIcon("fullscreen-exit"),
                    this.addClass("fullscreen-close"),
                    document.querySelector("body").classList.add("fullscreen")) : (this.controlText("Fullscreen"),
                        this.setIcon("fullscreen-enter"),
                        this.removeClass("fullscreen-close"),
                        document.querySelector("body").classList.remove("fullscreen")),
                    this.player().el().focus(),
                    this.trigger({
                        type: "pageFullscreen",
                        detail: {
                            pageFullscreen: e
                        }
                    })
            }
            handleClick(t) {
                this.isPageFullscreen() ? this.exitFullscreen() : this.requestFullscreen()
            }
        }
            ,
            Yr(Yd, "controlText_", "Fullscreen"),
            Yd);
    U.registerComponent("PageFullscreenToggle", sE);
    var rE = U.getPlugin("plugin")
        , nE = class extends rE {
            constructor(t, e) {
                super(t, e);
                let s = t.controlBar.progressControl.getChild("seekBar");
                s.originalMouseMove = s.handleMouseMove,
                    s.originalMouseUp = s.handleMouseUp,
                    s.handleMouseMove = function (r, n = !1) {
                        if (!U.dom.isSingleLeftClick(r) || isNaN(t.duration()))
                            return;
                        !n && !t.scrubbing() && t.scrubbing(!0);
                        let a = this.calculateDistance(r);
                        s.bar.el().style.width = (a * 100).toFixed(2) + "%"
                    }
                    ,
                    s.handleMouseUp = function (r) {
                        s.originalMouseMove(r),
                            s.originalMouseUp(r)
                    }
            }
        }
        ;
    U.registerPlugin("smoothSeekBar", nE);
    function In(t) {
        this.message = t,
            this.name = "DMException"
    }
    var cg = {
        TOP: "top",
        BOTTOM: "bottom",
        ROLLING: "rolling",
        LOCATION: "location"
    }
        , Hd = {};
    $.each(cg, function (t, e) {
        Hd[e] = !0
    });
    function aE(t) {
        var e = {
            sn: t.sn,
            time: t.time,
            mode: t.mode,
            text: t.text,
            size: t.size,
            color: t.color,
            class: t.class,
            style: t.style,
            attr: t.attr,
            locate: t.locate,
            duration: t.duration
        };
        return e.text = e.text ? e.text : "",
            e.color = e.color ? e.color : "white",
            e.time = e.time ? parseInt(e.time) : 0,
            e.size = e.size ? parseInt(e.size) : 16,
            e.mode = e.mode ? e.mode : "rolling",
            e
    }
    function oE(t, e) {
        switch (!0) {
            case t.sn > e.sn:
                return 1;
            case t.sn < e.sn:
                return -1;
            default:
                return 0
        }
    }
    var lE = {
        danmuBaseClass: "danmu",
        danmuHtmlOuter: "<div></div>",
        danmuHtmlInner: "%%TEXT%%",
        danmuGroupClass: "danmu-group-%%MANAGER_ID%%",
        danmuID: "danmu-block-%%MANAGER_ID%%-%%ID%%",
        danmuProcess: !0,
        danmuTimeUnit: 200,
        danmuCleanTiming: 3e4,
        danmuRollingRule: {
            type: "time",
            unit: 12,
            reference: "screen"
        },
        danmuDuration: 5e3,
        danmuSizeRateRange: [.5, 1.5],
        danmuSpeedRateRange: [.25, 2],
        danmuFormatFn: aE,
        danmuSortFn: oE,
        danmuBuildCallback: null,
        zoom: !1
    }
        , uE = {
            visible: !0,
            speedRate: 1,
            sizeRate: 1,
            opacityRate: .7,
            modeAllow: $.extend(!0, {}, Hd)
        };
    function je(t, e, s, r) {
        return this instanceof je ? this.init(t, e, s, r) : new je(t, e, s, r)
    }
    je.prototype.init = function (t, e, s, r) {
        this._setting = {},
            s = s || {},
            this._setting = $.extend(!0, {}, lE),
            this._setting = $.extend(!0, this._setting, s),
            this._const = {},
            this._const.DANMU_WARP_SELECTOR = t,
            this._const.TIME_POINT_GETTER = e,
            this._const.MANAGER_ID = this.getManagerID(),
            this._const.DANMU_MODE = $.extend(!0, {}, cg),
            this._const.DANMU_MODE_INDEX = $.extend(!0, {}, Hd),
            this._const.GROUP_NAME = this.getDanmuGroupName(),
            this._const.DANMU_UNIT_CLASS = (this._setting.danmuBaseClass + " " + this._const.GROUP_NAME).replace(/\s+/g, " "),
            this._const.DANMU_UNIT_SELECTOR = "." + this._const.DANMU_UNIT_CLASS.replace(/\s+/g, "."),
            Object.freeze(this._const),
            this.display = {},
            r = r || {},
            this.display = $.extend(!0, {}, uE),
            this.display = $.extend(!0, this.display, r),
            this.danmuIsPlaying = !1,
            this.rollingKeyframeID = 0,
            this.getWarp(),
            this.DLA = [],
            this.iniDLA(),
            this.danmuList = [],
            this.warpWidth = 0,
            this.warpHeight = 0,
            this.onResize()
    }
        ,
        je.prototype.getWarp = function () {
            var t = "danmu-warp"
                , e = $(this._const.DANMU_WARP_SELECTOR + ">" + ("." + t));
            return e.length == 0 && (e = $('<div id="danmu-manager-' + this._const.MANAGER_ID + '" class="' + t + '"></div>').appendTo($(this._const.DANMU_WARP_SELECTOR)),
                e.on("animationend", "." + this._setting.danmuBaseClass, function () {
                    $(this).addClass("useless")
                })),
                e
        }
        ,
        je.prototype.getManagerID = function () {
            function t() {
                var e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
                    , s = 0
                    , r = []
                    , n = function () {
                        var a = new Date().getTime()
                            , o = a === s;
                        s = a;
                        var u = new Array(8);
                        for (let f = 7; f >= 0; f--)
                            u[f] = e.charAt(a % e.length),
                                a = Math.floor(a / e.length);
                        if (a !== 0)
                            throw new Error("We should have converted the entire timestamp.");
                        var c = u.join("");
                        if (o) {
                            for (let f = 5; f >= 0 && r[f] === e.length - 1; f--)
                                r[f] = 0;
                            r[i]++
                        } else
                            for (let f = 0; f < 6; f++)
                                r[f] = Math.floor(Math.random() * e.length);
                        for (let f = 0; f < 6; f++)
                            c += e.charAt(r[f]);
                        if (c.length != 14)
                            throw new Error("Length should be 14.");
                        return c
                    };
                return n()
            }
            return this._const.MANAGER_ID ? this._const.MANAGER_ID : t()
        }
        ,
        je.prototype.getDanmuGroupName = function () {
            return this._const.GROUP_NAME ? this._const.GROUP_NAME : this._setting.danmuGroupClass.replace(/\%\%MANAGER_ID\%\%/, this.getManagerID())
        }
        ,
        je.prototype.getDanmuID = function (t) {
            return this._setting.danmuID.replace(/\%\%MANAGER_ID\%\%/, this.getManagerID()).replace(/\%\%ID\%\%/, t)
        }
        ,
        je.prototype.setDanmuVisible = function (e) {
            var e = !!e;
            return this.display.visible = e,
                e ? $(this._const.DANMU_UNIT_SELECTOR).removeClass("danmu-hide") : $(this._const.DANMU_UNIT_SELECTOR).addClass("danmu-hide"),
                !0
        }
        ,
        je.prototype.setDanmuProcess = function (t) {
            this._setting.danmuProcess = !!t,
                t ? this.danmuRAFID || this.danmuIsPlaying && this.start() : (this.danmuRAFID && (window.cancelAnimationFrame(this.danmuRAFID),
                    this.danmuRAFID = !1),
                    this.cleanAll())
        }
        ,
        je.prototype.setDanmuSizeRate = function (t) {
            t = parseFloat(t);
            var e = Math.min.apply(null, this._setting.danmuSizeRateRange)
                , s = Math.max.apply(null, this._setting.danmuSizeRateRange);
            return t = t < e ? e : t,
                t = t > s ? s : t,
                this.display.sizeRate = t,
                t
        }
        ,
        je.prototype.setDanmuSpeedRate = function (t) {
            t = parseFloat(t);
            var e = Math.min.apply(null, this._setting.danmuSpeedRateRange)
                , s = Math.max.apply(null, this._setting.danmuSpeedRateRange);
            return t = t < e ? e : t,
                t = t > s ? s : t,
                this.display.speedRate = t,
                t
        }
        ,
        je.prototype.setDanmuOpacityRate = function (t) {
            t = parseFloat(t);
            var e = 0
                , s = 1;
            return t = t < e ? e : t,
                t = t > s ? s : t,
                this.display.opacityRate = t,
                t
        }
        ,
        je.prototype.setDanmuModeAllow = function (t, e) {
            return this.display.modeAllow[t] !== void 0 ? (this.display.modeAllow[t] = !!e,
                !0) : !1
        }
        ,
        je.prototype.onResize = function () {
            this.warpWidth = $(this._const.DANMU_WARP_SELECTOR).width(),
                this.warpHeight = $(this._const.DANMU_WARP_SELECTOR).height();
            var t = [this._const.DANMU_MODE.ROLLING, this._const.DANMU_MODE.TOP, this._const.DANMU_MODE.BOTTOM];
            for (var e in t) {
                var s = t[e];
                this.DLA[s].onHeightChange(this.getWarp().height())
            }
            this.zoom(),
                this.buildDanmuAnimation()
        }
        ,
        je.prototype.zoom = function (t) {
            if (this._setting.zoom) {
                var e = parseFloat(this._setting.zoom[0])
                    , s = parseFloat(this._setting.zoom[1]);
                if (!e && !s)
                    throw new In("Error: zoom setting should not be empty.");
                var r = this.warpWidth / this.warpHeight, n, a;
                switch (!0) {
                    case !e:
                        n = a = this.warpHeight / s,
                            e = s * r;
                        break;
                    case !s:
                        n = a = this.warpWidth / e,
                            s = e / r;
                        break;
                    default:
                        n = this.warpWidth / e,
                            a = this.warpHeight / s
                }
                var o = function (u) {
                    u.css({
                        width: e + "px",
                        height: s + "px",
                        transform: "scale3d( " + n + ", " + a + " , 1)",
                        "transform-origin": "left top"
                    })
                };
                t ? o(t) : $(this._const.DANMU_WARP_SELECTOR + ">.danmu-warp").each(function () {
                    o($(this))
                })
            }
        }
        ,
        je.prototype.formatDanmu = function (t) {
            var e = this._setting.danmuFormatFn
                , s = e && $.isFunction(e) ? e(t) : t;
            if (!s.sn)
                throw new In("Missing necessary column `sn`");
            if (!s.mode)
                throw new In("Missing necessary column `mode`");
            if (typeof this._const.DANMU_MODE_INDEX[s.mode] > "u")
                throw new In("Wrong value '" + s.mode + "' in column `mode`");
            if (s.time = Math.floor(s.time / this._setting.danmuTimeUnit) * this._setting.danmuTimeUnit,
                s.time !== 0 && !(s.time > 0))
                throw new In("Missing necessary column `time`");
            return s
        }
        ,
        je.prototype.danmuLoad = function (t) {
            var e = this
                , s = {}
                , r = [];
            $.each(t, function (n, a) {
                var o = e.formatDanmu(a)
                    , u = o.time;
                r[u] == null && (r[u] = []),
                    r[u].push(o),
                    r[u].length > 1 && (s[u] = 1),
                    o = null
            }),
                $.each(s, function (n, a) {
                    r[n].sort(e._setting.danmuSortFn)
                }),
                this.danmuList = $.extend(!0, [], r),
                s = null,
                r = null
        }
        ,
        je.prototype.danmuPush = function (t, e) {
            e = e !== void 0 ? !!e : !0;
            var s = this.formatDanmu(t)
                , r = s.time;
            return this.danmuList[r] == null && (this.danmuList[r] = []),
                this.danmuList[r].push(s),
                e && this.danmuList[r].length > 1 && this.danmuList[r].sort(this._setting.danmuSortFn),
                s
        }
        ,
        je.prototype.iniDLA = function () {
            var t = [this._const.DANMU_MODE.ROLLING, this._const.DANMU_MODE.TOP, this._const.DANMU_MODE.BOTTOM];
            for (var e in t) {
                var s = t[e];
                this.DLA[s] = new Cr(this.getWarp().height())
            }
        }
        ,
        je.prototype.buildDanmuAnimation = function () {
            var t = new Date().getTime();
            $.keyframe.define([{
                name: "DM-" + this.getManagerID() + "-danmu-" + this._const.DANMU_MODE.ROLLING + "-" + t,
                "0%": {
                    transform: "translate3d(" + this.getWarp().width() + "px, 0, 0)"
                },
                "100%": {
                    transform: "translate3d(-110%, 0, 0)"
                }
            }]),
                this.rollingKeyframeID = t,
                $.keyframe.define([{
                    name: "DM-" + this.getManagerID() + "-danmu-" + this._const.DANMU_MODE.TOP,
                    "0%": {
                        visibility: "visible"
                    },
                    "100%": {
                        visibility: "hidden"
                    }
                }]),
                $.keyframe.define([{
                    name: "DM-" + this.getManagerID() + "-danmu-" + this._const.DANMU_MODE.BOTTOM,
                    "0%": {
                        visibility: "visible"
                    },
                    "100%": {
                        visibility: "hidden"
                    }
                }]),
                $.keyframe.define([{
                    name: "DM-" + this.getManagerID() + "-danmu-" + this._const.DANMU_MODE.LOCATION,
                    "0%": {
                        visibility: "visible"
                    },
                    "100%": {
                        visibility: "hidden"
                    }
                }])
        }
        ,
        je.prototype.buildDanmu = function (t) {
            if (document.visibilityState == "visible" && this._setting.danmuProcess && this.display.modeAllow[t.mode] && this.display.opacityRate != 0 && t.sn) {
                var e = this.getDanmuID(t.sn);
                if (!($("#" + e + ":not(.useless)").length > 0)) {
                    var s = this.getWarp()
                        , r = Math.floor(t.size * this.display.sizeRate)
                        , n = $(this._setting.danmuHtmlOuter).addClass(this._const.DANMU_UNIT_CLASS);
                    n.html(this._setting.danmuHtmlInner.replace("%%TEXT%%", t.text)),
                        n.attr("id", e),
                        n.addClass("danmu-mode-" + t.mode),
                        n.css("color", t.color),
                        n.css("font-size", r + "px"),
                        n.css("opacity", this.display.opacityRate),
                        this.display.visible || n.addClass("danmu-hide"),
                        t.class && n.addClass(t.class),
                        t.attr && $.each(t.attr, function (B, z) {
                            n.attr(B, z)
                        }),
                        t.data && $.each(t.data, function (B, z) {
                            n.data(B, z)
                        }),
                        t.style && $.each(t.style, function (B, z) {
                            n.css(B, z)
                        });
                    var a = n.css("visibility");
                    n.css("visibility", "hidden"),
                        s.append(n);
                    var o = n[0].offsetHeight
                        , u = n[0].offsetWidth;
                    if (t.mode != this._const.DANMU_MODE.ROLLING)
                        var c = t.duration ? t.duration : this._setting.danmuDuration
                            , f = c;
                    else {
                        var v = this._setting.danmuRollingRule.type
                            , T = this._setting.danmuRollingRule.unit;
                        switch (v) {
                            case "speed":
                                var _ = T;
                                break;
                            case "time":
                                var D = this._setting.danmuRollingRule.reference === "warp" ? this.getWarp().width() : window.screen.availWidth
                                    , _ = (D + u * 2) / T;
                                break
                        }
                        _ = _ / 1e3;
                        var c = u / _
                            , f = (this.getWarp().width() + u * 1.1) / _
                    }
                    var L = f / this.display.speedRate
                        , M = this.DLA[t.mode];
                    switch (t.mode) {
                        case this._const.DANMU_MODE.ROLLING:
                            var N = M.getLocation(o, t.time, t.time + c);
                            n.css("top", N + "px");
                            break;
                        case this._const.DANMU_MODE.TOP:
                            var N = M.getLocation(o, t.time, t.time + c);
                            n.css("top", N + "px");
                            break;
                        case this._const.DANMU_MODE.BOTTOM:
                            var N = M.getLocation(o, t.time, t.time + c);
                            n.css("bottom", N + "px");
                            break;
                        case this._const.DANMU_MODE.LOCATION:
                            $.each(["left", "right", "top", "bottom"], function (B, z) {
                                t.locate[z] && n.css(z, t.locate[z])
                            });
                            break
                    }
                    n.css("visibility", a);
                    var x = "DM-" + this.getManagerID() + "-danmu-" + t.mode;
                    return x += t.mode == this._const.DANMU_MODE.ROLLING ? "-" + this.rollingKeyframeID : "",
                        n.playKeyframe({
                            name: x,
                            duration: L + "ms",
                            timingFunction: "linear",
                            delay: "0s"
                        }),
                        this.danmuIsPlaying || n.pauseKeyframe(),
                        this._setting.danmuBuildCallback && $.isFunction(this._setting.danmuBuildCallback) && this._setting.danmuBuildCallback(n),
                        N = null,
                        e = null,
                        M = null,
                        n
                }
            }
        }
        ,
        je.prototype.fireThisTimePoint = function (t) {
            if (this.danmuList[t] !== void 0 && this.danmuList[t].length > 0) {
                var e = this.danmuList[t]
                    , s = this.buildDanmu.bind(this);
                $.each(e, function (r, n) {
                    s(n)
                }),
                    e = null
            }
            return []
        }
        ,
        je.prototype.start = function () {
            if (this.danmuIsPlaying = !0,
                !this._setting.danmuProcess) {
                this.danmuRAFID && (window.cancelAnimationFrame(this.danmuRAFID),
                    this.danmuRAFID = !1);
                return
            }
            if (!this._const.TIME_POINT_GETTER)
                throw new In("Illrgal parm of fnGetTimePoint.");
            var t = this._const.TIME_POINT_GETTER();
            this.timePointCounter = this.timePointCounter != null ? this.timePointCounter : 0,
                t = Math.floor(t / this._setting.danmuTimeUnit) * this._setting.danmuTimeUnit,
                this.timePointKeeper != t && (this.timePointKeeper = t,
                    this.fireThisTimePoint(t),
                    this.timePointCounter++),
                this.danmuRAFID = window.requestAnimationFrame(this.start.bind(this));
            var e = Math.floor(this.timePointCounter * this._setting.danmuTimeUnit / this._setting.danmuCleanTiming) * this._setting.danmuCleanTiming;
            this.timePointCleanKeeper != e && (this.timePointCleanKeeper = e,
                this.cleanUseless()),
                t = null,
                e = null
        }
        ,
        je.prototype.pause = function () {
            this.danmuIsPlaying = !1,
                $(this._const.DANMU_UNIT_SELECTOR).pauseKeyframe(),
                this.danmuRAFID && (window.cancelAnimationFrame(this.danmuRAFID),
                    this.danmuRAFID = !1),
                this.cleanUseless()
        }
        ,
        je.prototype.resume = function () {
            this.danmuIsPlaying !== !0 && ($(this._const.DANMU_UNIT_SELECTOR).resumeKeyframe(),
                this.start())
        }
        ,
        je.prototype.cleanAll = function () {
            $(this._const.DANMU_UNIT_SELECTOR).remove(),
                this.timePointKeeper = null,
                this.timePointCleanKeeper = null,
                this.iniDLA()
        }
        ,
        je.prototype.cleanUseless = function () {
            $(this._const.DANMU_UNIT_SELECTOR + ".useless").remove()
        }
        ;
    function Cr(t) {
        return this instanceof Cr ? this.init(t) : new Cr(t)
    }
    Cr.prototype.init = function (t) {
        this.onHeightChange(t),
            this.locationList = {}
    }
        ,
        Cr.prototype.onHeightChange = function (t) {
            this.maxHeight = t
        }
        ,
        Cr.prototype.getLocation = function (t, e, s) {
            for (var r, n, a, o, u = 0; (a = u + t - 1) <= this.maxHeight;) {
                if (r = this.regLocation(u, t, e, s),
                    r === !0)
                    return r = null,
                        n = null,
                        u;
                var c = r
                    , f = 0
                    , v = 0
                    , T = this;
                $.each(c, function (D, _) {
                    var L = T.locationList[_]
                        , M = Math.min(L.locationEnd, a) - Math.max(L.locationStart, u)
                        , N = Math.min(L.lifeTimeStart, e) - Math.max(L.lifeTimeEnd, s);
                    f += M * N,
                        L.crossList && L.crossList.length > 0 && (f += L.crossList.reduce(function (x, B) {
                            return x + B
                        })),
                        v = Math.max(v, L.locationEnd),
                        L = null
                }),
                    (n == null || f < n) && (n = f,
                        o = u),
                    u = v + 1
            }
            return this.regLocation(o, t, e, s, !0),
                r = null,
                n = null,
                o
        }
        ,
        Cr.prototype.regLocation = function (t, e, s, r, n) {
            var a = t + e - 1
                , o = !!n;
            if (!o) {
                for (var u = !0, c = [], f = t; f <= a; f++)
                    this.locationList[f] == null || s >= this.locationList[f].lifeTimeEnd || (u = !1,
                        c.push(f));
                o = u
            }
            if (o) {
                for (var f = t; f <= a; f++) {
                    if (this.locationList[f] == null) {
                        this.locationList[f] = {
                            locationStart: t,
                            locationEnd: a,
                            lifeTimeStart: s,
                            lifeTimeEnd: r,
                            crossList: []
                        };
                        continue
                    }
                    r >= this.locationList[f].lifeTimeEnd && (this.locationList[f].locationStart = t,
                        this.locationList[f].locationEnd = a,
                        this.locationList[f].lifeTimeStart = s,
                        this.locationList[f].lifeTimeEnd = r),
                        s >= this.locationList[f].lifeTimeEnd ? this.locationList[f].crossList = [] : this.locationList[f].crossList.push(r)
                }
                return !0
            }
            return c
        }
        ;
    var hE = je
        , dE = U.getPlugin("plugin")
        , cE = 50
        , fE = (Pg = class extends dE {
            constructor(e, s = {}) {
                super(e, s);
                j(this, Yl);
                j(this, Ql);
                j(this, Jl);
                j(this, ao);
                j(this, Zl);
                j(this, eu);
                j(this, tu);
                j(this, iu);
                j(this, su);
                j(this, ru);
                j(this, hs);
                j(this, qn);
                j(this, oo);
                j(this, nu);
                j(this, Wt, void 0);
                j(this, no, []);
                j(this, Te, {});
                j(this, sr, []);
                j(this, xr, !1);
                j(this, Ir, Vt.NORMAL);
                j(this, ks, "vjs-hidden");
                let r = {
                    videoSn: 0,
                    videoType: Ua.MAIN,
                    preVideoSn: 0,
                    nextVideoSn: 0,
                    danmuVideoSn: 0,
                    enableHotkey: !0,
                    enableDanmuTextarea: !0,
                    enableDanmuToggle: !0,
                    enablePlaybackRate: !0,
                    enableQuality: !0,
                    enableVideoDanmu: !0,
                    enableDanmu: !0,
                    enableRightMenuDanmu: !1,
                    enableRightMenuDanmuToggle: !1,
                    enableShareButton: !0,
                    enableAdLogo: !1,
                    adLogoSetup: {},
                    isLogin: !1,
                    showFakeFHD: !1,
                    initTheaterState: !0
                };
                this.state = Object.assign(r, s),
                    V(this, no, this.player.playbackRates()),
                    te(this, Yl, jv).call(this)
            }
            setPlayerSetup(e) {
                let s = document.getElementsByClassName("subtitle")[0];
                switch (V(this, Ir, e),
                e) {
                    case Vt.PARTY:
                    case Vt.PARTY_MODERATOR:
                        this.setState({
                            enableHotkey: !0,
                            enableDanmuTextarea: !0,
                            enableDanmuToggle: !0,
                            enablePlaybackRate: !1,
                            enableQuality: !0,
                            enableDanmu: !0,
                            enableShareButton: !1
                        }),
                            h(this, Te).danmuToggle.enableSetup(!1),
                            h(this, Te).danmuTextarea.options({
                                showSetupButton: !1,
                                noLoginDesc: "\u767B\u5165\u767C\u8868\u804A\u5929\u8A0A\u606F",
                                placeholder: "\u8F38\u5165\u804A\u5929\u8A0A\u606F"
                            }),
                            this.player.hotkeys().setOptions({
                                enablePlayPauseHint: !1,
                                enableNumberKey: e == Vt.PARTY_MODERATOR,
                                enableForwardRewindKey: e == Vt.PARTY_MODERATOR,
                                enablePlayPause: !0,
                                enableDanmuToggle: !0,
                                enableMute: !0,
                                enableVolumeChange: !0
                            }),
                            V(this, ks, "theater-mode"),
                            s.classList.contains("vjs-hidden") && (s.classList.add(h(this, ks)),
                                s.classList.remove("vjs-hidden")),
                            ["top", "bottom", "rolling"].forEach(a => {
                                this.danmuManager.setDanmuModeAllow(a, !0)
                            }
                            ),
                            this.danmuManager.setDanmuOpacityRate(.5),
                            this.danmuManager.setDanmuSizeRate(.9);
                        break;
                    case Vt.AD:
                        this.setState({
                            preVideoSn: 0,
                            nextVideoSn: 0,
                            enableHotkey: !1,
                            enableDanmuTextarea: !1,
                            enableDanmuToggle: !1,
                            enablePlaybackRate: !1,
                            enableQuality: !1,
                            enableDanmu: !1,
                            enableShareButton: !1,
                            enableAdLogo: !1
                        });
                        break;
                    case Vt.SHOW_AGE_GATE:
                        this.player.hotkeys().setOptions({
                            enablePlayPause: !1,
                            enableNumberKey: !1,
                            enableForwardRewindKey: !1,
                            enableDanmuToggle: !1,
                            enableMute: !1,
                            enableVolumeChange: !1
                        });
                        break;
                    case Vt.NORMAL:
                    default:
                        this.setState({
                            enableHotkey: !0,
                            enableDanmuTextarea: !0,
                            enableDanmuToggle: !0,
                            enablePlaybackRate: !0,
                            enableQuality: !0,
                            enableDanmu: !0,
                            enableDanmuVideo: !0,
                            enableShareButton: !0
                        }),
                            h(this, Te).danmuToggle.enableSetup(!0),
                            h(this, Te).danmuTextarea.options({
                                showSetupButton: !0,
                                noLoginDesc: "\u767B\u5165\u5E33\u865F\u767C\u8868\u5F48\u5E55",
                                placeholder: ""
                            }),
                            this.player.hotkeys().setOptions({
                                enablePlayPauseHint: !0,
                                enableNumberKey: !0,
                                enableForwardRewindKey: !0,
                                enablePlayPause: !0,
                                enableDanmuToggle: !0,
                                enableMute: !0,
                                enableVolumeChange: !0
                            }),
                            V(this, ks, "vjs-hidden"),
                            s.classList.contains("theater-mode") && (s.classList.add(h(this, ks)),
                                s.classList.remove("theater-mode"));
                        let r = Le.getItem(Be.DANMU_OPACITY)
                            , n = Le.getItem(Be.DANMU_SIZE);
                        n && this.danmuManager.setDanmuSizeRate(n),
                            r && (r = te(this, oo, _c).call(this, r),
                                ["top", "bottom", "rolling"].forEach(a => {
                                    this.danmuManager.setDanmuModeAllow(a, r[a])
                                }
                                ),
                                this.danmuManager.setDanmuOpacityRate(r.opacityRate))
                }
            }
            handleStateChanged(e) {
                e.changes.videoSn && (te(this, su, Wv).call(this),
                    te(this, ru, Kv).call(this),
                    h(this, xr) && te(this, hs, pr).call(this)),
                    e.changes.danmuVideoSn && te(this, hs, pr).call(this, !0, !0, !0),
                    e.changes.preVideoSn && te(this, tu, zv).call(this, this.state.preVideoSn),
                    e.changes.nextVideoSn && te(this, iu, Gv).call(this, this.state.nextVideoSn),
                    e.changes.enableHotkey && this.player.hotkeys().enable(this.state.enableHotkey),
                    e.changes.enableDanmuTextarea && (this.state.enableDanmuTextarea ? h(this, Te).danmuTextarea.show() : h(this, Te).danmuTextarea.hide()),
                    e.changes.enableDanmuToggle && (this.state.enableDanmuToggle ? h(this, Te).danmuToggle.show() : h(this, Te).danmuToggle.hide()),
                    e.changes.enablePlaybackRate && (this.state.enablePlaybackRate ? this.player.playbackRates(h(this, no)) : this.player.playbackRates([])),
                    e.changes.enableQuality && (this.state.enableQuality ? h(this, Te).qualityButton.show() : h(this, Te).qualityButton.hide()),
                    e.changes.enableDanmu && (this.danmuManager.setDanmuProcess(this.isVideoDanmuEnable()),
                        this.trigger({
                            type: "danmu",
                            detail: {
                                display: this.isDanmuEnable()
                            }
                        })),
                    e.changes.enableVideoDanmu && this.danmuManager.setDanmuProcess(this.isVideoDanmuEnable()),
                    (e.changes.videoSn || e.changes.enableShareButton || e.changes.enableAdLogo || e.changes.adLogoSetup) && h(this, Te).topToolBar.options({
                        videoSn: this.state.videoSn,
                        enableShareButton: this.state.enableShareButton,
                        enableAdLogo: this.state.enableAdLogo,
                        adLogoSetup: this.state.adLogoSetup
                    }),
                    e.changes.enableRightMenuDanmu && this.state.enableRightMenuDanmu && te(this, ao, yc).call(this)
            }
            isDanmuEnable() {
                return this.state.enableDanmu && (Le.getItem(Be.DANMU) === null || Le.getItem(Be.DANMU) == "on")
            }
            isVideoDanmuEnable() {
                return this.isDanmuEnable() && this.state.enableVideoDanmu
            }
            clearDanmuInput() {
                h(this, Te).danmuTextarea.clearText()
            }
            getPlayerMode() {
                let e = h(this, Te).fullscreenToggle.isPageFullscreen()
                    , s = h(this, Te).theaterToggle.isTheaterMode();
                return e ? "fullscreen" : s ? "theater" : "normal"
            }
        }
            ,
            Wt = new WeakMap,
            no = new WeakMap,
            Te = new WeakMap,
            sr = new WeakMap,
            xr = new WeakMap,
            Ir = new WeakMap,
            ks = new WeakMap,
            Yl = new WeakSet,
            jv = function () {
                this.state.enableRightMenuDanmu && te(this, ao, yc).call(this),
                    te(this, Jl, qv).call(this),
                    te(this, Ql, Hv).call(this),
                    h(this, Te).topToolBar = this.player.addChild("TopToolBar", {
                        videoSn: this.state.videoSn,
                        enableShareButton: this.state.enableShareButton,
                        enableAdLogo: this.state.enableAdLogo,
                        adLogoSetup: this.state.adLogoSetup
                    }),
                    te(this, Zl, $v).call(this),
                    te(this, eu, Vv).call(this),
                    this.player.hotkeys({
                        volumeStep: .1,
                        seekStep: 5,
                        enableMute: !0,
                        enableFullscreen: !0,
                        enableNumbers: !0,
                        alwaysCaptureHotkeys: !0
                    }),
                    this.player.smoothSeekBar(),
                    this.player.on("pause", () => {
                        !this.player.ended() && !this.player.seeking() && this.player.bigPlayButton.show()
                    }
                    ),
                    this.player.on("play", () => {
                        this.player.bigPlayButton.hide(),
                            this.player.el().focus()
                    }
                    ),
                    h(this, Te).danmuTextarea && this.player.on("userinactive", () => {
                        h(this, Te).danmuTextarea.shouldCbKeepingHold() && this.player.userActive(!0)
                    }
                    );
                let e = !1;
                this.player.on("useractive", s => {
                    !te(this, nu, Xv).call(this) && !e && (h(this, Te).danmuTextarea === void 0 || !h(this, Te).danmuTextarea.shouldCbKeepingHold()) && this.player.userActive(!1)
                }
                ),
                    this.player.on("touchstart", () => {
                        e = !0
                    }
                    ),
                    this.player.on("mousemove", s => {
                        this.pageY = s.clientY,
                            this.pageX = s.clientX,
                            clearTimeout(this.hideMouseTimeout),
                            this.player.el().style.cursor = "default",
                            this.hideMouseTimeout = setTimeout(() => {
                                this.player && (this.player.el().style.cursor = "")
                            }
                                , 2e3)
                    }
                    ),
                    h(this, Te).fullscreenToggle.on("pageFullscreen", s => {
                        let r = s.detail.pageFullscreen;
                        r ? h(this, Te).theaterToggle.normalMode() : Le.getItem(Be.INDENT) == "on" && h(this, Te).theaterToggle.theaterMode();
                        let n = h(this, Te).theaterToggle.isTheaterMode();
                        this.trigger({
                            type: "resize",
                            detail: {
                                mode: r ? "fullscreen" : n ? "theater" : "normal"
                            }
                        }),
                            this.danmuManager.onResize()
                    }
                    ),
                    window.animefun.refreshdanmu = () => {
                        Rl.force("updateDanmu", s => {
                            te(this, hs, pr).call(this, !1, !1),
                                s()
                        }
                            , 500)
                    }
                    ,
                    this.state.enableDanmuTextarea || h(this, Te).danmuTextarea.hide(),
                    this.state.enableDanmuToggle || h(this, Te).danmuToggle.hide(),
                    this.state.enablePlaybackRate || this.player.playbackRates([]),
                    this.state.enableQuality || h(this, Te).qualityButton.hide(),
                    this.state.enableDanmu || this.danmuManager.setDanmuProcess(!1)
            }
            ,
            Ql = new WeakSet,
            Hv = function () {
                let e = this.player.controlBar;
                this.player.addChild("Component", {
                    id: "controlBarMask",
                    className: "control-bar-mask"
                });
                let s = e.addChild("Component", {
                    id: "controlBarL",
                    className: "control-bar-leftbtn"
                })
                    , r = e.addChild("DanmuTextarea", {
                        id: "controlBarC",
                        className: "danmutext_area vjs-control",
                        login: this.state.isLogin
                    });
                r.on("danmuSend", B => {
                    let z = B.detail.setup
                        , R = B.detail.text;
                    if (h(this, Ir) == Vt.PARTY || h(this, Ir) == Vt.PARTY_MODERATOR) {
                        this.trigger({
                            type: "danmuSend",
                            detail: {
                                setup: z,
                                text: R
                            }
                        });
                        return
                    }
                    if (R == "") {
                        Dialogify.alert("\u8ACB\u8F38\u5165\u5F48\u5E55\u5167\u5BB9\u3002");
                        return
                    }
                    if (Util.String.utf8Length(R) > 60) {
                        Dialogify.alert("\u4E0D\u5F97\u8D85\u904E20\u5B57");
                        return
                    }
                    let F = Math.floor(this.player.currentTime().toFixed(1) * 10);
                    r.disable(!0),
                        Ri.danmuSet({
                            sn: this.state.videoSn,
                            content: R,
                            color: z.color,
                            position: z.position,
                            size: z.size,
                            time: Math.floor(this.player.currentTime().toFixed(1) * 10)
                        }).then(Y => {
                            if (r.disable(!1),
                                Y.error) {
                                if (Y.nologin) {
                                    window.User.Login.requireLoginIframe();
                                    return
                                }
                                Dialogify.alert(Y.msg);
                                return
                            }
                            let ue = {
                                sn: Y.sn,
                                text: U.dom.createEl("span", {
                                    textContent: R
                                }).outerHTML,
                                color: z.color,
                                size: z.size,
                                position: z.position,
                                time: F,
                                userid: User.Login.getUserid()
                            }
                                , de = this.danmuManager.danmuPush(ue);
                            this.danmuManager.buildDanmu(de),
                                te(this, hs, pr).call(this, !1, !1),
                                r.clearText()
                        }
                        )
                }
                ),
                    h(this, Te).danmuTextarea = r;
                let n = e.addChild("Component", {
                    id: "controlBarR",
                    className: "control-bar-rightbtn"
                });
                s.addChild(e.getChildById("playToggle"));
                let a = e.getChildById("preEpisode");
                a.el().title = "\u4E0A\u4E00\u96C6",
                    a.controlText("\u4E0A\u4E00\u96C6"),
                    a.el().className = "vjs-pre-button vjs-control vjs-show-tip vjs-hidden",
                    a.handleClick = () => {
                        this.trigger({
                            type: "videoChange",
                            detail: {
                                videoSn: this.state.preVideoSn
                            }
                        })
                    }
                    ,
                    s.addChild(a, {
                        id: "preEpisode"
                    }),
                    h(this, Te).pre = a;
                let o = e.getChildById("nextEpisode");
                o.el().title = "\u4E0B\u4E00\u96C6",
                    o.controlText("\u4E0B\u4E00\u96C6"),
                    o.el().className = "vjs-next-button vjs-control vjs-show-tip vjs-hidden",
                    o.handleClick = () => {
                        this.trigger({
                            type: "videoChange",
                            detail: {
                                videoSn: this.state.nextVideoSn
                            }
                        })
                    }
                    ,
                    s.addChild(o, {
                        id: "nextEpisode"
                    }),
                    h(this, Te).next = o,
                    s.addChild(e.getChildById("currentTimeDisplay"), {
                        id: "currentTimeDisplay"
                    }),
                    s.addChild(e.getChildById("timeDivider"), {
                        id: "timeDivider"
                    }),
                    s.addChild(e.getChildById("durationDisplay"), {
                        id: "durationDisplay"
                    }),
                    s.addChild("volumePanel", {
                        id: "volumePanel",
                        inline: !1
                    }).getChild("volumeControl").el().prepend(U.dom.createEl("span", {
                        className: "volume_text"
                    }));
                let f = e.getChildById("pageFullscreenToggle");
                f.el().classList.add("vjs-show-tip"),
                    n.addChild(f),
                    h(this, Te).fullscreenToggle = f;
                let v = e.getChildById("theaterToggle");
                n.addChild(v, {
                    id: "theaterToggle"
                }),
                    h(this, Te).theaterToggle = v;
                let T = n.addChild(e.getChildById("playbackRateMenuButton"), {
                    id: "playbackRateMenuButton"
                });
                h(this, Te).playbackRate = T;
                let D = Le.getItem(Be.DANMU_GEOS);
                try {
                    D = JSON.parse(D)
                } catch (B) {
                    D = null
                }
                D == null ? (D = Fd,
                    Le.setItem(Be.DANMU_GEOS, JSON.stringify(D))) : D = D.filter(B => Fd.includes(B)),
                    V(this, sr, D);
                let _ = U.getComponent("DanmuToggle")
                    , L = new _(this.player, {
                        id: "danmuToggle",
                        className: "vjs-danmu-button vjs-control vjs-menu-button",
                        ariaLive: "polite",
                        tabindex: 0,
                        role: "button",
                        defaultSetup: {
                            display: Le.getItem(Be.DANMU) === null || Le.getItem(Be.DANMU) == "on",
                            opacityRate: this.danmuManager.display.opacityRate,
                            sizeRate: this.danmuManager.display.sizeRate,
                            rolling: this.danmuManager.display.modeAllow.rolling,
                            top: this.danmuManager.display.modeAllow.top,
                            bottom: this.danmuManager.display.modeAllow.bottom,
                            rightMenu: this.state.enableRightMenuDanmuToggle,
                            geos: h(this, sr)
                        },
                        onOpacityChange: B => {
                            this.danmuManager.setDanmuOpacityRate(B),
                                Le.setItem(Be.DANMU_OPACITY, te(this, qn, sh).call(this))
                        }
                        ,
                        onSizeRateChange: B => {
                            this.danmuManager.setDanmuSizeRate(B),
                                Le.setItem(Be.DANMU_SIZE, B)
                        }
                        ,
                        onDanmuDisplayChange: (B, z) => {
                            switch (B) {
                                case "danmu":
                                    Le.setItem(Be.DANMU, z ? "on" : "off"),
                                        this.danmuManager.setDanmuProcess(this.isVideoDanmuEnable()),
                                        this.trigger({
                                            type: "danmu",
                                            detail: {
                                                display: this.isDanmuEnable(),
                                                isUserTrigger: !0
                                            }
                                        });
                                    break;
                                default:
                                    this.danmuManager.setDanmuModeAllow(B, z),
                                        Le.setItem(Be.DANMU_OPACITY, te(this, qn, sh).call(this))
                            }
                        }
                        ,
                        onDanmuGeoChange: B => {
                            V(this, sr, B),
                                Le.setItem(Be.DANMU_GEOS, JSON.stringify(B)),
                                Rl.force("updateDanmu", z => {
                                    te(this, hs, pr).call(this, !1, !1),
                                        z()
                                }
                                    , 500)
                        }
                    });
                n.addChild(L, {
                    id: "danmuToggle"
                }),
                    h(this, Te).danmuToggle = L;
                let M = Le.getItem(Be.QUALITY)
                    , N = U.getComponent("QualitySelector")
                    , x = new N(this.player, {
                        className: "vjs-visible-text vjs-res-button",
                        defaultQuality: M != this.player.localize("Auto") ? parseInt(M) : M,
                        showFakeFHD: this.state.isLogin && this.state.showFakeFHD,
                        showLoginBtn: !this.state.isLogin,
                        showAutoBtn: this.state.isLogin
                    });
                x.on("vipCharge", () => {
                    this.player.pause(),
                        this.player.animeMask().showCharge("\u9700\u6210\u70BAVIP\u6703\u54E1\u624D\u80FD\u9078\u64C7\u6B64\u756B\u8CEA\u5594\uFF01", () => {
                            this.player.play()
                        }
                        )
                }
                ),
                    x.on("login", () => {
                        this.player.pause(),
                            this.player.animeMask().showLogin("\u66F4\u6539\u756B\u8CEA\u9700\u8981\u5148\u767B\u5165\u5DF4\u54C8\u5E33\u865F\u5594\uFF01", () => {
                                this.player.play()
                            }
                            )
                    }
                    ),
                    x.on("quality", B => {
                        Le.setItem(Be.QUALITY, B.detail.quality)
                    }
                    ),
                    n.addChild(x, {
                        id: "resButton"
                    }),
                    h(this, Te).qualityButton = x
            }
            ,
            Jl = new WeakSet,
            qv = function () {
                let e = U.dom.createEl("div", {
                    className: "vjs-danmu"
                });
                this.player.el().insertBefore(e, this.player.el().getElementsByClassName("vjs-poster")[0]);
                let s = Le.getItem(Be.DANMU_OPACITY)
                    , r = Le.getItem(Be.DANMU_SIZE)
                    , n = Le.getItem(Be.DANMU)
                    , a = {};
                r && (a.sizeRate = r),
                    s && (s = te(this, oo, _c).call(this, s),
                        a.opacityRate = s.opacityRate,
                        a.modeAllow = {
                            top: s.top,
                            rolling: s.rolling,
                            bottom: s.bottom
                        }),
                    this.danmuManager = new hE(".vjs-danmu", () => {
                        if (this.player != null)
                            return this.player.currentTime().toFixed(1) * 1e3
                    }
                        , {
                            danmuFormatFn: function (u) {
                                let c = {
                                    sn: u.sn,
                                    time: Math.floor(u.time * 100),
                                    text: u.text,
                                    color: u.color,
                                    locate: u.locate,
                                    class: u.class,
                                    style: u.style,
                                    lifeTime: u.lifeTime
                                };
                                switch (u.size) {
                                    case 0:
                                        c.size = 16;
                                        break;
                                    case 2:
                                        c.size = 28;
                                        break;
                                    case 1:
                                    default:
                                        c.size = 24
                                }
                                switch (u.position) {
                                    case 1:
                                        c.mode = "top";
                                        break;
                                    case 2:
                                        c.mode = "bottom";
                                        break;
                                    case 0:
                                    default:
                                        c.mode = "rolling"
                                }
                                return c
                            },
                            danmuRollingRule: {
                                type: "time",
                                unit: "12",
                                reference: "screen"
                            },
                            danmuProcess: n == null || n == "on"
                        }, a),
                    Le.setItem(Be.DANMU_OPACITY, te(this, qn, sh).call(this)),
                    Le.setItem(Be.DANMU_SIZE, this.danmuManager.display.sizeRate),
                    this.player.on("playerresize", () => {
                        Rl.force("danmuManagerResize", u => {
                            this.danmuManager.onResize(),
                                u()
                        }
                            , 50)
                    }
                    ),
                    this.player.on(["pause", "waiting"], () => {
                        this.danmuManager.pause()
                    }
                    ),
                    this.player.on(["play", "timeupdate"], () => {
                        this.player.paused() || this.danmuManager.resume()
                    }
                    ),
                    this.player.on("ratechange", () => {
                        this.danmuManager.setDanmuSpeedRate(this.player.playbackRate())
                    }
                    ),
                    this.player.on("seeking", () => {
                        this.danmuManager.cleanAll()
                    }
                    );
                let o = null;
                this.player.on("timeupdate", () => {
                    if (h(this, Ir) == Vt.AD)
                        return;
                    let u = this.player.currentTime()
                        , c = parseInt(u, 10);
                    if (c === o)
                        return;
                    o = c;
                    let f = Math.floor(u * 1e3 / 100);
                    h(this, Wt) && h(this, Wt).scrollDanmuList(f)
                }
                )
            }
            ,
            ao = new WeakSet,
            yc = function () {
                h(this, Wt) || (V(this, Wt, new jb),
                    h(this, Wt).refreshDanmuList(this.state.danmuVideoSn),
                    h(this, Wt).onDanmuCopy = e => {
                        h(this, Te).danmuTextarea && h(this, Te).danmuTextarea.setText(e)
                    }
                    ,
                    h(this, Wt).onDanmuRefresh = () => {
                        Rl.force("updateDanmu", e => {
                            te(this, hs, pr).call(this),
                                e()
                        }
                            , 500)
                    }
                    ,
                    h(this, Wt).onDanmuScrollEnd = () => {
                        h(this, xr) && te(this, hs, pr).call(this, !1, !1)
                    }
                )
            }
            ,
            Zl = new WeakSet,
            $v = function () {
                let s = this.player.controlBar.getChildById("controlBarL").getChildById("volumePanel").getChild("volumeControl").el().querySelector(".volume_text");
                this.player.volume(Le.getItem(Be.VOLUME) || 1),
                    this.player.muted(Le.getItem(Be.VOLUME_MUTE) === "true"),
                    this.player.on(["volumechange", "canplay"], () => {
                        Le.setItem(Be.VOLUME, this.player.volume()),
                            Le.setItem(Be.VOLUME_MUTE, this.player.muted()),
                            this.player.muted() || this.player.volume() == 0 ? s.textContent = "0" : s.textContent = Math.ceil(this.player.volume() * 100)
                    }
                    )
            }
            ,
            eu = new WeakSet,
            Vv = function () {
                let e = {
                    indent: h(this, Te).theaterToggle,
                    subtitle: document.getElementsByClassName("subtitle")[0],
                    videoframe: document.getElementsByClassName("videoframe")[0],
                    video: document.getElementsByClassName("video")[0]
                }
                    , s = a => {
                        let o = document.querySelector(".top_sky");
                        a == "on" ? (o.classList.add("fullwindow"),
                            o.classList.add("is-fixed")) : a == "off" && (o.classList.remove("fullwindow"),
                                o.classList.remove("is-fixed"))
                    }
                    , r = () => {
                        e.indent.theaterMode(),
                            e.subtitle.classList.add(h(this, ks)),
                            e.videoframe.classList.add("vjs-fullwindow"),
                            document.querySelectorAll("div.container-player").forEach(a => a.classList.add("fullwindow")),
                            document.querySelectorAll("div.video").forEach(a => a.classList.add("fullwindow")),
                            s("on")
                    }
                    , n = () => {
                        e.indent.normalMode(),
                            e.subtitle.classList.remove(h(this, ks)),
                            e.videoframe.classList.remove("vjs-fullwindow"),
                            document.querySelectorAll("div.container-player").forEach(a => a.classList.remove("fullwindow")),
                            document.querySelectorAll("div.video").forEach(a => a.classList.remove("fullwindow")),
                            s("off"),
                            e.video.style.paddingBottom = "56.25%"
                    }
                    ;
                e.indent.on("click", () => {
                    let a;
                    e.indent.isTheaterMode() && !h(this, Te).fullscreenToggle.isPageFullscreen() ? (n(),
                        Le.setItem(Be.INDENT, "off"),
                        a = "normal") : (r(),
                            Le.setItem(Be.INDENT, "on"),
                            a = "theater"),
                        h(this, Te).fullscreenToggle.isPageFullscreen() && h(this, Te).fullscreenToggle.exitFullscreen(),
                        this.player.el().focus(),
                        this.danmuManager.onResize(),
                        this.trigger({
                            type: "resize",
                            detail: {
                                mode: a
                            }
                        })
                }
                ),
                    this.state.initTheaterState && (Le.getItem(Be.INDENT) == "on" ? r() : n()),
                    this.danmuManager.onResize()
            }
            ,
            tu = new WeakSet,
            zv = function (e) {
                e > 0 ? (h(this, Te).pre.el().classList.remove("vjs-hidden"),
                    h(this, Te).pre.el().setAttribute("data-ani-video-sn", e)) : h(this, Te).pre.el().classList.add("vjs-hidden")
            }
            ,
            iu = new WeakSet,
            Gv = function (e) {
                e > 0 ? (h(this, Te).next.el().classList.remove("vjs-hidden"),
                    h(this, Te).next.el().setAttribute("data-ani-video-sn", e)) : h(this, Te).next.el().classList.add("vjs-hidden")
            }
            ,
            su = new WeakSet,
            Wv = function () {
                h(this, Te).qualityButton.options({
                    showFakeFHD: this.state.isLogin && this.state.showFakeFHD,
                    showLoginBtn: !this.state.isLogin,
                    showAutoBtn: this.state.isLogin
                }),
                    h(this, Te).qualityButton.updateQuality(parseInt(Le.getItem(Be.QUALITY)))
            }
            ,
            ru = new WeakSet,
            Kv = function () {
                h(this, Te).danmuTextarea.options({
                    isLogin: this.state.isLogin
                })
            }
            ,
            hs = new WeakSet,
            pr = function (e = !1, s = !0, r = !1) {
                s && this.danmuManager.cleanAll();
                let n = this.state.danmuVideoSn;
                if (n === 0)
                    return;
                if (h(this, sr).length == 0) {
                    h(this, Wt) && h(this, Wt).showDisableAllGeoInfo(),
                        this.danmuManager.danmuLoad([]);
                    return
                }
                V(this, xr, r);
                let a = r ? cE : 0;
                Ri.danmuGet(n, h(this, sr), a).then(o => {
                    let u = o.data.danmu
                        , c = o.data.totalCount;
                    h(this, Wt) && h(this, Wt).refreshDanmuList(n, u, e, c, this.state.videoType),
                        u.length == c && V(this, xr, !1),
                        this.danmuManager.danmuLoad(u)
                }
                )
            }
            ,
            qn = new WeakSet,
            sh = function () {
                return this.danmuManager.display.opacityRate + "," + (this.danmuManager.display.modeAllow.rolling ? 1 : 0) + "," + (this.danmuManager.display.modeAllow.top ? 1 : 0) + "," + (this.danmuManager.display.modeAllow.bottom ? 1 : 0)
            }
            ,
            oo = new WeakSet,
            _c = function (e) {
                return e = e.split(","),
                {
                    opacityRate: parseFloat(e[0]),
                    rolling: !!parseInt(e[1]),
                    top: !!parseInt(e[2]),
                    bottom: !!parseInt(e[3])
                }
            }
            ,
            nu = new WeakSet,
            Xv = function () {
                let e = this.player.el().querySelector("video").getBoundingClientRect()
                    , s = 60
                    , r = 60
                    , n = e.top
                    , a = n + e.height
                    , o = e.left
                    , u = o + e.width
                    , c = {
                        cb: {
                            top: a - s,
                            bottom: a,
                            left: o,
                            right: u
                        },
                        top: {
                            top: n,
                            bottom: n + r,
                            left: o,
                            right: u
                        }
                    };
                return Object.values(c).some(f => {
                    if (f.left <= this.pageX && this.pageX <= f.right && f.top <= this.pageY && this.pageY <= f.bottom)
                        return !0
                }
                )
            }
            ,
            Pg);
    U.registerPlugin("animePlayer", fE);
    var pE = U.getPlugin("plugin")
        , mE = (Lg = class extends pE {
            constructor() {
                super(...arguments);
                Yr(this, "AD_EVENTS", Object.freeze({
                    START: "start",
                    END: "end",
                    ERROR: "error",
                    CANCEL: "cancel"
                }));
                j(this, lo, 0)
            }
            play() { }
            destroy(e = !1) {
                this.clearAdTimeout(),
                    e && this.trigger(this.AD_EVENTS.ERROR)
            }
            startAdTimeout() {
                V(this, lo, window.setTimeout(() => {
                    this.destroy(!0)
                }
                    , this.getAdTimeoutTime()))
            }
            getAdTimeoutTime() {
                return 0
            }
            clearAdTimeout() {
                window.clearTimeout(h(this, lo))
            }
            dispose() {
                this.destroy(),
                    super.dispose()
            }
        }
            ,
            lo = new WeakMap,
            Lg)
        , Nl = mE
        , gE = (Og = class extends Nl {
            constructor(e, s) {
                super(e, s);
                j(this, au);
                j(this, $n, void 0);
                j(this, xs, void 0);
                j(this, gi, void 0);
                j(this, Pr, void 0);
                j(this, Vn, void 0);
                j(this, rr, void 0);
                j(this, Ui, {});
                V(this, $n, U.dom)
            }
            play(e = {}) {
                super.play(),
                    e.adId || this.destroy(!0),
                    V(this, Vn, "https://bahamut.akamaized.net/ad/" + e.adId + "/playlist.m3u8"),
                    V(this, rr, e.skipTime || 30),
                    e.skipText || (e.skipText = "\u5EE3\u544A %%TIME%% \u79D2\uFF0C\u5982\u4F55\u6D88\u9664\u5EE3\u544A\uFF1F"),
                    V(this, xs, h(this, $n).createEl("a", {
                        className: "vast-blocker"
                    }, {
                        href: e.adUrl,
                        target: "_blank"
                    })),
                    h(this, xs).onclick = s => {
                        this.player.paused() ? (this.player.play(),
                            s.preventDefault()) : this.player.pause()
                    }
                    ,
                    V(this, gi, h(this, $n).createEl("div", {
                        className: "vast-skip-button",
                        id: "adSkipButton",
                        "style.display": "block"
                    })),
                    h(this, gi).style.display = "block",
                    h(this, gi).onclick = () => {
                        if (h(this, rr) <= 0) {
                            this.player.removeClass("vjs-ad-playing"),
                                this.destroy(),
                                this.trigger(this.AD_EVENTS.END);
                            return
                        }
                        window.open("https://ani.gamer.com.tw/animePay.php")
                    }
                    ,
                    this.player.el().appendChild(h(this, xs)),
                    this.player.el().appendChild(h(this, gi)),
                    V(this, Ui, {
                        loadedmetadata: () => {
                            this.trigger(this.AD_EVENTS.START),
                                this.player.play(),
                                this.player.addClass("vjs-ad-playing")
                        }
                        ,
                        play: () => {
                            V(this, Pr, setInterval(() => te(this, au, Yv).call(this, e.skipText), 1e3))
                        }
                        ,
                        pause: () => {
                            clearInterval(h(this, Pr))
                        }
                        ,
                        ended: () => {
                            this.destroy(),
                                this.trigger(this.AD_EVENTS.END)
                        }
                        ,
                        error: () => {
                            this.player.removeClass("vjs-ad-playing"),
                                this.destroy(!0)
                        }
                    }),
                    this.player.one("loadedmetadata", h(this, Ui).loadedmetadata),
                    this.player.on("play", h(this, Ui).play),
                    this.player.on("pause", h(this, Ui).pause),
                    this.player.one("ended", h(this, Ui).ended),
                    this.player.one("error", h(this, Ui).error),
                    this.player.src({
                        src: h(this, Vn),
                        type: "application/x-mpegURL"
                    })
            }
            destroy(e = !1) {
                super.destroy(e);
                for (const s in h(this, Ui))
                    this.player.off(s, h(this, Ui)[s]);
                this.player.src() == h(this, Vn) && this.player.pause(),
                    this.player.removeClass("vjs-ad-playing"),
                    h(this, xs) && (h(this, xs).remove(),
                        V(this, xs, null)),
                    h(this, gi) && (h(this, gi).remove(),
                        V(this, gi, null)),
                    clearInterval(h(this, Pr))
            }
        }
            ,
            $n = new WeakMap,
            xs = new WeakMap,
            gi = new WeakMap,
            Pr = new WeakMap,
            Vn = new WeakMap,
            rr = new WeakMap,
            Ui = new WeakMap,
            au = new WeakSet,
            Yv = function (e) {
                if (fa(this, rr)._--,
                    h(this, rr) <= 0) {
                    h(this, gi).innerHTML = '<p class="vast-skip-button-text">\u9EDE\u6B64\u8DF3\u904E\u5EE3\u544A</p>',
                        h(this, gi).classList.add("enable"),
                        clearInterval(h(this, Pr));
                    return
                }
                h(this, gi).innerHTML = `<p class="vast-skip-button-text">${e.replace("%%TIME%%", h(this, rr))}</p>`
            }
            ,
            Og);
    U.registerPlugin("animeAd", gE);
    var vE = (Mg = class extends Nl {
        constructor(e, s) {
            super(e, s);
            j(this, ou);
            j(this, lu);
            j(this, Is);
            j(this, Ot, void 0);
            j(this, nr, void 0);
            j(this, ds, void 0);
            j(this, Lr, void 0);
            j(this, zn, void 0);
            j(this, cs, void 0);
            j(this, Or, void 0);
            j(this, ct, void 0);
            V(this, Lr, U.dom)
        }
        play(e, s = null) {
            super.play(),
                s = s || "https://pubads.g.doubleclick.net/gampad/ads?iu=/1017768/ANI_PREROLL&description_url=https%3A%2F%2Fani.gamer.com.tw%2FanimeVideo.php%3Fsn%3D" + e + "&env=vp&impl=s&correlator=&tfcd=0&npa=0&gdfp_req=1&output=vast&sz=1x1|640x480&unviewed_position_start=1&vpmute=0&plcmt=1",
                h(this, Or) || te(this, ou, Qv).call(this),
                V(this, cs, new google.ima.AdsLoader(h(this, Or))),
                h(this, cs).addEventListener(google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED, n => {
                    te(this, lu, Jv).call(this, n)
                }
                    , !1),
                h(this, cs).addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, () => {
                    this.destroy(!0)
                }
                    , !1),
                h(this, Or).initialize(),
                h(this, Ot).classList.remove("vjs-hidden");
            let r = new google.ima.AdsRequest;
            r.adTagUrl = s,
                r.linearAdSlotWidth = h(this, Ot).offsetWidth,
                r.linearAdSlotHeight = h(this, Ot).offsetHeight,
                r.nonLinearAdSlotWidth = h(this, Ot).offsetWidth,
                r.nonLinearAdSlotHeight = h(this, Ot).offsetHeight,
                h(this, cs).requestAds(r),
                this.player.controlBar.hide(),
                this.startAdTimeout()
        }
        getAdTimeoutTime() {
            return 5e3
        }
        destroy(e = !1) {
            super.destroy(e),
                h(this, ct) && (h(this, ct).destroy(),
                    h(this, cs).contentComplete(),
                    V(this, ct, null)),
                h(this, cs) && h(this, cs).destroy(),
                this.player && this.player.controlBar.show(),
                h(this, Ot) && h(this, Ot).classList.add("vjs-hidden")
        }
    }
        ,
        Ot = new WeakMap,
        nr = new WeakMap,
        ds = new WeakMap,
        Lr = new WeakMap,
        zn = new WeakMap,
        cs = new WeakMap,
        Or = new WeakMap,
        ct = new WeakMap,
        ou = new WeakSet,
        Qv = function () {
            V(this, zn, this.player.el().querySelector("video")),
                V(this, Ot, h(this, Lr).createEl("div", {
                    className: "video-google-AD"
                })),
                V(this, nr, h(this, Lr).createEl("div", {
                    className: "video-google-AD-ima-content"
                })),
                V(this, ds, h(this, Lr).createEl("div", {
                    className: "video-google-AD-custom-mask",
                    innerHTML: '<div class="btn-google-AD-play"></div>'
                })),
                h(this, ds).onclick = () => {
                    h(this, ct) && h(this, ct).resume()
                }
                ,
                h(this, Ot).appendChild(h(this, nr)),
                h(this, Ot).appendChild(h(this, ds)),
                this.player.el().appendChild(h(this, Ot)),
                V(this, Or, new google.ima.AdDisplayContainer(h(this, nr), h(this, zn)))
        }
        ,
        lu = new WeakSet,
        Jv = function (e) {
            this.clearAdTimeout();
            let s = new google.ima.AdsRenderingSettings;
            s.restoreCustomPlaybackStateOnAdBreakComplete = !0,
                V(this, ct, e.getAdsManager(h(this, zn), s)),
                h(this, ct).setVolume(.3),
                h(this, ct).addEventListener(google.ima.AdErrorEvent.Type.AD_ERROR, () => this.destroy(!0)),
                h(this, ct).addEventListener(google.ima.AdEvent.Type.STARTED, te(this, Is, Qr).bind(this)),
                h(this, ct).addEventListener(google.ima.AdEvent.Type.COMPLETE, te(this, Is, Qr).bind(this)),
                h(this, ct).addEventListener(google.ima.AdEvent.Type.ALL_ADS_COMPLETED, te(this, Is, Qr).bind(this)),
                h(this, ct).addEventListener(google.ima.AdEvent.Type.SKIPPED, te(this, Is, Qr).bind(this)),
                h(this, ct).addEventListener(google.ima.AdEvent.Type.PAUSED, te(this, Is, Qr).bind(this)),
                h(this, ct).addEventListener(google.ima.AdEvent.Type.RESUMED, te(this, Is, Qr).bind(this));
            try {
                h(this, ct).init(h(this, Ot).offsetWidth, h(this, Ot).offsetHeight, google.ima.ViewMode.NORMAL),
                    h(this, ct).start(),
                    h(this, nr).querySelectorAll(":scope > div").forEach(a => {
                        a.style.width = "100%",
                            a.style.height = "100%"
                    }
                    );
                let n = h(this, nr).querySelector("iframe");
                n.style.width = "100%",
                    n.style.height = "100%"
            } catch (r) {
                this.destroy(!0)
            }
        }
        ,
        Is = new WeakSet,
        Qr = function (e) {
            switch (e.getAd().isLinear() || this.destroy(!0),
            e.type) {
                case google.ima.AdEvent.Type.STARTED:
                    h(this, ds).classList.remove("active"),
                        this.trigger(this.AD_EVENTS.START);
                    break;
                case google.ima.AdEvent.Type.SKIPPED:
                case google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED:
                case google.ima.AdEvent.Type.ALL_ADS_COMPLETED:
                    h(this, ds).classList.remove("active"),
                        this.destroy(),
                        this.trigger(this.AD_EVENTS.END);
                    break;
                case google.ima.AdEvent.Type.PAUSED:
                    h(this, ds).classList.add("active");
                    break;
                case google.ima.AdEvent.Type.RESUMED:
                    h(this, ds).classList.remove("active");
                    break;
                default:
            }
        }
        ,
        Mg);
    U.registerPlugin("imaAd", vE);
    var qd = "ani-google-native-left"
        , $d = "ani-google-native-right"
        , wi = {
            SUCCESS: 1,
            READY: 0,
            EMPTY: -1
        }
        , yE = (Rg = class extends Nl {
            constructor(e, s) {
                super(e, s);
                j(this, uu);
                j(this, hu);
                j(this, du);
                j(this, ar, void 0);
                j(this, ki, void 0);
                j(this, ri, void 0);
                j(this, Ct, void 0);
                j(this, Mr, void 0);
                j(this, Rr, void 0);
                j(this, Nr, wi.READY);
                j(this, Br, wi.READY);
                j(this, ji, void 0);
                j(this, Gn, void 0);
                j(this, fs, void 0);
                j(this, uo, void 0);
                j(this, ho, void 0);
                V(this, ar, U.dom)
            }
            play(e = {}) {
                if (super.play(),
                    !h(this, Ct)) {
                    if (!(window.googletag && googletag.apiReady)) {
                        this.destroy(!0);
                        return
                    }
                    V(this, Ct, window.googletag),
                        te(this, uu, Zv).call(this),
                        te(this, hu, ey).call(this)
                }
                V(this, Nr, wi.READY),
                    V(this, Br, wi.READY),
                    h(this, ri).classList.remove("enable"),
                    V(this, Gn, 600),
                    V(this, fs, parseInt(e.skipCountDown) || 30),
                    V(this, fs, h(this, fs) >= 5 ? h(this, fs) : 5),
                    V(this, uo, e.skipText),
                    V(this, ho, e.skipButtonText),
                    h(this, Ct).cmd.push(() => {
                        V(this, Mr, h(this, Ct).defineSlot("/1017768/AD_desktopweb_preroll_button_left", [[336, 280]], qd).addService(h(this, Ct).pubads())),
                            V(this, Rr, h(this, Ct).defineSlot("/1017768/AD_desktopweb_preroll_button_right", [[336, 280]], $d).addService(h(this, Ct).pubads())),
                            window.DFP.setTargeting(),
                            h(this, Ct).pubads().setTargeting("service", "ani"),
                            h(this, Ct).pubads().collapseEmptyDivs(),
                            h(this, Ct).enableServices(),
                            h(this, Ct).display($d),
                            h(this, Ct).display(qd)
                    }
                    ),
                    this.startAdTimeout()
            }
            getAdTimeoutTime() {
                return 15e3
            }
            destroy(e = !1) {
                super.destroy(e),
                    h(this, ji) && (clearInterval(h(this, ji)),
                        V(this, ji, 0)),
                    googletag.destroySlots && (googletag.destroySlots([h(this, Mr), h(this, Rr)]),
                        V(this, Mr, null),
                        V(this, Rr, null)),
                    h(this, ki) && (h(this, ki).classList.add("vjs-hidden"),
                        h(this, ri).classList.add("vjs-hidden"),
                        h(this, ri).innerHTML = "",
                        h(this, ki).classList.remove("all-loaded")),
                    this.player && this.player.controlBar.show()
            }
        }
            ,
            ar = new WeakMap,
            ki = new WeakMap,
            ri = new WeakMap,
            Ct = new WeakMap,
            Mr = new WeakMap,
            Rr = new WeakMap,
            Nr = new WeakMap,
            Br = new WeakMap,
            ji = new WeakMap,
            Gn = new WeakMap,
            fs = new WeakMap,
            uo = new WeakMap,
            ho = new WeakMap,
            uu = new WeakSet,
            Zv = function () {
                if (!(window.googletag && googletag.apiReady))
                    return;
                V(this, ki, h(this, ar).createEl("div", {
                    className: "video-google-AD"
                })),
                    V(this, ri, h(this, ar).createEl("div", {
                        className: "nativeAD-skip-button",
                        innerHTML: "<p>\u5EE3\u544A\u8F09\u5165\u4E2D...</p>"
                    })),
                    h(this, ri).onclick = () => {
                        if (h(this, ri).classList.contains("enable")) {
                            this.trigger(this.AD_EVENTS.END),
                                this.destroy();
                            return
                        }
                        window.open("https://ani.gamer.com.tw/animePay.php")
                    }
                    ;
                let e = h(this, ar).createEl("div", {
                    id: qd
                })
                    , s = h(this, ar).createEl("div", {
                        id: $d
                    });
                h(this, ki).appendChild(e),
                    h(this, ki).appendChild(s),
                    this.player.el().appendChild(h(this, ki)),
                    this.player.el().appendChild(h(this, ri))
            }
            ,
            hu = new WeakSet,
            ey = function () {
                h(this, Ct) && h(this, Ct).pubads().addEventListener("slotRenderEnded", e => {
                    switch (e.slot) {
                        case h(this, Mr):
                            V(this, Nr, e.isEmpty ? wi.EMPTY : wi.SUCCESS);
                            break;
                        case h(this, Rr):
                            V(this, Br, e.isEmpty ? wi.EMPTY : wi.SUCCESS);
                            break;
                        default:
                            return
                    }
                    if (h(this, Br) === wi.SUCCESS && h(this, Nr) === wi.SUCCESS && h(this, ki).classList.add("all-loaded"),
                        h(this, Br) === wi.EMPTY && h(this, Nr) === wi.EMPTY) {
                        this.destroy(!0);
                        return
                    }
                    e.advertiserId != null && !e.isEmpty && !h(this, ji) && (this.trigger(this.AD_EVENTS.START),
                        this.clearAdTimeout(),
                        this.player.controlBar.hide(),
                        h(this, ki).classList.remove("vjs-hidden"),
                        h(this, ri).classList.remove("vjs-hidden"),
                        V(this, ji, setInterval(() => {
                            te(this, du, ty).call(this)
                        }
                            , 1e3)))
                }
                )
            }
            ,
            du = new WeakSet,
            ty = function () {
                if (fa(this, fs)._--,
                    fa(this, Gn)._--,
                    h(this, Gn) <= 0) {
                    h(this, ji) && (clearInterval(h(this, ji)),
                        V(this, ji, 0)),
                        this.destroy(),
                        this.trigger(this.AD_EVENTS.END);
                    return
                }
                if (h(this, fs) <= 0) {
                    h(this, ri).innerHTML = h(this, ho),
                        h(this, ri).classList.add("enable");
                    return
                }
                h(this, ri).innerHTML = "<p>" + h(this, uo).replace("%%TIME%%", h(this, fs)) + "</p>"
            }
            ,
            Rg);
    U.registerPlugin("nativeAd", yE);
    var _E = {
        video: "/1017768/AD_rwdweb_ani_videorewarded"
    }
        , TE = (Ng = class extends Nl {
            constructor(e, s) {
                super(e, s);
                j(this, cu);
                j(this, Kt, void 0);
                j(this, Hi, void 0);
                j(this, or, void 0);
                V(this, Kt, window.googletag || {
                    cmd: []
                }),
                    V(this, or, !1),
                    te(this, cu, iy).call(this)
            }
            play() {
                super.play(),
                    h(this, Kt).pubads || this.destroy(!0),
                    h(this, Hi) || (V(this, Hi, h(this, Kt).defineOutOfPageSlot(_E.video, h(this, Kt).enums.OutOfPageFormat.REWARDED).addService(h(this, Kt).pubads())),
                        h(this, Kt).enableServices()),
                    V(this, or, !1),
                    h(this, Kt).display(h(this, Hi)),
                    this.startAdTimeout()
            }
            getAdTimeoutTime() {
                return 3e3
            }
            destroy(e = !1) {
                super.destroy(e),
                    h(this, Hi) && (h(this, Kt).destroySlots([h(this, Hi)]),
                        V(this, Hi, null),
                        V(this, or, !1)),
                    document.querySelector("body").classList.remove("rewardedFix")
            }
        }
            ,
            Kt = new WeakMap,
            Hi = new WeakMap,
            or = new WeakMap,
            cu = new WeakSet,
            iy = function () {
                h(this, Kt).pubads && (h(this, Kt).pubads().addEventListener("rewardedSlotReady", e => {
                    e.slot === h(this, Hi) && (this.clearAdTimeout(),
                        document.querySelector("body").classList.add("rewardedFix"),
                        e.makeRewardedVisible(),
                        this.trigger(this.AD_EVENTS.START))
                }
                ),
                    h(this, Kt).pubads().addEventListener("rewardedSlotGranted", e => {
                        e.slot === h(this, Hi) && V(this, or, !0)
                    }
                    ),
                    h(this, Kt).pubads().addEventListener("rewardedSlotClosed", e => {
                        this.trigger(h(this, or) ? this.AD_EVENTS.END : this.AD_EVENTS.CANCEL),
                            this.destroy()
                    }
                    ))
            }
            ,
            Ng);
    U.registerPlugin("rewardedAd", TE);
    var bE = U.getPlugin("plugin")
        , Ha = [["video"], ["ima"], ["rewarded"], ["native"], ["PAD"]]
        , qa = 30
        , EE = (Bg = class extends bE {
            constructor(e, s) {
                super(e, s);
                j(this, co);
                j(this, Xn);
                j(this, fo);
                j(this, po);
                j(this, fu);
                j(this, pu);
                j(this, mu);
                j(this, Ur);
                j(this, gu);
                j(this, vu);
                j(this, mo);
                j(this, Yn);
                j(this, go);
                j(this, Wn, void 0);
                j(this, Fr, void 0);
                j(this, Mt, void 0);
                j(this, Ps, void 0);
                j(this, Ls, void 0);
                j(this, Os, void 0);
                j(this, Ms, void 0);
                j(this, Kn, void 0);
                j(this, lr, void 0);
                j(this, ps, void 0)
            }
            play(e, s, r) {
                V(this, Fr, e),
                    V(this, Mt, s),
                    V(this, Wn, r),
                    V(this, ps, {}),
                    V(this, Kn, !1),
                    V(this, lr, []),
                    te(this, co, Tc).call(this)
            }
            destroy() {
                h(this, Ps) && h(this, Ps).destroy(),
                    h(this, Ls) && h(this, Ls).destroy(),
                    h(this, Os) && h(this, Os).destroy(),
                    h(this, Ms) && h(this, Ms).destroy()
            }
        }
            ,
            Wn = new WeakMap,
            Fr = new WeakMap,
            Mt = new WeakMap,
            Ps = new WeakMap,
            Ls = new WeakMap,
            Os = new WeakMap,
            Ms = new WeakMap,
            Kn = new WeakMap,
            lr = new WeakMap,
            ps = new WeakMap,
            co = new WeakSet,
            Tc = function () {
                if (!h(this, Mt).enableAd) {
                    h(this, Wn).call(this);
                    return
                }
                switch (te(this, go, Cc).call(this, Ai.SHOW),
                te(this, mo, Sc).call(this)) {
                    case "video":
                        te(this, po, Ec).call(this, qa);
                        break;
                    case "rewarded":
                        te(this, fu, sy).call(this);
                        break;
                    case "ima":
                        te(this, mu, ny).call(this, h(this, Fr));
                        break;
                    case "native":
                        te(this, pu, ry).call(this, qa - te(this, Yn, nh).call(this));
                        break;
                    case "PAD":
                        this.player.pause();
                        let e = getMinorAd();
                        h(this, Mt).adId = e ? e[0] : "",
                            h(this, Mt).adUrl = e ? e[1] : "",
                            h(this, Mt).adSid = e ? e[2] : "",
                            te(this, po, Ec).call(this, qa - te(this, Yn, nh).call(this));
                        break;
                    default:
                        this.player.animeMask().showError(this.player.localize("\u932F\u8AA4\u7684\u5EE3\u544A\u8CC7\u8A0A\uFF01 \u5982\u91CD\u8907\u51FA\u73FE\u6B64\u554F\u984C\u8ACB\u5354\u52A9\u9032\u884C\u56DE\u5831\u3002"))
                }
            }
            ,
            Xn = new WeakSet,
            rh = function () {
                if (te(this, Yn, nh).call(this) >= qa) {
                    te(this, vu, oy).call(this);
                    return
                }
                let e = te(this, mo, Sc).call(this)
                    , s = !1;
                Ha.forEach((o, u) => {
                    s === !1 && o.indexOf(e) !== -1 && (s = u)
                }
                ),
                    s === !1 && te(this, fo, bc).call(this, 1, "Ad sort doesn't exists.");
                let r = h(this, lr).indexOf("ima") !== -1
                    , n = h(this, lr).indexOf("rewarded") !== -1
                    , a = !1;
                for (let o = s + 1; o < Ha.length && !a; o++) {
                    let u = Ha[o];
                    u = u.filter(c => c !== e),
                        r && (u = u.filter(c => c != "ima")),
                        n && (u = u.filter(c => c != "rewarded")),
                        u.length != 0 && (a = u[Math.floor(Math.random() * u.length)])
                }
                a || te(this, fo, bc).call(this, 2, "No more Ad."),
                    h(this, Mt).adType = a,
                    te(this, co, Tc).call(this)
            }
            ,
            fo = new WeakSet,
            bc = function (e, s) {
                this.player.animeMask().showError(this.player.localize(["\u5EE3\u544A\u64AD\u653E\u932F\u8AA4\uFF0C\u8ACB\u91CD\u65B0\u6574\u7406\u3002(" + e + ")", "<p>\u7576\u60A8\u6301\u7E8C\u51FA\u73FE\u6B64\u72C0\u6CC1\u6642\uFF0C\u8ACB\u6AA2\u67E5\u662F\u5426\u70BA\u700F\u89BD\u5668\u64F4\u5145\u5957\u4EF6\u5F71\u97FF\u3002</p>"].join("<br>"))),
                    console.error(s)
            }
            ,
            po = new WeakSet,
            Ec = function (e) {
                h(this, Ps) || (V(this, Ps, this.player.animeAd()),
                    te(this, Ur, Fo).call(this, h(this, Ps), "video"));
                let s = {
                    skipTime: e || qa,
                    skipText: "\u5EE3\u544A %%TIME%% \u79D2\uFF0C\u5982\u4F55\u6D88\u9664\u5EE3\u544A\uFF1F",
                    adId: h(this, Mt).adId,
                    adUrl: h(this, Mt).adUrl
                };
                h(this, Ps).play(s)
            }
            ,
            fu = new WeakSet,
            sy = function () {
                h(this, Ls) || (V(this, Ls, this.player.rewardedAd()),
                    te(this, Ur, Fo).call(this, h(this, Ls), "rewarded")),
                    h(this, Ls).play()
            }
            ,
            pu = new WeakSet,
            ry = function (e) {
                h(this, Os) || (V(this, Os, this.player.nativeAd()),
                    te(this, Ur, Fo).call(this, h(this, Os), "native"));
                let s = {
                    skipText: "\u5EE3\u544A %%TIME%% \u79D2\uFF0C\u5982\u4F55\u6D88\u9664\u5EE3\u544A\uFF1F",
                    skipButtonText: "<p>\u9EDE\u6B64\u8DF3\u904E\u5EE3\u544A</p>",
                    skipCountDown: e
                };
                h(this, Os).play(s)
            }
            ,
            mu = new WeakSet,
            ny = function (e, s = null) {
                h(this, Ms) || (V(this, Ms, this.player.imaAd()),
                    te(this, Ur, Fo).call(this, h(this, Ms), "ima")),
                    h(this, Ms).play(e, s)
            }
            ,
            Ur = new WeakSet,
            Fo = function (e, s) {
                e.on(e.AD_EVENTS.START, () => {
                    te(this, gu, ay).call(this),
                        te(this, go, Cc).call(this, Ai.PLAYING_AD),
                        h(this, ps)[s] = {
                            start: performance.now(),
                            end: performance.now()
                        }
                }
                ),
                    e.on(e.AD_EVENTS.END, () => {
                        h(this, ps)[s] !== void 0 && (h(this, ps)[s].end = performance.now()),
                            h(this, lr).push(s),
                            te(this, Xn, rh).call(this)
                    }
                    ),
                    e.on(e.AD_EVENTS.CANCEL, () => {
                        h(this, ps)[s] = {
                            start: 0,
                            end: 0
                        },
                            h(this, lr).push(s),
                            te(this, Xn, rh).call(this)
                    }
                    ),
                    e.on(e.AD_EVENTS.ERROR, () => {
                        h(this, ps)[s] = {
                            start: 0,
                            end: 0
                        },
                            te(this, Xn, rh).call(this)
                    }
                    )
            }
            ,
            gu = new WeakSet,
            ay = function () {
                h(this, Kn) || (V(this, Kn, !0),
                    this.player.el().classList.add("vjs-anigamer-ad-playing"),
                    fetch("/ajax/videoCastcishu.php?s=" + h(this, Mt).adSid + "&sn=" + h(this, Fr)))
            }
            ,
            vu = new WeakSet,
            oy = function () {
                this.player.el().classList.remove("vjs-anigamer-ad-playing"),
                    fetch("/ajax/videoCastcishu.php?s=" + h(this, Mt).adSid + "&sn=" + h(this, Fr) + "&ad=end").then(() => {
                        h(this, Wn).call(this)
                    }
                    )
            }
            ,
            mo = new WeakSet,
            Sc = function () {
                let e;
                if (h(this, Mt).adType == "facebook") {
                    let s = "";
                    for (let r = 1; r < Ha.length && !s; r++)
                        e = Ha[r],
                            e = e.filter(function (n) {
                                return n != "facebook"
                            }),
                            e.length != 0 && (s = e[Math.floor(Math.random() * Math.floor(e.length))]);
                    h(this, Mt).adType = s
                }
                return h(this, Mt).adType
            }
            ,
            Yn = new WeakSet,
            nh = function () {
                let e = 0;
                return Object.values(h(this, ps)).forEach(function (s) {
                    s.start !== void 0 && s.end !== void 0 && s.end > s.start && (e += s.end - s.start)
                }),
                    Math.floor(e / 1e3)
            }
            ,
            go = new WeakSet,
            Cc = function (e) {
                this.setState({
                    adLoadingState: e
                })
            }
            ,
            Bg);
    U.registerPlugin("adHandler", EE);
    var SE = U.getPlugin("plugin")
        , CE = "https://i2.bahamut.com.tw/anime/loading-apng1f.png"
        , AE = (Fg = class extends SE {
            constructor(e, s = {}) {
                super(e, s);
                j(this, yu);
                j(this, _u);
                j(this, Tu);
                j(this, bu);
                j(this, Eu);
                j(this, Su);
                j(this, Cu);
                j(this, Au);
                j(this, Ns);
                j(this, wu);
                j(this, qi, void 0);
                j(this, jr, void 0);
                j(this, Qn, void 0);
                j(this, Rt, {});
                j(this, Rs, {});
                j(this, ms, {});
                j(this, Xt, void 0);
                j(this, ur, void 0);
                j(this, vi, void 0);
                j(this, hr, void 0);
                this.state = {
                    showAgeGateOnlyOnce: s.showAgeGateOnlyOnce !== void 0 ? !!s.showAgeGateOnlyOnce : !1,
                    enableAgeGate: s.enableAgeGate !== void 0 ? !!s.enableAgeGate : !0,
                    videoSn: 0,
                    playingAd: !1,
                    playingVideo: !1
                },
                    V(this, qi, U.dom),
                    this.player.adHandler().on("statechanged", r => {
                        r.changes.adLoadingState && te(this, Ns, Jr).call(this, r.changes.adLoadingState.to)
                    }
                    ),
                    s.videoSn !== void 0 && s.videoSn != 0 && this.changeSrc(s.videoSn)
            }
            async changeSrc(e) {
                te(this, yu, ly).call(this),
                    this.setState({
                        videoSn: e
                    }),
                    V(this, jr, new AbortController);
                let s = h(this, jr).signal
                    , r = await Ol.get(!0);
                return te(this, _u, uy).call(this, s, e).then(() => (this.player.poster(h(this, Rs).video.cover),
                    te(this, Tu, hy).call(this, s, r))).then(() => (te(this, bu, dy).call(this),
                        !h(this, Rt).vip && !h(this, ms).adId && h(this, ms).adType !== "facebook" ? Promise.reject({
                            code: 2,
                            message: "\u5EE3\u544A\u8B80\u53D6\u932F\u8AA4"
                        }) : (h(this, Rt).showFakeFHD = !h(this, Rt).vip && h(this, Rs).video.quality === "FHD",
                            te(this, wu, gy).call(this, h(this, Rt).r18)))).then(() => te(this, Su, fy).call(this)).then(() => te(this, Eu, cy).call(this, s, r)).catch(n => (s.aborted || te(this, Cu, py).call(this, n),
                                Promise.reject(n)))
            }
            handleStateChanged(e) {
                e.changes.playingAd && (e.changes.playingAd.to ? this.player.addClass("vjs-anigamer-m3u8-ad-playing") : this.player.removeClass("vjs-anigamer-m3u8-ad-playing")),
                    e.changes.videoSn && this.trigger({
                        type: "changeSrc",
                        detail: {
                            videoSn: e.changes.videoSn.to
                        }
                    })
            }
            isVideoLoaded() {
                return this.state.playingVideo
            }
            getVideoInfo() {
                return h(this, Rs)
            }
            getTokenData() {
                return h(this, Rt)
            }
            agreeAgeGate() {
                h(this, hr) && h(this, hr).click()
            }
            isShowAgeGate() {
                return h(this, vi) !== null
            }
            getAgeGateMask() {
                return h(this, vi)
            }
        }
            ,
            qi = new WeakMap,
            jr = new WeakMap,
            Qn = new WeakMap,
            Rt = new WeakMap,
            Rs = new WeakMap,
            ms = new WeakMap,
            Xt = new WeakMap,
            ur = new WeakMap,
            vi = new WeakMap,
            hr = new WeakMap,
            yu = new WeakSet,
            ly = function () {
                this.state.enableAgeGate ? document.querySelector(".top_sky").classList.remove("fullwindow-unlock") : document.querySelector(".top_sky").classList.add("fullwindow-unlock"),
                    h(this, vi) && (h(this, vi).remove(),
                        V(this, vi, null)),
                    this.player.pause(),
                    this.player.adHandler().destroy(),
                    this.player.animeMask().remove(),
                    V(this, Rt, {}),
                    V(this, Rs, {}),
                    this.setState({
                        playingAd: !1,
                        playingVideo: !1
                    }),
                    te(this, Ns, Jr).call(this, Ai.SHOW),
                    h(this, Qn) && this.player.off("loadedmetadata", h(this, Qn)),
                    h(this, jr) && h(this, jr).abort()
            }
            ,
            _u = new WeakSet,
            uy = function (e, s) {
                return Ri.getVideo(e, s).then(r => {
                    if (r.error)
                        return Promise.reject(r.error);
                    V(this, Rs, r.data),
                        this.trigger({
                            type: "videoInfo",
                            detail: {
                                data: h(this, Rs)
                            }
                        })
                }
                ).catch(r => Promise.reject(r))
            }
            ,
            Tu = new WeakSet,
            hy = function (e, s) {
                return h(this, Rt).uuid = te(this, Au, my).call(this),
                    fetch("/ajax/token.php?adID=" + h(this, Rt).adId + "&sn=" + this.state.videoSn + "&device=" + s + "&hash=" + h(this, Rt).uuid, {
                        signal: e
                    }).then(r => r.ok ? r.json() : Promise.reject({
                        code: 1,
                        message: "network error"
                    })).then(r => {
                        if (r.error)
                            return Promise.reject(r.error);
                        for (let n in r)
                            h(this, Rt)[n] = r[n]
                    }
                    ).catch(r => Promise.reject(r))
            }
            ,
            bu = new WeakSet,
            dy = function () {
                let e = getSponsorVideoAd(h(this, Rt).animeSn) || getMajorAd();
                V(this, ms, {
                    adId: e[0],
                    adUrl: e[1],
                    adSid: e[2],
                    adType: e[3],
                    sponsorText: e[4] || "",
                    enableAd: h(this, Rt).time != 1
                });
                let s = getSponsorLogoAd(h(this, Rt).animeSn);
                s && s[5] && (h(this, ms).sponsorText = s[5])
            }
            ,
            Eu = new WeakSet,
            cy = function (e, s) {
                return te(this, Ns, Jr).call(this, Ai.SHOW),
                    fetch("/ajax/m3u8.php?sn=" + this.state.videoSn + "&device=" + s, {
                        signal: e
                    }).then(r => r.ok ? r.json() : Promise.reject({
                        code: 1,
                        message: "network error"
                    })).then(r => r.error ? Promise.reject(r.error) : r.src ? (this.player.src({
                        src: r.src,
                        type: "application/x-mpegURL"
                    }),
                        new Promise((n, a) => {
                            let o = () => {
                                te(this, Ns, Jr).call(this, Ai.REMOVE),
                                    this.setState({
                                        playingAd: !1,
                                        playingVideo: !0
                                    }),
                                    this.trigger({
                                        type: "videoLoaded",
                                        detail: {
                                            videoSn: this.state.videoSn
                                        }
                                    }),
                                    n({
                                        videoSn: this.state.videoSn
                                    })
                            }
                                ;
                            this.player.one("loadedmetadata", o),
                                V(this, Qn, o)
                        }
                        )) : Promise.reject({
                            code: 0,
                            message: "\u7121\u5F71\u7247\u8CC7\u6E90"
                        })).catch(r => {
                            if (!e.aborted)
                                return Promise.reject(r)
                        }
                        )
            }
            ,
            Su = new WeakSet,
            fy = function () {
                return new Promise((e, s) => {
                    this.setState({
                        playingAd: !0,
                        playingVideo: !1
                    }),
                        this.trigger("playingAd"),
                        this.player.adHandler().play(this.state.videoSn, h(this, ms), () => {
                            e()
                        })
                }
                ).catch(e => {
                    debugger
                    console.error(e)
                })
            }
            ,
            Cu = new WeakSet,
            py = function (e) {
                switch (te(this, Ns, Jr).call(this, Ai.REMOVE),
                e.code) {
                    case 1009:
                    case 1016:
                        this.player.animeMask().showLogin(e.message);
                        break;
                    case 1017:
                        this.player.animeMask().showAgeValidateOnly(e.message);
                        break;
                    case 1014:
                        this.player.animeMask().showCharge(e.message);
                        break;
                    case 1018:
                        e.message = "\u56E0\u5075\u6E2C\u5230\u60A8\u8FD1\u671F\u7684\u7570\u5E38\u4F7F\u7528\u884C\u70BA\uFF0C\u5DF2\u9055\u53CD\u670D\u52D9\u689D\u6B3E\u8207\u5DF4\u54C8\u59C6\u7279\u7AD9\u898F\uFF0C\u73FE\u5DF2\u505C\u6B62\u63D0\u4F9B\u670D\u52D9\u3002",
                            this.player.animeMask().showError(this.player.localize(e.message));
                        break;
                    case 1019:
                        this.player.animeMask().showAgeValidateOrEvenCharge(e);
                        break;
                    default:
                        this.player.error(e)
                }
            }
            ,
            Au = new WeakSet,
            my = function () {
                let e = new Date().getTime();
                return window.performance && typeof window.performance.now == "function" && (e += performance.now()),
                    "xxxxxxxxxxxx".replace(/[x]/g, function (r) {
                        let n = (e + Math.random() * 16) % 16 | 0;
                        return e = Math.floor(e / 16),
                            (r == "x" ? n : n & 3 | 8).toString(16)
                    })
            }
            ,
            Ns = new WeakSet,
            Jr = function (e = Ai.HIDE) {
                if (!h(this, Xt)) {
                    let s = h(this, qi).createEl("img", {
                        src: CE
                    });
                    V(this, ur, h(this, qi).createEl("div", {
                        className: "info"
                    })),
                        V(this, Xt, h(this, qi).createEl("div", {
                            className: "video-adHandler-background-blocker"
                        })),
                        h(this, Xt).appendChild(s),
                        h(this, Xt).appendChild(h(this, ur)),
                        this.player.el().appendChild(h(this, Xt))
                }
                switch (e) {
                    case Ai.HIDE:
                        h(this, Xt).classList.remove("loading"),
                            h(this, ur).textContent = "";
                        break;
                    case Ai.SHOW:
                        h(this, Xt).classList.add("loading"),
                            h(this, ur).textContent = "Loading";
                        break;
                    case Ai.PLAYING_AD:
                        h(this, Xt).classList.remove("loading"),
                            h(this, ur).textContent = "\u5EE3\u544A\u64AD\u653E\u4E2D";
                        break;
                    case Ai.REMOVE:
                        if (this.isBlockerStartRemove)
                            return;
                        this.isBlockerStartRemove = !0;
                        let s = 300;
                        h(this, Xt).style.transition = "opacity " + s + "ms ease-out",
                            h(this, Xt).style.opacity = 0,
                            setTimeout(() => {
                                h(this, Xt).remove(),
                                    V(this, Xt, null),
                                    this.isBlockerStartRemove = !1
                            }
                                , s)
                }
            }
            ,
            wu = new WeakSet,
            gy = function (e) {
                if (!this.state.enableAgeGate)
                    return Promise.resolve();
                this.trigger("showAgeGate"),
                    te(this, Ns, Jr).call(this, Ai.HIDE);
                let s = {
                    1: "\u4E00\u822C\u89C0\u773E\u7686\u53EF\u89C0\u8CDE\u3002",
                    2: "\u672A\u6EFF6\u6B72\u4E4B\u5152\u7AE5\u4E0D\u5B9C\u89C0\u8CDE\uFF0C6\u6B72\u4EE5\u4E0A\u672A\u6EFF12\u6B72\u4E4B\u5152\u7AE5\u9700\u7236\u6BCD\u3001\u5E2B\u9577\u6216\u6210\u5E74\u89AA\u53CB\u966A\u4F34\u89C0\u8CDE\u3002",
                    3: "\u672A\u6EFF12\u6B72\u4E4B\u5152\u7AE5\u4E0D\u5B9C\u89C0\u8CDE\u3002",
                    4: "\u672A\u6EFF15\u6B72\u4E4B\u4EBA\u4E0D\u5B9C\u89C0\u8CDE\u3002",
                    5: "\u672A\u6EFF18\u6B72\u4E4B\u4EBA\u4E0D\u5B9C\u89C0\u8CDE\u3002",
                    6: "\u672A\u6EFF18\u6B72\u8005\u4E0D\u5B9C\u89C0\u8CDE\uFF0C\u5167\u5BB9\u53EF\u80FD\u5305\u542B\u5F37\u70C8\u88F8\u9732\u3001\u6027\u806F\u60F3\u3001\u6050\u6016\u3001\u8840\u8165\u7B49\uFF0C\u5FC5\u9808\u901A\u904E\u5E74\u9F61\u9A57\u8B49\u3002"
                }
                    , r = {
                        1: "TW-ALL.png",
                        2: "TW-6TO12.png",
                        3: "TW-12TO15.png",
                        4: "TW-15TO18.png",
                        5: "TW-18UP.png",
                        6: "TW-18UP.png"
                    }
                    , n = h(this, qi).createEl("div", {
                        className: "R18"
                    });
                V(this, hr, null);
                let a = h(this, qi).createEl("div", {
                    className: "video-cover-ncc"
                });
                a.innerHTML = `<div class="ncc-choosearea"><img src="https://i2.bahamut.com.tw/anime/${r[e]}"><div class="ncc-choosebar"><p>${s[e]}</p><div class="ncc-choose-btn"><button class="choose-btn-agree" id="adult">\u540C\u610F</button><button class="choose-btn-disagree" id="not-adult">\u4E0D\u540C\u610F</button></div></div></div>`,
                    n.appendChild(a),
                    V(this, hr, n.querySelector("#adult"));
                let o = n.querySelector("#not-adult");
                if (h(this, ms).sponsorText) {
                    let u = h(this, qi).createEl("div", {
                        className: "sponsorship-text"
                    })
                        , c = h(this, qi).createEl("span", {
                            innerHTML: h(this, ms).sponsorText
                        });
                    u.appendChild(c),
                        n.appendChild(u)
                }
                return V(this, vi, n),
                    this.player.el().appendChild(h(this, vi)),
                    new Promise((u, c) => {
                        h(this, hr).onclick = () => {
                            this.state.showAgeGateOnlyOnce && this.setState({
                                enableAgeGate: !1
                            }),
                                document.querySelector(".top_sky").classList.add("fullwindow-unlock"),
                                h(this, vi) && (h(this, vi).remove(),
                                    V(this, vi, null)),
                                u()
                        }
                            ,
                            o.onclick = () => {
                                setTimeout(() => {
                                    window.location = "http://ani.gamer.com.tw/index.php"
                                }
                                    , 500),
                                    c()
                            }
                    }
                    )
            }
            ,
            Fg);
    U.registerPlugin("m3u8", AE);
    var wE = U.getComponent("Button")
        , DE = class extends wE {
            constructor(t, e) {
                super(t, e)
            }
            buildCSSClass() {
                return "vjs-indent-button vjs-control vjs-show-tip"
            }
            theaterMode() {
                this.addClass("vjs-indent-enable fullwindow-close"),
                    this.el().title = "\u4E00\u822C\u6A21\u5F0F (T)",
                    this.controlText("\u4E00\u822C\u6A21\u5F0F (T)")
            }
            normalMode() {
                this.removeClass("vjs-indent-enable fullwindow-close"),
                    this.el().title = "\u5287\u9662\u6A21\u5F0F (T)",
                    this.controlText("\u5287\u9662\u6A21\u5F0F (T)")
            }
            isTheaterMode() {
                return this.hasClass("vjs-indent-enable")
            }
        }
        ;
    U.registerComponent("TheaterToggle", DE);
    var kE = (Ug = class {
        constructor() {
            j(this, Du);
            j(this, ku);
            j(this, Bs, "");
            j(this, rt, {});
            j(this, gt, {});
            j(this, Jn, 0);
            h(this, rt).title = document.querySelector(".anime_name h1"),
                h(this, rt).uploadTime = document.querySelector(".anime_info_detail p.uploadtime"),
                h(this, rt).downTime = document.querySelector(".anime_info_detail p.is-deathline"),
                h(this, rt).viewCount = document.querySelector(".anime_info_detail .newanime-count span"),
                h(this, rt).rating = document.querySelector(".rating img"),
                h(this, rt).fbComments = document.querySelector(".container-player .fb-comments"),
                h(this, gt).description = document.querySelector('meta[name="description"]'),
                h(this, gt).ogTitle = document.querySelector('meta[property="og:title"]'),
                h(this, gt).ogDescription = document.querySelector('meta[property="og:description"]'),
                h(this, gt).ogUrl = document.querySelector('meta[property="og:url"]'),
                h(this, gt).linkAlternate = document.querySelector('link[rel="alternate"]'),
                h(this, gt).linkCanonical = document.querySelector('link[rel="canonical"]'),
                V(this, Bs, h(this, rt).title.textContent),
                h(this, rt).episode = document.querySelectorAll(".season a"),
                h(this, rt).episode.forEach(t => {
                    t.addEventListener("click", e => {
                        e.preventDefault(),
                            this.onVideoChange(e.target.dataset.aniVideoSn)
                    }
                    )
                }
                ),
                V(this, Jn, Date.now())
        }
        update(t) {
            let e = {};
            for (const [n, a] of Object.entries(t.anime.episodes))
                a.forEach(o => {
                    e[o.videoSn] = o.state
                }
                );
            h(this, rt).episode.forEach(n => {
                switch (e[n.dataset.aniVideoSn]) {
                    case 2:
                        n.parentElement.className = "saw";
                        break;
                    case 1:
                        n.parentElement.className = "playing";
                        break;
                    case 0:
                    default:
                        n.parentElement.className != "" && (n.parentElement.className = "")
                }
            }
            );
            let s = "https://ani.gamer.com.tw/animeVideo.php?sn=" + t.video.videoSn;
            document.title = document.title.replace(h(this, Bs), t.video.title),
                h(this, gt).description.content = h(this, gt).description.content.replace(h(this, Bs), t.video.title),
                h(this, gt).ogTitle.content = h(this, gt).ogTitle.content.replace(h(this, Bs), t.video.title),
                h(this, gt).ogDescription.content = h(this, gt).ogDescription.content.replace(h(this, Bs), t.video.title),
                h(this, gt).ogUrl.href = s,
                h(this, gt).linkAlternate = "android-app://tw.com.gamer.android.animad/https/ani.gamer.com.tw/animeVideo.php?sn=" + t.video.videoSn,
                h(this, gt).linkCanonical.href = s,
                h(this, rt).title.textContent = t.video.title,
                h(this, rt).uploadTime.textContent = "\u4E0A\u67B6\u6642\u9593\uFF1A" + t.video.upTime,
                h(this, rt).viewCount.textContent = te(this, ku, yy).call(this, t.anime.popular),
                h(this, rt).rating.src = te(this, Du, vy).call(this, t.video.rating),
                t.video.downTime ? (h(this, rt).downTime.textContent = "\u9810\u5B9A\u4E0B\u67B6\u65E5\u671F\uFF1A" + t.video.downTime,
                    h(this, rt).downTime.style.display = "") : h(this, rt).downTime.style.display = "none";
            let r = "https://ani.gamer.com.tw/animeVideo.php?sn=" + t.video.videoSn;
            h(this, rt).fbComments.dataset.href != r && window.FB && (document.querySelector(".container-player .fb-comments").dataset.href = "https://ani.gamer.com.tw/animeVideo.php?sn=" + t.video.videoSn,
                window.FB.XFBML.parse()),
                V(this, Bs, t.video.title),
                h(this, Jn) + 60 * 1e3 <= Date.now() && window.googletag && googletag.apiReady && (window.googletag.cmd.push(() => {
                    window.googletag.pubads().refresh()
                }
                ),
                    V(this, Jn, Date.now()))
        }
        onVideoChange(t) { }
    }
        ,
        Bs = new WeakMap,
        rt = new WeakMap,
        gt = new WeakMap,
        Jn = new WeakMap,
        Du = new WeakSet,
        vy = function (t) {
            let e = "https://i2.bahamut.com.tw/acg/";
            switch (t) {
                case 1:
                    return e + "TW-ALL.gif";
                case 2:
                    return e + "TW-6TO12.gif";
                case 3:
                    return e + "TW-12TO18.gif";
                case 4:
                    return e + "TW-15TO18.gif";
                case 5:
                case 6:
                    return e + "TW-18UP.gif";
                default:
                    return ""
            }
        }
        ,
        ku = new WeakSet,
        yy = function (t) {
            return t < 1e3 ? "\u7D71\u8A08\u4E2D" : t < 1e4 ? t : Math.floor(t / 1e3) / 10 + "\u842C"
        }
        ,
        Ug)
        , xE = kE
        , IE = U.getPlugin("plugin")
        , PE = (jg = class extends IE {
            constructor(e, s = {}) {
                super(e, s);
                j(this, xu);
                j(this, Zn, {});
                j(this, ea, !1);
                j(this, nt, {
                    start: 0,
                    end: 0,
                    tmpTime: 0,
                    totalTime: 0,
                    episodeCount: 1
                });
                let r = {
                    idleSecond: 80 * 60,
                    episodeCount: 4
                };
                V(this, Zn, Object.assign(r, s)),
                    te(this, xu, _y).call(this)
            }
            countWatchTime() {
                let e = this.player.currentTime();
                if (h(this, ea)) {
                    V(this, ea, !1),
                        h(this, nt).start = h(this, nt).end = e;
                    return
                }
                h(this, nt).end = e,
                    h(this, nt).tmpTime = h(this, nt).end - h(this, nt).start > 0 ? h(this, nt).end - h(this, nt).start : 0
            }
            increaseEpisode() {
                h(this, nt).episodeCount++,
                    h(this, nt).totalTime += h(this, nt).tmpTime,
                    h(this, nt).end = h(this, nt).start = h(this, nt).tmpTime = 0
            }
            resetIdleRecord() {
                V(this, nt, {
                    start: 0,
                    end: 0,
                    tmpTime: 0,
                    totalTime: 0,
                    episodeCount: 1
                })
            }
            isIdle() {
                return h(this, nt).episodeCount >= h(this, Zn).episodeCount && h(this, nt).totalTime + h(this, nt).tmpTime >= h(this, Zn).idleSecond
            }
        }
            ,
            Zn = new WeakMap,
            ea = new WeakMap,
            nt = new WeakMap,
            xu = new WeakSet,
            _y = function () {
                let e = () => {
                    this.resetIdleRecord(),
                        V(this, ea, !0)
                }
                    ;
                window.addEventListener("keydown", e),
                    window.addEventListener("mousemove", e),
                    window.addEventListener("click", e)
            }
            ,
            jg);
    U.registerPlugin("idleDetector", PE);
    var LE = "//bahamut.akamaized.net/ad/welcome_to_anigamer/playlist.m3u8"
        , OE = 900
        , fg = 1
        , Vd = !0
        , ME = new qb(Ud.NORMAL.NAME, !1)
        , pg = new xE
        , Bl = {
            preSn: animefun.preSn,
            nextSn: animefun.nextSn,
            videoSn: animefun.videoSn,
            quality: animefun.quality
        }
        , zd = document.getElementById("video-container");
    Bl.breakPoint = zd.dataset.videoBreakPoint;
    var $a = document.createElement("video-js");
    $a.className = "video-js vjs-default-skin",
        $a.id = "ani_video",
        $a.poster = zd.dataset.videoPoster;
    var Gd = document.createElement("source");
    Gd.src = LE,
        Gd.type = "application/x-mpegURL",
        $a.appendChild(Gd),
        zd.appendChild($a);
    var Wd;
    switch (!0) {
        case U.browser.IS_ANY_SAFARI:
        case U.browser.IS_EDGE:
            Wd = {
                nativeAudioTracks: !1,
                nativeVideoTracks: !1,
                vhs: {
                    cacheEncryptionKeys: !0,
                    overrideNative: !0,
                    withCredentials: !1,
                    fastQualityChange: !0
                }
            };
            break;
        default:
            Wd = {
                vhs: {
                    cacheEncryptionKeys: !0,
                    withCredentials: !1,
                    fastQualityChange: !0
                }
            }
    }
    var pe = U("ani_video", {
        preload: "auto",
        techOrder: ["html5"],
        html5: Wd,
        aspectRatio: "16:9",
        languages: {
            "zh-TW": {
                Play: "\u64AD\u653E",
                Pause: "\u66AB\u505C",
                "Current Time": "\u76EE\u524D\u6642\u9593",
                "Duration Time": "\u7E3D\u5171\u6642\u9593",
                "Remaining Time": "\u5269\u9918\u6642\u9593",
                "Stream Type": "\u4E32\u6D41\u985E\u578B",
                LIVE: "\u76F4\u64AD",
                Loaded: "\u8F09\u5165\u5B8C\u7562",
                Progress: "\u9032\u5EA6",
                Fullscreen: "\u9032\u5165\u5168\u87A2\u5E55 (F)",
                "Exit Fullscreen": "\u9000\u51FA\u5168\u87A2\u5E55 (F)",
                Mute: "\u975C\u97F3",
                Unmute: "\u53D6\u6D88\u975C\u97F3",
                "Playback Rate": " \u64AD\u653E\u901F\u7387",
                Subtitles: "\u5B57\u5E55",
                "subtitles off": "\u95DC\u9589\u5B57\u5E55",
                Captions: "\u5167\u5D4C\u5B57\u5E55",
                "You aborted the video playback": "\u5F71\u7247\u64AD\u653E\u5DF2\u7D42\u6B62",
                "A network error caused the video download to fail part-way.": "\u7DB2\u8DEF\u932F\u8AA4\u5C0E\u81F4\u5F71\u7247\u4E0B\u8F09\u5931\u6557\u3002",
                "The media could not be loaded, either because the server or network failed or because the format is not supported.": "\u5F71\u7247\u56E0\u683C\u5F0F\u4E0D\u652F\u63F4\u6216\u8005\u4F3A\u670D\u5668\u6216\u7DB2\u8DEF\u7684\u554F\u984C\u7121\u6CD5\u8F09\u5165\u3002",
                "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.": "\u5F71\u7247\u7531\u65BC\u4E00\u4E9B\u554F\u984C\u6216\u4F7F\u7528\u7684\u700F\u89BD\u5668\u4E0D\u652F\u63F4\u7684\u529F\u80FD\u800C\u64AD\u653E\u4E2D\u6B62\u3002",
                "The media is encrypted and we do not have the keys to decrypt it.": "\u5F71\u7247\u5DF2\u52A0\u5BC6\uFF0C\u7121\u6CD5\u89E3\u5BC6\u3002",
                "Video doesn't exist.": "\u932F\u8AA4\u7684\u5F71\u7247\u4F4D\u7F6E\uFF01",
                "Unauthorized devices.": "\u932F\u8AA4\u4EE3\u78BC1\uFF0C\u5F71\u7247\u50B3\u8F38\u4E2D\u65B7\uFF0C\u8ACB\u53C3\u8003<a href='//ani.gamer.com.tw/anime403info.php'>\u53EF\u80FD\u539F\u56E0</a>",
                "Duplicate login.": "\u91CD\u8907\u767B\u5165\uFF0C\u672C\u670D\u52D9\u50C5\u9650\u4E00\u53F0\u88DD\u7F6E\u4F7F\u7528\uFF0C\u8ACB\u66AB\u505C\u5176\u4ED6\u88DD\u7F6E\u64AD\u653E\uFF01",
                "To access the video, please login": "<a href='//user.gamer.com.tw/login.php'>\u8ACB\u5148\u767B\u5165</a>",
                "The video playback was aborted due to a corruption problem.": "\u7DB2\u8DEF\u7570\u5E38\uFF0C\u7121\u6CD5\u53D6\u5F97\u5F71\u7247\uFF01\u8ACB\u5617\u8A66\u91CD\u65B0\u6574\u7406\u9801\u9762",
                "Our Services are available in Taiwan.": "\u672C\u670D\u52D9\u6388\u6B0A\u7BC4\u570D\u50C5\u9650\u53F0\u7063\u5730\u5340\uFF0C\u5982\u679C\u60A8\u70BA\u5916\u570B\u7528\u6236\u6216\u4F7F\u7528\u8B8A\u66F4IP\u7684\u63D2\u4EF6\u6216\u8EDF\u9AD4\uFF0C\u5C07\u7121\u6CD5\u6B63\u5E38\u4F7F\u7528\u672C\u670D\u52D9\u3002",
                "Oops, something went wrong.": "\u64AD\u653E\u5668\u672A\u6B63\u78BA\u8F09\u5165\uFF0C\u53EF\u80FD\u539F\u56E0\u5982\u4E0B\uFF1A <br />1.\u7DB2\u8DEF\u7570\u5E38\uFF0C\u8ACB\u5617\u8A66\u91CD\u65B0\u6574\u7406\u9801\u9762 <br />2.\u53D7\u700F\u89BD\u5668\u7684\u64CB\u5EE3\u544A\u63D2\u4EF6\u6216\u662F\u9632\u6BD2\u8EDF\u9AD4\u5F71\u97FF\uFF0C\u8ACB\u5C07 gamer.com.tw \u52A0\u5165\u767D\u540D\u55AE\u6216\u662F\u95DC\u9589\u63D2\u4EF6\u3002",
                "Sorry, you need to register for three months to use the service.": "\u5F88\u62B1\u6B49\uFF01\u4F7F\u7528\u672C\u670D\u52D9\u9808\u8A3B\u518A\u6EFF\u4E09\u500B\u6708\u3002",
                "Paid Member only.": "\u672C\u52D5\u756B\u50C5\u4F9B\u4ED8\u8CBB\u6703\u54E1\u89C0\u770B\u5594\uFF01\u3002"
            }
        },
        language: "zh-TW",
        controlBar: {
            children: [{
                name: "playToggle",
                id: "playToggle"
            }, {
                name: "progressControl",
                id: "progressControl"
            }, {
                name: "button",
                id: "preEpisode"
            }, {
                name: "button",
                id: "nextEpisode"
            }, {
                name: "currentTimeDisplay",
                id: "currentTimeDisplay"
            }, {
                name: "timeDivider",
                id: "timeDivider"
            }, {
                name: "durationDisplay",
                id: "durationDisplay"
            }, {
                name: "PageFullscreenToggle",
                id: "pageFullscreenToggle"
            }, {
                name: "TheaterToggle",
                id: "theaterToggle"
            }, {
                name: "playbackRateMenuButton",
                id: "playbackRateMenuButton"
            }]
        },
        controls: !0,
        resizeManager: {
            ResizeObserver: null
        },
        playbackRates: [.5, .75, 1, 1.25, 1.5, 1.75, 2],
        inactivityTimeout: 300
    }, () => {
        pe.bigPlayButton.hide(),
            pe.animePlayer({
                enableRightMenuDanmu: !0,
                enableRightMenuDanmuToggle: !0
            }).setPlayerSetup(Vt.NORMAL),
            pe.breakPoint({
                namespace: "ANIME"
            }),
            pe.idleDetector({
                idleSecond: Ud.PARTY.SECOND,
                episodeCount: Ud.PARTY.EPISODE
            }),
            pe.m3u8().on("changeSrc", () => {
                fg = pe.playbackRate(),
                    pe.el().focus(),
                    pe.stopMask().hide()
            }
            ),
            pe.m3u8().on("showAgeGate", () => {
                pe.animePlayer().setPlayerSetup(Vt.SHOW_AGE_GATE)
            }
            ),
            pe.m3u8().on("playingAd", () => {
                pe.breakPoint().stop(),
                    pe.animePlayer().setPlayerSetup(Vt.AD)
            }
            ),
            pe.m3u8().on("videoLoaded", t => {
                pe.playbackRate(fg);
                let e = t.detail.videoSn
                    , s = pe.m3u8().getVideoInfo()
                    , r = pe.m3u8().getTokenData()
                    , n = s.video.prevVideoSn
                    , a = s.video.nextVideoSn;
                pe.animePlayer().setPlayerSetup(Vt.NORMAL),
                    pe.animePlayer().setState({
                        videoSn: e,
                        preVideoSn: n,
                        nextVideoSn: a,
                        isLogin: r.login,
                        showFakeFHD: r.showFakeFHD
                    }),
                    pe.idleDetector().increaseEpisode(),
                    pe.elapse().init(e);
                let o = getSponsorLogoAd(s.animeSn);
                if (!s.vip && o) {
                    let u = {
                        link: o[1] || "",
                        title: o[5] || "",
                        imgSrc: o[4] || ""
                    };
                    pe.animePlayer().setState({
                        enableAdLogo: !0,
                        adLogoSetup: u
                    })
                }
                pe.one("play", () => {
                    if (!Vd) {
                        Vd = !0;
                        return
                    }
                    let u = window.AnimeRoute.getUrlParam().get("t");
                    if (u != null)
                        pe.currentTime(ja.timeToSeconds(u));
                    else {
                        let c = pe.breakPoint().get(pe.m3u8().state.videoSn)
                            , f = s.video.breakpoint;
                        switch (!0) {
                            case (!!c.watchTime && !!f.watchTime):
                                c = c.watchTime > f.watchTime ? c.breakPoint : f.breakPoint;
                                break;
                            case !!c.watchTime:
                                c = c.breakPoint;
                                break;
                            case !!f.watchTime:
                                c = f.breakPoint;
                                break;
                            default:
                                c = 0
                        }
                        c != 0 && Math.abs(pe.duration() - parseInt(c, 10)) > 60 && pe.currentTime(c)
                    }
                    pe.breakPoint().startRecord(e)
                }
                ),
                    pe.one("play", async () => {
                        let u = await Ol.get();
                        Ri.checkLock(pe.m3u8().state.videoSn, u)
                    }
                    ),
                    pe.one("timeupdate", () => {
                        Ri.videoStart(pe.m3u8().state.videoSn)
                    }
                    ),
                    pe.play()
            }
            ),
            pe.m3u8().on("videoInfo", t => {
                let e = t.detail.data
                    , s = e.video.videoSn;
                pg.update(e),
                    pe.animePlayer().setState({
                        danmuVideoSn: s,
                        videoType: e.video.type
                    }),
                    Bl.videoSn = s
            }
            ),
            pe.m3u8().changeSrc(Bl.videoSn),
            pe.on("timeupdate", () => {
                pe.m3u8().isVideoLoaded() && (pe.elapse().countTotalWatchTime(),
                    pe.idleDetector().countWatchTime())
            }
            ),
            pe.on(["play", "pause", "ended"], () => {
                pe.m3u8().isVideoLoaded() && pe.elapse().videoStateChanged()
            }
            ),
            pe.on("contextmenu", function (t) {
                t.preventDefault()
            }),
            pe.stopMask().on("nextEpisode", () => {
                Vd = !1;
                let e = pe.m3u8().getVideoInfo().video.nextVideoSn;
                pe.m3u8().setState({
                    enableAgeGate: !1
                }),
                    window.history.pushState({
                        videoSn: e
                    }, "", "?sn=" + e),
                    window.AnimeRoute.triggerPageParamChange("animeVideo", {
                        sn: e
                    })
            }
            ),
            pe.on("ended", function () {
                if (pe.m3u8().isVideoLoaded()) {
                    let t = () => {
                        let e = pe.m3u8().getVideoInfo()
                            , s = e.video.title
                            , r = e.video.nextVideoSn;
                        pe.idleDetector().isIdle() && r > 0 ? pe.stopMask().showBreak(s) : pe.stopMask().show(s, r > 0, ME.isEnable())
                    }
                        ;
                    if (pe.elapse().getTotalTime() >= OE) {
                        pe.stopMask().showQuiz(() => {
                            t()
                        }
                        );
                        return
                    }
                    t()
                }
            }),
            pe.animePlayer().on("videoChange", t => {
                t.detail.videoSn && (window.history.pushState({
                    videoSn: t.detail.videoSn
                }, "", "?sn=" + t.detail.videoSn),
                    pe.m3u8().setState({
                        enableAgeGate: !0
                    }),
                    window.AnimeRoute.triggerPageParamChange("animeVideo", {
                        sn: t.detail.videoSn
                    }))
            }
            ),
            pg.onVideoChange = t => {
                t && (window.history.pushState({
                    videoSn: t
                }, "", "?sn=" + t),
                    pe.m3u8().setState({
                        enableAgeGate: !0
                    }),
                    window.AnimeRoute.triggerPageParamChange("animeVideo", {
                        sn: t
                    }))
            }
            ,
            window.AnimeRoute.onPageParamChange("animeVideo", function (t) {
                if (t.sn == Bl.videoSn && t.timeCode) {
                    if (pe.m3u8().isShowAgeGate()) {
                        pe.m3u8().agreeAgeGate();
                        return
                    }
                    if (pe.stopMask().isShowQuiz() || pe.m3u8().state.playingAd)
                        return;
                    if (pe.seeking()) {
                        pe.one("seeked", () => {
                            pe.currentTime(ja.timeToSeconds(t.timeCode)),
                                pe.el().focus()
                        }
                        );
                        return
                    }
                    pe.currentTime(ja.timeToSeconds(t.timeCode)),
                        pe.el().focus()
                } else
                    t.sn && pe.m3u8().changeSrc(t.sn)
            }),
            window.addEventListener("popstate", t => {
                t.state && t.state.videoSn && pe.m3u8().changeSrc(t.state.videoSn)
            }
            )
    }
    )
}
)();
